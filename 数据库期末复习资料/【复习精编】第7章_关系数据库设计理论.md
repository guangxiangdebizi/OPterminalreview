# 【复习精编】第7章 - 关系数据库设计理论

> 数据库期末复习 - 核心知识点整理

---

## 一、问题的提出

### 1.1 数据库设计要解决的问题
- 应该构造几个关系模式？
- 每个关系模式包括哪些属性？

### 1.2 什么是好的模式？
- ✅ 不会发生插入异常
- ✅ 不会发生删除异常
- ✅ 不会发生更新异常
- ✅ 数据冗余应尽可能少

### 1.3 不良模式示例

**关系模式**：WAE(仓库号，所在区域，区域主管，设备号，数量)

**语义**：
1. 一个区域有多个仓库，一个仓库只能属于一个区域
2. 一个区域只有一个区域主管
3. 一个仓库可以存放多种设备，每种设备可以存放在多个仓库中
4. 每个仓库的每种设备都有一个库存数量

**存在的问题**：
1. ❌ **数据冗余太大**：浪费大量的存储空间
2. ❌ **更新异常**：更新代价大，可能导致数据不一致
3. ❌ **插入异常**：该插的数据插不进去
4. ❌ **删除异常**：不该删除的数据不得不删，造成某些数据丢失

### 1.4 问题的原因和解决方法

**原因**：模式中的某些数据依赖引起的

**解决方法**：
- 通过分解关系模式来消除其中不合适的数据依赖
- 用规范化理论改造关系模式

**正确的分解**：
```
WAE → W(仓库号，所在区域)
      A(区域，区域主管)
      WE(仓库号，设备号，数量)
```

---

## 二、基本概念

### 2.1 函数依赖（Functional Dependency）

#### 定义
设R(U)是一个属性集U上的关系模式，X和Y是U的子集。
若对于R(U)的任意一个可能的关系r，对于t1, t2 ∈ r：
- 若 t1[X] = t2[X]，则 t1[Y] = t2[Y]
- 则称X函数决定Y或Y函数依赖于X，记作 **X→Y**

#### 示例
```
仓库号 → 所在区域
所在区域 → 区域主管
(仓库号，设备号) → 数量
```

#### 重要说明
1. **语义范畴**：只能根据数据的语义来确定函数依赖
   - 例："区域主管→所在区域"只有在不允许有同名人的条件下成立

2. **所有实例**：函数依赖是指R的所有关系实例均要满足的约束条件

3. **时间无关性**：函数依赖存在的时间无关性

#### 函数依赖与联系类型的关系
- **一对一**联系：X → Y，Y → X，即 X ↔ Y
- **多对一**联系：X → Y，但 Y ↮ X
- **多对多**联系：X与Y之间不存在任何函数依赖

### 2.2 平凡函数依赖与非平凡函数依赖

#### 定义
在关系模式R(U)中，对于U的子集X和Y：
- **非平凡函数依赖**：若 X→Y，但 Y ⊄ X
- **平凡函数依赖**：若 X→Y，但 Y ⊆ X

#### 示例
```
非平凡函数依赖：(仓库号，设备号) → 数量
平凡函数依赖：  (仓库号，设备号) → 仓库号
               (仓库号，设备号) → 设备号
```

**注意**：对任一关系模式，平凡函数依赖必然存在，一般讨论非平凡函数依赖

### 2.3 完全函数依赖与部分函数依赖

#### 定义
设R(U)是一个关系模式，X和Y是U的子集：
- **完全函数依赖**：X→Y，但对于X的任何真子集X'，都有X'↛Y，记作 **X \xrightarrow{F} Y**
- **部分函数依赖**：X→Y，但存在X的真子集X'，使得X'→Y，记作 **X \xrightarrow{P} Y**

#### 图示理解
```
完全函数依赖：
X = {A, B}  →  Y
但 A ↛ Y 且 B ↛ Y

部分函数依赖：
X = {A, B}  →  Y
且存在 A → Y（或 B → Y）
```

### 2.4 传递函数依赖与直接函数依赖

#### 定义
在关系模式R(U)中，如果：
- X→Y
- Y↛X（即不是 X↔Y）
- Y→Z
- 则称 **Z传递函数依赖于X**，记作 **X \xrightarrow{t} Z**

如果 Y→X（即 X↔Y），则Z对X是直接函数依赖

#### 示例
```
仓库号 → 所在区域
所在区域 → 区域主管
可得到传递函数依赖：仓库号 \xrightarrow{t} 区域主管
```

### 2.5 码（Key）

#### 定义
设K为R<U,F>中的属性或属性组合：
- **候选码**：若 K \xrightarrow{F} U，则K称为R的一个候选码
- **主码**：若关系模式R有多个候选码，则选定其中的一个作为主码
- **主属性**：包含在任何一个候选码中的属性
- **非主属性**：不包含在任何一个码中的属性
- **全码**：整个属性组全是码

#### 示例
```
WAE(仓库号，所在区域，区域主管，设备号，数量)
码：(仓库号, 设备号)
主属性：仓库号, 设备号
非主属性：所在区域、区域主管和数量
```

---

## 三、规范化（范式）

### 3.1 范式概述

#### 定义
- **范式**：符合某一种级别的关系模式的集合
- **规范化**：将一个低级范式的关系模式转换为若干个高一级范式的关系模式集合的过程

#### 范式层次
```
5NF ⊂ 4NF ⊂ BCNF ⊂ 3NF ⊂ 2NF ⊂ 1NF
```

某一关系模式R为第n范式，可简记为 **R∈nNF**

#### 规范化的基本思想
- 消除不合适的数据依赖
- 采用"一事一地"的模式设计原则
- 让一个关系描述一个概念、一个实体或者实体间的一种联系
- 若多于一个概念就把它"分离"出去
- 规范化实质上是概念的单一化

### 3.2 第一范式（1NF）

#### 定义
如果一个关系模式R的所有属性都是不可分的基本数据项，则 **R∈1NF**

#### 说明
- 第一范式是对关系模式的最起码要求
- 不满足第一范式的数据库模式不能称为关系数据库
- 但满足第一范式的关系模式并不一定是一个好的关系模式

#### 示例
```
学号 | 姓名 | 性别 | 手机 | 固定电话
-----|------|------|------|----------
0022102 | 王雪莲 | 女 | 15812345678 | 68021234

R∈1NF（所有属性都是不可分的基本数据项）
```

### 3.3 第二范式（2NF）

#### 定义
若关系模式 R∈1NF，并且每一个非主属性都完全函数依赖于R的码，则 **R∈2NF**

**即：消除非主属性对码的部分依赖**

#### WAE示例分析

**关系模式**：WAE(仓库号，所在区域，区域主管，设备号，数量)

**码**：(仓库号, 设备号)

**函数依赖**：
```
(仓库号, 设备号) → 数量  【完全函数依赖】
仓库号 → 所在区域        【部分函数依赖】
仓库号 → 区域主管        【部分函数依赖】
```

**结论**：
- 非主属性"所在区域"和"区域主管"部分函数依赖于码
- WAE∈1NF，但 WAE∉2NF

#### 规范化到2NF

**分解方案**：
```
WE（仓库号，设备号，数量）  → WE∈2NF
WA（仓库号，所在区域，区域主管） → WA∈2NF
```

#### 2NF存在的问题
虽然消除了部分函数依赖，但仍存在问题：
1. 若某个区域刚刚设立还没有仓库，则无法插入（插入异常）
2. 有一定的数据冗余（多个仓库处于同一区域时，区域主管被多次存储）
3. 更新某区域的区域主管，需要逐一修改所有记录（更新异常）

**原因**：存在传递函数依赖

### 3.4 第三范式（3NF）

#### 定义
如果关系模式 R∈2NF，且每个非主属性都不传递函数依赖于R的候选码，则 **R∈3NF**

**即：消除非主属性对码的部分依赖和传递依赖**

#### WA关系分析

**关系模式**：WA（仓库号，所在区域，区域主管）

**码**：仓库号

**函数依赖**：
```
仓库号 → 所在区域
所在区域 → 区域主管
可得：仓库号 \xrightarrow{t} 区域主管  【传递依赖】
```

**结论**：WA∈2NF，但 WA∉3NF

#### 规范化到3NF

**分解方案**：
```
W（仓库号，所在区域）     → W∈3NF
A（所在区域，区域主管）   → A∈3NF
```

#### 3NF存在的问题
- 将2NF关系分解为多个3NF关系，可以减轻插入异常、删除异常、数据冗余等问题
- 但并不能完全消除关系模式中的各种异常情况和数据冗余
- **原因**：可能存在主属性对码的部分和传递依赖

### 3.5 BC范式（BCNF）

#### 定义
设关系模式 R∈1NF，若对于R的每个函数依赖 X→Y：
- 若 Y ⊄ X
- 则 X 必含有候选码
- 则 **R∈BCNF**

**即：每一个决定因素（决定属性集）都包含码**

#### 重要性质
1. **BCNF ⊂ 3NF**（所有BCNF都是3NF）
2. **3NF ⊄ BCNF**（有些3NF不是BCNF）

#### 证明：BCNF ⊂ 3NF
**反证法**：
- 假设 R∈BCNF，但 R∉3NF
- 按3NF定义，一定有非主属性对码的传递依赖
- 即存在：X→Y，Y→Z，Y↛X，且Z为非主属性
- 由Y→Z，按BCNF定义，Y含有码，则Y→X
- 这与Y↛X矛盾
- 所以：R∈3NF

#### BCNF的特点
若 R∈BCNF，则：
- 所有非主属性对每一个候选码都是完全函数依赖
- 所有主属性对每一个不包含它的候选码都是完全函数依赖
- 没有任何属性完全函数依赖于非码的任何一组属性

#### 示例1：属于BCNF
```
Course（Cno, Credit, Pcno）
函数依赖：
  Cno → Credit
  Cno → Pcno
码：Cno
决定因素：Cno（包含候选码）
结论：Course∈BCNF，且 Course∈3NF
```

#### 示例2：属于BCNF
```
SCP（S, C, P）
说明：
  每一个学生选修每一门课程都有一个固定的名次
  每一门课程中每一名次只对应一个学生
函数依赖：
  (S，C)→P
  (C，P)→S
候选码：(S，C) 和 (C，P)
主属性：S、C、P（全是主属性）
决定因素：(S，C)和(C，P)（都包含候选码）
结论：SCP∈BCNF，且 SCP∈3NF
```

#### 示例3：不属于BCNF
```
WES(仓库号, 设备号, 职工号)
说明：
  一个仓库可以有多个职工
  一个职工仅在一个仓库工作
  每个仓库一种设备仅由一名职工保管
  但每名职工可以保管多种设备
函数依赖：
  职工号 → 仓库号
  (仓库号, 设备号) → 职工号
码：(仓库号, 设备号)
决定因素："职工号"不包含候选码
结论：WES∈3NF，但 WES∉BCNF
问题：某位职工刚分配到一个仓库工作，但尚未负责具体设备，
      这样的信息就无法插入（插入异常）
```

#### 重要结论
- ⚠️ 关系模式R中的属性全部是主属性，则R必定是3NF
- ⚠️ 任何一个二元关系必定属于BCNF（基于函数依赖最高范式）

### 3.6 第四范式（4NF）

#### 多值依赖问题引入

**示例**：Teaching(C, T, B)
- C：课程
- T：教师
- B：参考书
- 说明：某一门课程由多个教师讲授，他们使用相同的一套参考书

**问题**：
- Teaching具有唯一候选码(C, T, B)，即全码
- Teaching∈BCNF
- 但仍存在问题：
  1. 数据冗余：有多少名任课教师，参考书就要存储多少次
  2. 插入异常：增加一名任课教师，有多少本参照书就必须插入多少个元组
  3. 删除异常：去掉一本参考书，有多少名教师就必须删除多少个元组
  4. 修改异常：修改一本参考书，有多少名教师就必须修改多少个元组

**产生原因**：存在多值依赖

#### 多值依赖定义

设R(U)是属性集U上的一个关系模式，X、Y、Z是U的子集，并且Z＝U－X－Y。

**多值依赖** X→→Y 成立当且仅当：
- 对R的任一关系r
- 给定一对(x, z)值
- 有一组Y值与之对应
- 且这组值仅仅决定于X值而与Z值无关

#### 示例
```
Teaching（C, T, B）
对于C的每一个值，T总有一组值与之对应，而与B的取值无关
则：C→→T
且：C→→B
```

#### 多值依赖分类
- **平凡多值依赖**：若 X→→Y，而 Z＝φ
- **非平凡多值依赖**：若 X→→Y，而 Z≠φ

#### 多值依赖的性质

1. **对称性**：
   ```
   若 X→→Y，则 X→→Z
   其中 Z＝U－X－Y
   ```
   可以用完全二分图直观地表示

2. **传递性**：
   ```
   若 X→→Y，Y→→Z
   则 X→→Z－Y
   ```

3. **合并性**：
   ```
   若 X→→Y，X→→Z
   则 X→→Y∪Z
   ```

4. **分解性**：
   ```
   若 X→→Y，X→→Z
   则 X→→Y∩Z
       X→→Y－Z
       X→→Z－Y
   ```

5. **函数依赖是多值依赖的特殊情况**：
   ```
   若 X→Y，则 X→→Y
   ```

#### 第四范式定义

关系模式 R∈1NF，如果对于R的每个非平凡多值依赖 X→→Y（Y ⊄ X）：
- X 都含有候选码
- 则 **R∈4NF**

**即：消除各属性间非平凡且非函数依赖的多值依赖**

#### 4NF的特点
- 允许出现函数依赖（非平凡多值依赖）
- 允许出现平凡多值依赖
- **4NF ⊂ BCNF**

#### 证明：4NF ⊂ BCNF
**反证法**：
- 假设 R∈4NF，但 R∉BCNF
- 按BCNF定义，一定有一个决定因素不包含码
- 即存在：X→Y，Y ⊄ X，且X中不含有码
- 由于函数依赖是多值依赖的特殊情况，可得 X→→Y
- 按4NF定义，X一定含有码
- 这与X中不含有码矛盾
- 所以：R∈BCNF

#### 规范化到4NF

**原关系**：Teaching(C, T, B)
- 存在非平凡的多值依赖 C→→T
- C不是候选码
- 候选码是(C,T,B)，即全码

**分解方案**：
```
CT(C, T)  → CT∈4NF
CB(C, B)  → CB∈4NF
```

其中：C→→T，C→→B 是平凡多值依赖

#### 范式总结
- 若只考虑函数依赖，则BCNF为最高范式
- 若考虑多值依赖，则4NF为最高范式
- 若消除了4NF中的连接依赖，可以得到更为规范化的5NF

---

## 四、规范化步骤

### 4.1 规范化流程图

```
                1NF
                 ↓
消除非主属性对码   2NF
的部分函数依赖     ↓
                3NF
消除非主属性对码   ↓
的传递函数依赖   BCNF
                 ↓
消除主属性对码的  4NF
部分和传递依赖
                 ↓
消除非平凡且非
函数依赖的多值依赖
```

### 4.2 注意事项
- ⚠️ 不能说规范化程度越高的关系模式就越好
- ⚠️ 必须对现实世界的实际情况和用户应用需求作进一步分析
- ⚠️ 确定一个合适的、能够反映现实世界的模式
- ⚠️ 规范化步骤可以在其中任何一步终止

---

## 五、判断范式的步骤

给定关系模式和函数依赖集合，判断达到的最高范式：

### 步骤
1. 求出给定关系的函数依赖和候选码（可能不止一个）
2. 根据码，写出主属性和非主属性
3. 判断是否满足第一范式（属性的值域是否可以分解）
4. 判断是否满足第二范式（非主属性对码的部分函数依赖）
5. 判断是否满足第三范式（非主属性对码的传递函数依赖）
6. 判断是否满足BCNF范式（主属性对码的传递和部分函数依赖）

---

## 六、典型例题

### 例题1
**题目**：已知关系模式R<U,F>
```
U={A,B,C,D}
F={A→B, A→D, A→C, B→D, B→C}
```
在函数依赖范围内该关系属于的最高范式是什么？

**解答**：
1. **求候选码**：
   - 候选码为：AB和AC

2. **确定主属性和非主属性**：
   - 主属性：A、B、C
   - 非主属性：D

3. **判断范式**：
   - R的所有属性值域都不可再分 → R∈1NF
   - 非主属性D不存在对任何码的部分函数依赖 → R∈2NF
   - 非主属性D不存在对任何码的传递函数依赖 → R∈3NF
   - 有函数依赖 B→C，而B不是关系R的码 → R∉BCNF

**结论**：R∈3NF

### 例题2
**题目**：已知关系模式R<U,F>
```
U={A,B,C,D,E,F}
F={A→B, C→D∪F, A∪C→E, D→F}
```
在函数依赖范围内该关系属于的最高范式是什么？

**解答**：
1. **求候选码**：
   - 候选码为：AC

2. **确定主属性和非主属性**：
   - 主属性：A、C
   - 非主属性：B、D、E、F

3. **判断范式**：
   - R的所有属性值域都不可再分 → R∈1NF
   - 存在函数依赖 A→B，C→D∪F
   - A和C均不是关系的码
   - 存在非主属性B、D、F对码的部分函数依赖 → R∉2NF

**结论**：R∈1NF

### 例题3
**题目**：某商业集团数据库中有一关系模式R如下：
```
R(商店编号，商品编号，数量，部门编号，负责人)
```
规定：
1. 每个商店的每种商品只在一个部门销售
2. 每个商店的每个部门只有一个负责人
3. 每个商店的每种商品只有一个库存数量

**问题**：
1. 根据上述规定，写出关系模式R的基本函数依赖
2. 找出关系模式R的候选码
3. 试问关系模式R最高已经达到第几范式？为什么？
4. 如果R不属于3NF，请将R分解成3NF模式集

**解答**：
1. **函数依赖**：
   ```
   (商店编号，商品编号) → 部门编号
   (商店编号，部门编号) → 负责人
   (商店编号，商品编号) → 数量
   ```

2. **候选码**：
   ```
   (商店编号，商品编号)
   ```

3. **范式判断**：
   - 存在非主属性"负责人"对候选码(商店编号、商品编号)的传递函数依赖
   - 但无部分函数依赖
   - 所以 R∈2NF，但 R∉3NF

4. **分解成3NF**：
   ```
   R1(商店编号，商品编号，数量，部门编号)
   R2(商店编号，部门编号，负责人)
   ```

---

## 七、考试重点总结

### 7.1 核心概念（必考）
1. ✅ 函数依赖的定义
2. ✅ 完全函数依赖 vs 部分函数依赖
3. ✅ 传递函数依赖 vs 直接函数依赖
4. ✅ 候选码、主码、主属性、非主属性
5. ✅ 1NF、2NF、3NF、BCNF、4NF的定义和区别
6. ✅ 范式之间的包含关系：5NF⊂4NF⊂BCNF⊂3NF⊂2NF⊂1NF

### 7.2 常考题型

#### 概念题
1. 什么是函数依赖？
2. 什么是完全函数依赖和部分函数依赖？
3. 什么是传递函数依赖？
4. 什么是候选码、主码、主属性、非主属性？
5. 各个范式的定义是什么？
6. 各个范式之间的关系是什么？

#### 判断题
1. 属于BCNF的关系一定属于3NF（✅）
2. 属于3NF的关系一定属于BCNF（❌）
3. 一个表只能有一个候选码（❌）
4. 关系模式中的属性全部是主属性，则一定是3NF（✅）
5. 任何一个二元关系必定属于BCNF（✅）

#### 计算题
1. 给定关系模式和函数依赖，求候选码
2. 给定关系模式和函数依赖，判断属于第几范式
3. 将不符合要求的关系模式分解为更高范式

### 7.3 记忆技巧

#### 范式消除的依赖
```
1NF → 2NF：消除非主属性对码的部分函数依赖
2NF → 3NF：消除非主属性对码的传递函数依赖
3NF → BCNF：消除主属性对码的部分和传递函数依赖
BCNF → 4NF：消除非平凡且非函数依赖的多值依赖
```

#### 判断口诀
1. **看属性**：是否可分 → 1NF
2. **看部分**：非主属性对码是否有部分依赖 → 2NF
3. **看传递**：非主属性对码是否有传递依赖 → 3NF
4. **看决定因素**：所有决定因素是否都包含码 → BCNF
5. **看多值**：是否有非平凡且非函数依赖的多值依赖 → 4NF

### 7.4 重点对比

| 范式 | 要求 | 关键点 |
|------|------|--------|
| 1NF | 属性不可分 | 最基本要求 |
| 2NF | 消除部分依赖 | 针对非主属性 |
| 3NF | 消除传递依赖 | 针对非主属性 |
| BCNF | 决定因素都包含码 | 针对所有属性 |
| 4NF | 消除多值依赖 | 针对非平凡多值依赖 |

---

**复习建议**：
1. 重点掌握1NF、2NF、3NF、BCNF的定义和区别
2. 熟练掌握求候选码的方法
3. 熟练掌握判断范式的步骤
4. 多做练习题，特别是分解关系模式的题目
5. 理解各种函数依赖的概念和区别
6. 记住范式之间的包含关系和消除的依赖类型

