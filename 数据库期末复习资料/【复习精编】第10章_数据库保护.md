# 【复习精编】第10章 - 数据库保护

> 数据库期末复习 - 核心知识点整理

---

## 一、事务的概念

### 1.1 事务的定义

**事务（Transaction）**：一系列数据库操作序列：
- 一条或一组SQL语句
- 存储过程或其中的一部分
- 是一个完整的操作，是一个整体——它或者完全执行，或者完全不执行
- 是数据库应用程序的基本逻辑单元

### 1.2 事务的ACID性质 ⭐⭐⭐

#### （1）原子性（Atomicity）
- 每个事务的所有操作要么被成功地执行，要么一个也不被执行
- 事务是不可分割的工作单位

#### （2）一致性（Consistency）
- 一个事务的正确执行必须使数据库从一个正确状态转换为另一个正确的状态
- **例**：从帐户A转10000元到帐户B
  - `UPDATE account SET 余额=余额-10000 WHERE 帐号=A`
  - `UPDATE account SET 余额=余额+10000 WHERE 帐号=B`
  - 如果只执行第一条语句，数据库将出现不正确状态

#### （3）隔离性（Isolation）
- 多个并发事务之间不能相互干扰
- 并发不影响事务的执行
- **例**：多个售票窗口同时售火车票（多个并发事务），它们之间互不影响

#### （4）持续性（Durability）
- 事务对数据库的更新必须是永久的
- 事务一旦提交，则永久改变数据库中的数据

### 1.3 事务的状态

#### 状态转换图

```
活动状态 → 部分提交状态 → 提交状态（正常结束）
   ↓
失败状态 → 异常结束状态
```

**各状态说明**：

1. **活动状态（Active）**
   - 事务开始运行就进入活动状态（BEGIN-TRANSACTION）
   - 直到部分提交或失败

2. **部分提交状态（Partially Committed）**
   - 事务执行完最后一条语句（END-TRANSACTION）
   - 把事务的所有操作对数据库的影响存入数据库

3. **失败状态（Failed）**
   - 发现一个事务不能正常运行下去（ABORT-TRANSACTION）
   - DBMS消除事务中所有操作对数据库和其他事务的影响

4. **异常结束状态（Aborted）**
   - 失败事务对数据库和其他事务的影响被消除
   - 数据库恢复到该事务开始执行前的状态

5. **提交状态（Committed）**
   - 事务成功完成所有操作（COMMIT-TRANSACTION）
   - 所有操作对数据库的影响都已永久地存入数据库
   - 事务正常结束

### 1.4 事务控制语句

**显式事务**：
```sql
BEGIN TRANSACTION      -- 开始事务
COMMIT TRANSACTION     -- 提交事务
ROLLBACK TRANSACTION   -- 回滚事务
```

**隐式事务**：
- 如果语句中没有用到BEGIN或COMMIT
- 每个DML语句都会隐式地构造自己的事务

---

## 二、并发控制

### 2.1 并发控制的概念

#### 事务的执行方式

**串行事务**：
- 一个事务结束，另一个事务才开始

**并行事务**：
- 多个事务同时执行
- **单处理器**：分时并发（交叉并发）
- **多处理器**：每个处理器处理一个事务，同时并行

**优点**：减少处理机的空闲时间，提高系统效率

#### 并发控制的必要性

**存在问题**：多个事务同时存取同一数据，导致数据一致性被破坏

**五大并发问题**：

1. ❌ **数据更新丢失问题（Lost Update）**
   - 两个事务读取同一数据并修改
   - 后写入的覆盖了先写入的更新

2. ❌ **读脏数据问题（Dirty Read）**
   - 事务T1修改了数据X
   - 事务T2读取了修改后的X
   - 但T1失败回滚，T2读到的是无效数据

3. ❌ **错误聚集计算问题**
   - 一个事务在计算聚集函数（如SUM）
   - 另一个事务正在更新相关数据
   - 导致计算结果错误

4. ❌ **不可重复读问题（Non-repeatable Read）**
   - 事务T1读取数据C
   - 并发事务T2修改数据C并提交
   - 事务T1再次读取数据C，两次读取结果不一致

5. ❌ **幻影数据行问题（Phantom Row）**
   - 事务A读取满足某条件的数据
   - 并发事务B插入满足该条件的新数据并提交
   - 事务A再次读取，发现多出一些数据
   - 同一事务中两次读取的记录数不一致

### 2.2 事务的调度

#### 调度的定义

**调度（Schedule）**：N个事务的所有操作的一个序列，表示这些操作的执行顺序

#### 调度的类型

**1. 串行调度**
- 一个事务的所有操作都执行完后才执行另一个事务的所有操作
- 对于N个事务，有N!个串行调度
- 保证数据一致性

**2. 并行调度**
- 除串行调度外的其它调度
- 不是所有并行调度都能保证数据一致性

#### 调度的可串行性

**可串行调度**：N个事务的调度S等价于一个串行调度

**目标**：确保并行调度的结果与某个串行调度的结果相同

---

## 三、基于锁的并发控制协议

### 3.1 锁的基本概念

**锁（Locking）**：
- 并发调度的主要技术——封锁
- 事务对需操作的数据进行加锁，以实现数据的互斥访问
- 当一个事务访问某个数据项时，其他事务都不能修改该数据项
- 对数据的访问均必须加锁

### 3.2 锁的类型

#### 共享锁（Share lock，S锁）

**定义**：读锁

**特点**：
- 多个事务可对同一数据重复申请加读锁
- 事务T对数据Q加了S锁，其它事务可再对数据Q加S锁
- 但不能对数据Q加X锁，直到T释放数据Q上的S锁

**操作**：`LOCK-S(Q)`

#### 互斥锁（又称排它锁）（eXclusive lock，X锁）

**定义**：写锁

**特点**：
- 一旦事务T对数据Q加上了X锁，只允许T对其进行读写
- 其他事务需等T释放X锁之后，才能获锁
- 其它事务不能对数据Q再加S锁和X锁

**操作**：`LOCK-X(Q)`

#### 解锁操作

**操作**：`UNLOCK(Q)` - 释放数据项Q上的锁

### 3.3 封锁协议

**封锁协议（Locking Protocol）**：规定何时申请锁、持锁时间、何时释放锁

#### 三级封锁协议 ⭐⭐⭐

**（1）一级封锁协议**

**规则**：
- 事务T在**修改**数据R之前必须先对其加**X锁**
- 直到**事务结束**才释放（COMMIT或ROLLBACK）

**作用**：
- ✅ 可防止**丢失修改**
- ✅ 保证事务T是可恢复的
- ❌ 不能保证可重复读
- ❌ 不能保证不读"脏"数据

---

**（2）二级封锁协议**

**规则**：
- 事务T在**修改**数据R之前必须先对其加**X锁**，直到**事务结束**才释放
- 事务T在**读取**数据R前必须先加**S锁**，**读完后即可释放**S锁

**作用**：
- ✅ 可以防止**丢失修改**
- ✅ 可以防止读"**脏"数据**
- ❌ 不能保证**可重复读**（因为读完后即释放S锁）

---

**（3）三级封锁协议**

**规则**：
- 事务T在**修改**数据R之前必须先对其加**X锁**，直到**事务结束**才释放
- 事务T在**读取**数据R前必须先加**S锁**，直到**事务结束**才释放

**作用**：
- ✅ 可以防止**丢失修改**
- ✅ 可以防止读"**脏"数据**
- ✅ 可以防止**不可重复读**

---

#### 三级协议的主要区别

| 封锁协议 | 修改数据 | 读取数据 | 防止丢失修改 | 防止读脏数据 | 防止不可重复读 |
|---------|---------|---------|------------|------------|--------------|
| 一级 | X锁到事务结束 | 不需要锁 | ✅ | ❌ | ❌ |
| 二级 | X锁到事务结束 | S锁读完即释放 | ✅ | ✅ | ❌ |
| 三级 | X锁到事务结束 | S锁到事务结束 | ✅ | ✅ | ✅ |

### 3.4 活锁和死锁

#### 活锁（Livelock）

**问题**：
- 多个事务申请对数据R加锁
- 系统随机地加锁
- 导致某些事务长期等待

**解决方法**：
- 采用**先来先服务**的策略
- 按请求封锁的先后次序对事务排队
- 数据对象上的锁一旦释放，首先批准申请队列中第一个事务获得锁

#### 死锁（Deadlock）

**定义**：两个（或多个）事务互相申请对方加锁对象的排它锁，造成循环等待

**示例**：
```
T1                T2
LOCK-X(R1)        
...               LOCK-X(R2)
LOCK-X(R2)        ...
等待              LOCK-X(R1)
...               等待
```

**解决方法**：

**1）预防死锁**

- **一次加锁法**：事务一次性对需要的数据进行加锁
  - 缺点：降低了系统的并发性，数据的不可预见性
  
- **顺序加锁法**：对系统中的锁设定一个加锁顺序，所有事务均按照该顺序进行加锁
  - 缺点：很难估算

**2）死锁的诊断与解除**

**诊断死锁的方法**：

- **超时法**：设定时限，超过即为死锁
  - 优点：实现简单
  - 缺点：可能误判死锁；时限设置太长，不能及时发现

- **等待图法**：检测图中是否存在回路，回路即为死锁

**解除死锁的方法**：
- 选择一个处理死锁代价最小的事务，将其撤消
- 释放此事务持有的所有的锁
- 使其它事务能继续运行下去

### 3.5 两段锁协议（Two-Phase Locking, 2PL）⭐⭐⭐

#### 定义

**两段锁协议**：保证并发调度可串行性的封锁协议

**要求**：每个事务分两个阶段进行数据项的加锁和解锁

#### 两个阶段

**1. 加锁阶段（扩展阶段）**
- 每个事务开始运行后即进入加锁阶段
- 申请获得所需要的所有锁
- **不能释放锁**

**2. 解锁阶段（收缩阶段）**
- 当一个事务第一次释放锁时，该事务进入解锁阶段
- **不能再申请任何锁**

#### 示例

**遵守两段锁协议**：
```
事务1：LOCK-S(A) → LOCK-S(B) → LOCK-X(C) → UNLOCK(B) → UNLOCK(A) → UNLOCK(C)
       |<------- 加锁阶段 ------>|<------- 解锁阶段 ------>|
```

**不遵守两段协议**：
```
事务2：LOCK-S(A) → UNLOCK(A) → LOCK-S(B) → LOCK-X(C) → UNLOCK(C) → UNLOCK(B)
       （释放了A锁之后又申请B锁，违反了两段锁协议）
```

#### 改进的两段锁协议

**增加了共享锁与互斥锁的转换机制**：

- **UPGRADE**：共享锁 → 互斥锁（只能在**加锁阶段**）
- **DOWNGRADE**：互斥锁 → 共享锁（只能在**解锁阶段**）

#### 重要关系

**两段锁协议与防止死锁的一次封锁法**：
- 一次封锁法遵守两段锁协议
- 遵守两段锁协议的事务可能发生死锁

**两段锁协议与三级封锁协议**：
- 两类不同目的的协议
- **两段锁协议**：保证并发调度的正确性（可串行性）
- **三级封锁协议**：在不同程度上保证数据一致性
- **遵守第三级封锁协议必然遵守两段协议**

### 3.6 锁的粒度

#### 封锁粒度

**锁的粒度**：封锁对象的大小
- 库级
- 表级
- 页面
- 行级
- 属性级

#### 锁粒度与并发度

- 锁粒度**越大**（可封锁的数据越大），并发度**越小**
- 锁粒度**越小**，并发度**越大**

#### 多粒度封锁

在一个系统中，同时支持多种粒度，供事务选择

### 3.7 意向锁

#### 意向锁的目的

- 提高对某个数据对象加锁时系统的检查效率
- 如果对一个结点加意向锁，则说明该结点的下层结点正在被加锁
- 对任一结点加基本锁，必须先对它的上层结点加意向锁

#### 常用意向锁

**1. 意向共享锁（IS锁）**
- 对一个数据对象加IS锁，表示它的后裔结点拟（意向）加S锁
- **例**：事务要对R1中某个元组加S锁，则要首先对关系R1和数据库加IS锁

**2. 意向排它锁（IX锁）**
- 对一个数据对象加IX锁，表示它的后裔结点拟（意向）加X锁
- **例**：事务要对R1中某个元组加X锁，则要首先对关系R1和数据库加IX锁

**3. 共享意向排它锁（SIX锁）**
- 对一个数据对象加SIX锁，表示对它加S锁，再加IX锁，即 **SIX = S + IX**
- **例**：对某个表加SIX锁，表示该事务要读整个表（S锁），同时会更新个别元组（IX锁）

#### 锁的相容矩阵

|  | IS | IX | S | SIX | X |
|---|---|---|---|---|---|
| **IS** | ✅ | ✅ | ✅ | ✅ | ❌ |
| **IX** | ✅ | ✅ | ❌ | ❌ | ❌ |
| **S** | ✅ | ❌ | ✅ | ❌ | ❌ |
| **SIX** | ✅ | ❌ | ❌ | ❌ | ❌ |
| **X** | ❌ | ❌ | ❌ | ❌ | ❌ |

#### 锁的强度

**锁的强度**：对其他锁的排斥程度

**强度顺序**（由强到弱）：
```
X > SIX > S, IX > IS
```

#### 具有意向锁的多粒度封锁方法

**申请封锁时**：按**自上而下**的次序进行

**释放封锁时**：按**自下而上**的次序进行

**优点**：
- 提高了系统的并发度
- 减少了加锁和解锁的开销
- 在实际的数据库管理系统产品中得到广泛应用

---

## 四、数据库恢复技术

### 4.1 数据库恢复概述

#### 数据库恢复机制的目的

1. 保证事务的原子性
2. 发生故障后，数据库能恢复到正确状态

#### 故障类型

1. **事务故障**：事务在运行过程中由于种种原因未能运行至正常终止点而夭折
2. **计算机系统故障**：硬件故障、软件故障、操作失误等
3. **介质故障**：磁盘损坏、磁头碰撞等
4. **其他原因**：意外情况（如病毒、人为破坏等）

#### 故障的影响

- 运行事务非正常中断
- 破坏数据库

#### 存储器的可恢复性

**（1）非永久存储器**（如主存、缓存等）
- 特点：存取速度快
- 故障：**不可恢复**

**（2）永久存储器**（如磁盘、磁带等）
- 特点：存取速度较慢
- 故障：**可恢复**

**（3）永恒存储器**
- 理论上永远不会丢失信息

**衡量系统优劣的重要指标**：能否从故障中恢复！

### 4.2 数据库恢复实现技术

#### 一、日志文件（重点）⭐⭐⭐

**日志文件（Log File）**：用来记录事务对数据库的操作信息的文件

**日志文件的格式**：
1. 以记录为单位的日志文件
2. 以数据块为单位的日志文件

**常用的日志记录格式**：

| 日志记录 | 含义 |
|---------|------|
| `<T, start>` | 事务T已经开始 |
| `<T, X, V1, V2>` | 事务T在数据项X上执行的写操作<br>V1：写操作之前的值<br>V2：写操作之后的值 |
| `<T, commit>` | 事务T已经提交 |

**日志使用机制**：
- 为保证事务的原子性
- 在执行数据库更新操作时，首先把描述更新操作的信息写入日志文件
- 而不修改数据库本身
- 当事务提交时，再使用日志中更新操作信息实现数据库的更新

**注意**：日志必须存储在**永恒存储器**上，以确保在系统和磁盘发生故障时仍可使用

#### 二、恢复技术

### （1）推迟更新技术（Deferred Update）

**原理**：
- 该事务对数据库的所有更新操作记录在日志中
- 把所有数据库更新操作推迟到该事务提交时执行

**推迟更新协议**：

1. 每个事务在到达**提交点之前不能更新数据库**
2. 在一个事务的所有更新操作对应的日志记录写入永恒存储器之前，该事务不能到达提交点

**执行事务T的过程**：

1. T开始执行，记录 `<T, start>`
2. T发出WRITE(X)操作，记录 `<T, X, V2>`（只需新值）
3. T达部分提交状态时，记录 `<T, commit>`，并将日志中的记录更新到数据库
4. 数据库真正被事务T更新，T进入提交状态

**示例**：

事务T1：从账号A向账号B转储50元
```
T1: READ(A);
    A := A-50;
    WRITE(A);
    READ(B);
    B := B+50;
    WRITE(B);
```

**日志内容**：
```
<T1, START>
<T1, A, 950>      # 只记录新值
<T1, B, 2050>
<T1, COMMIT>
```

**数据库变化**：
- 在 `<T1, COMMIT>` 写入日志后，才更新数据库
- A=950, B=2050

**恢复机制**：REDO(T)

```
REDO(T):
  FOR 日志中每个形如 (T, X, V) 的记录 DO
    把数据库中数据项X的值改为V;
  END FOR
```

**注意**：REDO操作必须是**幂等的**，即执行多次和执行一次的效果相同

**故障恢复规则**：
- 日志中有 `<T, commit>`：需要执行 **REDO(T)**
- 日志中只有 `<T, start>`：**不采取任何恢复行动**

---

### （2）即时更新技术（Immediate Update）

**原理**：
- 处于活动状态的事务直接在数据库上实施更新（非提交更新）

**即时更新协议**：

1. 在所有 `<T, X, V1, V2>` 型日志记录安全地存储到永恒存储器之前，事务T不能更新数据库
2. 在所有 `<T, X, V1, V2>` 型日志记录安全地存储到永恒存储器之前，不允许事务T提交

**执行事务T的过程**：

1. T开始执行时，记录 `<T, start>`
2. T发出WRITE(X)操作，在日志中记录 `<T, X, V1, V2>`，再直接在数据库上执行WRITE(X)
3. T达部分提交状态时，记录 `<T, commit>`
4. 数据库真正被事务T更新，T进入提交状态

**示例**：

同样的事务T1

**日志内容**：
```
<T1, START>
<T1, A, 1000, 950>    # 记录旧值和新值
<T1, B, 2000, 2050>
<T1, COMMIT>
```

**数据库变化**：
- 写入日志后，**立即更新数据库**（不等待提交）

**恢复机制**：UNDO(T) 和 REDO(T)

**UNDO(T)**：
```
UNDO(T):
  FOR 日志中每个形如 (T, X, V1, V2) 的记录 DO
    把数据库中数据项X的值改为V1;  # 恢复到旧值
  END FOR
```

**REDO(T)**：
```
REDO(T):
  FOR 日志中每个形如 (T, X, V1, V2) 的记录 DO
    把数据库中数据项X的值改为V2;  # 更新为新值
  END FOR
```

**注意**：UNDO、REDO操作必须是**幂等的**

**数据库恢复过程**：

1. 从后向前扫描日志记录，建立两个事务表：
   - **提交事务表**：含日志中有 `<Ti, commit>` 的所有事务Ti
   - **未提交事务表**：含日志中具有 `<Ti, start>`，但不具有 `<Ti, commit>` 的所有事务Ti

2. 对**提交事务表**中的每个事务执行 **REDO(T)**

3. 对**未提交事务表**中的每个事务执行 **UNDO(T)**，从日志删除T信息

**故障恢复规则**：
- 日志中有 `<T, commit>`：执行 **REDO(T)**
- 日志中只有 `<T, start>`：执行 **UNDO(T)**
- **注意**：UNDO须先执行，然后再执行REDO

---

### （3）检测点技术（Checkpoint）⭐⭐⭐

**问题**：
- 搜索日志耗时长
- 重复执行了已成功的REDO操作

**解决办法**：增加检测点法

**建立检测点的操作**：

数据库恢复机制定期执行如下操作，在日志中增加 `<checkpoint>` 记录：

1. 将当前缓存中所有日志记录输出到永恒存储器
2. 将所有缓冲区中被修改的数据块写入磁盘
3. 将日志记录 `<checkpoint>` 写入永恒存储器

**使用检测点法对数据库恢复技术的改进**：

- 在 `<checkpoint>` 之前的事务都已经提交
- 仅需对**最近建立的检测点之后开始执行或处于活动状态的事务**进行REDO或UNDO操作

**备份恢复示意图**：
```
|----备份即时点----|----某事务即时点----|----故障即时点----|
         ↓                  ↓                    ↓
    利用数据库备份恢复  利用日志备份恢复
```

---

## 五、MySQL数据库备份与恢复

### 5.1 备份的分类

#### 按照备份方法分类

**1. 热备（Hot Backup）**
- 数据库运行时进行备份

**2. 冷备（Cold Backup）**
- 数据库停止运行时进行备份

**3. 逻辑备份**
- 备份数据库的逻辑结构和数据

**4. 裸文件备份**
- 直接复制数据库文件

#### 按照备份数据库的内容分类

**1. 完全备份（Full Backup）**
- 备份数据库中所有数据

**2. 部分备份（Partial Backup）**
- 备份部分数据

**3. 增量备份（Incremental Backup）**
- 备份自上次备份后发生更改的数据

**4. 差异备份（Differential Backup）**
- 备份自上次完全备份后发生更改的数据

#### 需要备份的数据

- 表数据
- 二进制日志、InnoDB事务日志
- 代码（存储过程、存储函数、触发器、事件调度器）
- 服务器配置文件

### 5.2 备份命令

#### 一、备份全部数据库

**备份所有数据库**：
```bash
mysqldump -A -B --single-transaction | gzip > /server/backup/All_data_$(date +%F).sql.gz
```

**备份某个库的数据**：
```bash
mysqldump -A -B --single-transaction testDB1 | gzip > /server/backup/testDB1_$(date +%F).sql
```

#### 二、增量备份数据库

**概念**：
- 记录自上次数据库备份后发生更改的数据
- 增量备份比完全备份小且备份速度快
- 可以更经常地备份，减少丢失数据的危险

**适用场景**：
- 自上次备份后只有相对较少的数据发生了更改
- 使用简单恢复模型，希望进行更频繁的备份
- 使用完全恢复模型，希望需要最少的时间前滚事务日志

**建议过程**：
1. 创建定期的数据库备份
2. 在每个数据库备份之间定期创建增量备份
3. 如果使用完全恢复模型，则创建事务日志备份

**还原增量备份的顺序**：
1. 还原最新的数据库备份
2. 还原最后一次的增量备份
3. 应用自上次创建增量备份后创建的所有事务日志备份

#### 三、事务日志备份

**概念**：
- 自上次备份事务日志后对数据库执行的所有事务的一系列记录
- 可以使用事务日志备份将数据库恢复到特定的即时点或故障点

**特点**：
- 事务日志备份比数据库备份使用的资源少
- 可以比数据库备份更经常地创建
- 经常备份将减少丢失数据的危险

**建议**：
- 定期生成数据库备份（如每天）
- 以更短的间隔生成事务日志备份（如每隔10分钟）
- 至少有一个数据库备份，才能有效地进行日志备份

#### 四、用Navicat备份数据库

可以使用Navicat等图形化工具进行可视化备份操作

---

## 六、SQL Server数据库备份与恢复

### 6.1 数据库备份

#### 备份种类

**1. 完整备份（Full Backup）**

**定义**：包含数据库中全部数据和日志文件信息

**优点**：恢复操作简便，只需要将最近一次的备份恢复

**缺点**：完全备份所占的存储空间很大且备份的时间较长

**语法**：
```sql
BACKUP DATABASE database_name 
TO {DISK | TAPE} = 'physical_backup_device_name'
```

**例**：
```sql
BACKUP DATABASE Sample 
TO DISK='D:\backup\Sample_full.bak'
```

---

**2. 差异备份（Differential Backup）**

**定义**：只记录自上次数据库备份后发生更改的数据

**优点**：比完整备份小且备份速度快

**语法**：
```sql
BACKUP DATABASE database_name 
TO {DISK | TAPE} = 'physical_backup_device_name'
WITH DIFFERENTIAL
```

**例**：
```sql
BACKUP DATABASE Sample 
TO DISK='D:\backup\Sample_1.bak' 
WITH DIFFERENTIAL
```

**建议过程**：
1. 创建定期的完整数据库备份
2. 在每个完整备份之间定期创建差异备份
3. 如果使用完全恢复模型，创建事务日志备份的频率比差异备份大

**还原差异备份的顺序**：
1. 还原最新的数据库备份
2. 还原最后一次的差异备份
3. 应用自上次创建差异备份后创建的所有事务日志备份

---

**3. 日志文件备份（Transaction Log Backup）**

**定义**：当数据库信息更改时，其更新操作将记入日志文件，将这部分操作信息进行备份

**语法**：
```sql
BACKUP LOG {database_name | @database_name_var}
TO {DISK | TAPE} = 'physical_backup_device_name'
```

**例**：
```sql
BACKUP LOG Sample 
TO DISK='D:\backup\Sample_log.bak'
```

**特点**：
- 日志备份比完整备份使用的资源少
- 可以使用事务日志备份将数据库恢复到特定的即时点或故障点
- 事务日志备份序列独立于数据库备份

#### 备份前的计划工作

1. 确定备份的频率
2. 确定备份的内容
3. 确定使用的介质
4. 确定备份工作的负责人
5. 确定使用在线备份还是脱机备份
6. 确定是否使用备份服务器
7. 确定备份存储的地方
8. 确定备份存储的期限

#### 该备份哪些数据库

**应该定期备份**：
- master
- model、msdb
- 所有产品数据库

**必须备份的情况**：
- 创建该数据库后
- 创建索引后
- 清除事务日志后
- 执行了一个nonlogged操作之后

### 6.2 数据库恢复

**数据库恢复（还原）**：加载数据库备份到系统中的进程

#### 1. 根据数据库完全备份进行恢复

**语法**：
```sql
RESTORE DATABASE database_name 
FROM {DISK | TAPE} = 'physical_backup_device_name'  
[WITH [{NORECOVERY | RECOVERY}]]
```

- **NORECOVERY**：数据库保持在还原状态，可以继续还原其他备份
- **RECOVERY**：完成还原，数据库可以使用

#### 2. 根据差异备份进行恢复

**注意事项**：
1. 已经使用RESTORE DATABASE命令完成了完全备份的恢复，同时指定了**NORECOVERY**子句
2. 在进行差异备份恢复时需要指定NORECOVERY或RECOVERY
3. 如果有多个差异备份，则一定要**按照备份的先后顺序进行恢复**

#### 3. 根据日志文件进行恢复

**注意事项**：
1. 在恢复事务日志备份前需首先恢复数据库完全备份或差异备份
2. 如果有多个日志备份，则**按先后顺序进行恢复**

**语法**：
```sql
RESTORE LOG database_name  
FROM {DISK | TAPE} = 'physical_backup_device_name'  
[WITH [{NORECOVERY | RECOVERY}]
  [STOPAT = date_time           
  | STOPATMARK = 'mark_name' [AFTER datetime]          
  | STOPBEFOREMARK = 'mark_name' [AFTER datetime]]]
```

- **STOPAT**：还原到指定的时间点
- **STOPATMARK**：还原到指定的标记
- **STOPBEFOREMARK**：还原到指定标记之前

#### 完整的恢复示例

**例**：将数据库还原到2011年4月15日中午12点时的状态

**第一步**：还原完全备份的数据库
```sql
RESTORE DATABASE Sample
FROM DISK='D:\backup\Sample_full.bak'
WITH NORECOVERY
```

**第二步**：还原差异备份的数据库
```sql
RESTORE DATABASE Sample
FROM DISK='D:\backup\Sample_1.bak'
WITH NORECOVERY
```

**第三步**：还原日志备份，并且只还原到指定时间点
```sql
RESTORE LOG Sample
FROM DISK='D:\backup\Sample_log.bak'
WITH RECOVERY, STOPAT = 'Apr 15, 2011 12:00 AM'
```

### 6.3 备份与恢复策略示例

**假设有下列事件序列**：

| 时间 | 事件 |
|------|------|
| 上午 8:00 | 备份数据库 |
| 中午 | 备份事务日志 |
| 下午 04:00:00 | 备份事务日志 |
| 下午 6:00 | 备份数据库 |
| 晚上 08:00:00 | 备份事务日志 |
| 晚上 10:00 | 出现故障 |

**分析**：
- 晚上 8:00 创建的事务日志备份包含从下午 4:00 到晚上 8:00 的事务日志记录
- 中间跨越下午 6:00 创建数据库备份的时间
- 事务日志备份序列从上午 8:00 到晚上 8:00 是连续的

---

**方案一**：使用最后一次创建的数据库备份还原数据库

1. 创建当前活动事务日志的备份
2. 还原下午 6:00 的数据库备份
3. 应用晚上 8:00 的数据库备份和活动事务日志备份

**分析**：
- 还原进程检测到晚上 8:00 的事务日志备份包含自上次还原备份后所发生的事务
- 还原操作向下扫描事务日志直至下午 6:00 完成数据库备份时对应的即时点
- 只前滚事务日志备份内自该点后所完成的事务

---

**方案二**：使用以前的数据库备份（早于最后一次创建的数据库备份）还原数据库

1. 创建当前活动事务日志的备份
2. 还原上午 8:00 的数据库备份
3. 按顺序还原全部四个事务日志备份
4. 不要还原下午 6:00 的数据库备份
5. 所有完成的事务都将前滚到晚上 10:00

**分析**：
- 这个进程所用的时间比还原下午 6:00 的数据库备份要长
- 方案二注重由事务日志备份链所提供的冗余安全性
- 即使数据库备份丢失，也可以还原数据库

---

## 七、关键考点总结

### 7.1 事务与ACID性质
- 事务的定义和特点
- **ACID性质**：原子性、一致性、隔离性、持续性
- 事务的五种状态及转换
- 事务控制语句：BEGIN、COMMIT、ROLLBACK

### 7.2 并发控制
- 并发操作的五大问题：丢失更新、读脏数据、错误聚集计算、不可重复读、幻影数据行
- 锁的类型：共享锁（S锁）、互斥锁（X锁）
- **三级封锁协议**：各自的规则和能解决的问题
- **两段锁协议（2PL）**：加锁阶段、解锁阶段
- 死锁的产生和解决方法：预防死锁、诊断与解除
- 意向锁：IS锁、IX锁、SIX锁

### 7.3 数据库恢复
- **日志文件**：日志记录格式 `<T, start>`、`<T, X, V1, V2>`、`<T, commit>`
- **推迟更新技术**：只需新值，REDO操作
- **即时更新技术**：需要旧值和新值，UNDO和REDO操作
- **检测点技术（Checkpoint）**：减少恢复时间

### 7.4 备份与恢复
- 备份类型：完全备份、差异备份/增量备份、日志备份
- MySQL备份命令：mysqldump
- SQL Server备份语句：BACKUP DATABASE、BACKUP LOG
- SQL Server恢复语句：RESTORE DATABASE、RESTORE LOG
- 恢复策略：按照正确的顺序还原备份

### 7.5 重要关系
- 三级封锁协议 vs 两段锁协议
- 一次封锁法 vs 两段锁协议
- 差异备份 vs 增量备份
- REDO vs UNDO操作

---

**复习建议**：
1. **重点掌握事务的ACID性质**，理解每个性质的含义和作用
2. **熟练掌握三级封锁协议**，能够区分它们的规则和能解决的问题
3. **深入理解两段锁协议**，掌握加锁阶段和解锁阶段的规则
4. **掌握推迟更新和即时更新技术**，理解REDO和UNDO操作
5. **熟悉备份与恢复的类型和策略**，能够设计合理的备份恢复方案
6. 理解死锁的产生原因和解决方法
7. 掌握检测点技术的原理和作用
8. 能够根据实际场景选择合适的并发控制和恢复策略

