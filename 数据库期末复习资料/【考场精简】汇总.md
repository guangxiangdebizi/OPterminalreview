# 【考场精简】汇总


---

## 【考场精简】第3章_SQL语言

# 【考场精简】第3章 SQL语言

## 一、SQL概述

**SQL的核心特点：** 综合统一（DDL+DML+DCL）、高度非过程化（只需说做什么）、面向集合操作、语言简洁易用。

**九个核心动词：** SELECT查询、CREATE/DROP/ALTER定义、INSERT/UPDATE/DELETE操纵、GRANT/REVOKE控制。

---

## 二、数据定义语句

### 2.1 数据库操作

创建数据库：CREATE DATABASE 数据库名;
删除数据库：DROP DATABASE 数据库名;

### 2.2 基本表定义

**创建表语法：** CREATE TABLE 表名 (列名 数据类型 [列级约束], ..., [表级约束]);

**六大完整性约束：**
- PRIMARY KEY主码约束
- UNIQUE唯一性约束
- NOT NULL非空约束
- FOREIGN KEY外键约束（REFERENCES 引用表(引用列)）
- CHECK检查约束（CHECK(条件表达式)）
- DEFAULT默认值约束

**例题1：** 创建抢修工程表，prj_num为主码
```sql
CREATE TABLE Salvaging (
    prj_num char(8) PRIMARY KEY,
    prj_name varchar(50),
    start_date datetime,
    end_date datetime,
    prj_status bit
);
```

**例题2：** 创建出库表，复合主码+外键
```sql
CREATE TABLE Out_stock (
    prj_num char(8),
    mat_num char(4),
    amount int,
    get_date datetime default NOW(),
    department char(20),
    PRIMARY KEY(prj_num, mat_num),
    FOREIGN KEY (prj_num) REFERENCES Salvaging(prj_num),
    FOREIGN KEY (mat_num) REFERENCES Stock(mat_num)
);
```

### 2.3 修改表结构

**添加列：** ALTER TABLE 表名 ADD 列名 数据类型 [约束];
**删除列：** ALTER TABLE 表名 DROP COLUMN 列名;
**修改列：** ALTER TABLE 表名 MODIFY COLUMN 列名 数据类型 [约束];

**注意：** 新增列初始为空值。若表中已有数据，新增列不能设NOT NULL（除非有DEFAULT）。

**例题3：** 向表中添加负责人列
```sql
ALTER TABLE Salvaging ADD prj_director VARCHAR(10);
```

### 2.4 约束的添加与删除

**添加约束：** ALTER TABLE 表名 ADD CONSTRAINT 约束名 约束表达式;
**删除约束：** ALTER TABLE 表名 DROP CONSTRAINT 约束名;

**例题4：** 后期添加外键约束
```sql
ALTER TABLE out_stock ADD CONSTRAINT FK_Salvaging_Out_stock 
    FOREIGN KEY (prj_num) REFERENCES salvaging(prj_num);
```

### 2.5 删除表

**语法：** DROP TABLE 表名;
**危险：** 删除表会同时删除数据、索引、视图，且被外键引用的表不能删除。

---

## 三、单表查询

### 3.1 基本查询结构

**SELECT语句格式：**
SELECT [DISTINCT] 目标列 FROM 表名 [WHERE 条件] [GROUP BY 列名 [HAVING 条件]] [ORDER BY 列名 [ASC|DESC]];

**执行顺序：** FROM→WHERE→GROUP BY→HAVING→SELECT→ORDER BY

### 3.2 选择列

**查询指定列：** SELECT mat_num, mat_name, speci FROM Stock;
**查询全部列：** SELECT * FROM Stock;
**计算列：** SELECT prj_name, datediff(end_date, start_date) 抢修天数 FROM Salvaging;
**列别名：** 列名 [AS] 别名 或 别名=列名

**常用时间函数：** NOW()当前时间、YEAR(d)年份、MONTH(d)月份、DATEDIFF(d1,d2)天数差、ADDDATE(d,n)加天数、SUBDATE(d,n)减天数

### 3.3 选择元组（WHERE条件）

**1) 比较运算：** =、>、<、>=、<=、!=或<>、NOT

**例题5：** 查询单价小于80的物资
```sql
SELECT mat_name, amount, unit FROM stock WHERE unit < 80;
```

**2) 范围查询：** BETWEEN...AND...（闭区间）

**例题6：** 查询单价在50到100之间
```sql
SELECT mat_name, amount, unit FROM stock WHERE unit BETWEEN 50 AND 100;
-- 等价于：WHERE unit >= 50 AND unit <= 100
```

**3) 集合查询：** IN、NOT IN

**例题7：** 查询指定仓库的物资
```sql
SELECT mat_name, speci, amount FROM stock 
WHERE warehouse IN('供电局1#仓库', '供电局2#仓库');
```

**4) 模糊查询：** LIKE、NOT LIKE
- **%代表任意长度字符串**（包括0个）
- **_代表单个字符**
- **ESCAPE定义换码字符**（如ESCAPE '/'使/_失去通配符含义）

**例题8：** 模糊查询示例
```sql
-- 查询所有绝缘电线
SELECT mat_num, mat_name, speci FROM stock WHERE mat_name LIKE '%绝缘电线';
-- 第三四个字为"绝缘"
SELECT mat_num, mat_name, speci FROM stock WHERE mat_name LIKE '__绝缘%';
-- 包含"户外_真空"（_作为普通字符）
SELECT * FROM Stock WHERE mat_name LIKE '%户外/_真空%' ESCAPE '/';
```

**5) 空值查询：** IS NULL、IS NOT NULL（**注意不能用=NULL**）

**例题9：** 查询无单价的物资
```sql
SELECT mat_num, mat_name FROM stock WHERE unit IS NULL;
```

**6) 多条件：** AND优先级高于OR，可用括号改变优先级

### 3.4 结果排序与限制（⭐必考重点）

**ORDER BY排序：**
- **ASC** - 升序（默认，可省略）
- **DESC** - 降序（必须写）
- **多列排序：** 先按第一列排，相同再按第二列排
- **空值规则：** 空值在排序中是最小的

**LIMIT限制结果数量（老师重点强调）：**
- **LIMIT n** - 显示前n条记录（从第1条开始）
- **LIMIT m, n** - 从第m+1条开始，显示n条记录（**m是偏移量，从0开始计数**）
- **LIMIT offset, count** 等价于 **LIMIT count OFFSET offset**

**LIMIT核心理解：**
- **LIMIT 2, 3** 表示：跳过前2条（第1、2条），从第3条开始取3条（取第3、4、5条）
- **LIMIT 0, 5** 等价于 **LIMIT 5**（从第1条开始取5条）
- **LIMIT 5, 10** 表示：跳过前5条，从第6条开始取10条

**例题10：** ORDER BY基础用法
```sql
-- 按库存量降序排列
SELECT * FROM Stock ORDER BY amount DESC;

-- 按仓库降序，同一仓库内按库存量升序
SELECT * FROM stock ORDER BY warehouse DESC, amount ASC;
-- 等价于（ASC可省略）
SELECT * FROM stock ORDER BY warehouse DESC, amount;
```

**例题11：** LIMIT基础用法
```sql
-- 查询库存量最大的两条记录
SELECT * FROM Stock ORDER BY amount DESC LIMIT 2;

-- 查询库存量最大的第3到第5条记录（跳过前2条，取3条）
SELECT * FROM Stock ORDER BY amount DESC LIMIT 2, 3;
```

**例题12：** LIMIT分页查询（实战常考）
```sql
-- 第1页：显示前10条（第1-10条）
SELECT * FROM Stock ORDER BY mat_num LIMIT 0, 10;  -- 或 LIMIT 10

-- 第2页：显示第11-20条
SELECT * FROM Stock ORDER BY mat_num LIMIT 10, 10;

-- 第3页：显示第21-30条
SELECT * FROM Stock ORDER BY mat_num LIMIT 20, 10;

-- 通用公式：第page页，每页size条
-- LIMIT (page-1)*size, size
```

**例题13：** ORDER BY + LIMIT组合（必考题型）
```sql
-- 查询单价最低的3种物资
SELECT mat_name, unit FROM Stock ORDER BY unit ASC LIMIT 3;

-- 查询库存量第4-6名的物资（跳过前3名）
SELECT mat_name, amount FROM Stock ORDER BY amount DESC LIMIT 3, 3;

-- 查询每个仓库库存量最大的物资（需要用开窗函数或子查询）
SELECT * FROM (
    SELECT *, ROW_NUMBER() OVER(PARTITION BY warehouse ORDER BY amount DESC) as rn
    FROM Stock
) t WHERE rn = 1;
```

### 3.5 聚集函数（重点）

**五大聚集函数：**
- **COUNT(*)** 统计元组个数
- **COUNT(列名)** 统计列中非空值个数
- **SUM(列名)** 求和（数值型）
- **AVG(列名)** 平均值（数值型）
- **MAX(列名)/MIN(列名)** 最大/最小值

**DISTINCT关键字：** 计算时取消重复值，如COUNT(DISTINCT prj_num)

**注意事项：** 
- 除COUNT外其他函数忽略NULL值
- **WHERE子句中不能使用聚集函数**

**例题11：** 聚集函数应用
```sql
-- 统计领取物资的工程数
SELECT COUNT(DISTINCT prj_num) FROM out_stock;
-- 查询m001物资的最高、最低、平均领取量
SELECT MAX(amount), MIN(amount), AVG(amount) FROM out_stock WHERE mat_num = 'm001';
```

### 3.6 分组查询（GROUP BY + HAVING）

**GROUP BY作用：** 细化聚集函数作用对象，将结果按某列分组，每组一个函数值。

**HAVING作用：** 筛选分组，作用于组而非元组。

**WHERE vs HAVING：**
- WHERE作用于基本表，选择满足条件的元组
- HAVING作用于分组，选择满足条件的组
- **先WHERE后GROUP BY再HAVING**

**例题12：** 查询使用2种以上物资的工程
```sql
SELECT prj_num, COUNT(*) 物资种类 FROM out_stock 
GROUP BY prj_num HAVING COUNT(*) >= 2;
```

**例题13：** 多列分组
```sql
SELECT department, mat_num, count(distinct prj_num) 项目个数, sum(amount) 领取总量
FROM Out_stock GROUP BY department, mat_num;
```

**WITH ROLLUP：** 按分组顺序先对第一个字段分组并统计，最后给出总计。

### 3.7 开窗函数（数据分析）

**特点：** 每条记录都执行函数，有几条记录执行完还是几条（不像聚合函数合并为一条）。

**常用函数：** ROW_NUMBER()行号、RANK()排名（有间隙）、DENSE_RANK()密集排名、LAG()前一行、LEAD()后一行

**例题14：** 查询每种物资使用量前2的出库情况
```sql
select * from (
    select *, row_number() over(partition by mat_num order by amount desc) as row_num
    from out_stock
) as t where row_num <= 2;
```

### 3.8 正则表达式查询

**语法：** 列名 REGEXP '匹配方式'

**常用模式：** ^开头、$结尾、.任意字符、[字符集]、|或、*零或多次、+一或多次、{N}出现N次、{M,N}出现M到N次

**例题15：** 正则表达式示例
```sql
-- 包含"西丽"或"明珠"
SELECT * FROM Salvaging WHERE prj_name REGEXP '西丽|明珠';
-- 包含"2"至少1次最多2次
SELECT * FROM Salvaging WHERE prj_name REGEXP '2{1,2}';
```

---

## 四、连接查询

### 4.1 等值连接与自然连接

**连接条件格式：** [表名1.]列名1 比较运算符 [表名2.]列名2

**执行过程：** 表1每个元组与表2全部元组逐一匹配，满足连接条件的拼接成结果元组。

**例题16：** 查询每个工程及其出库情况
```sql
SELECT Salvaging.*, Out_stock.* FROM Salvaging, Out_stock 
WHERE Salvaging.prj_num = Out_stock.prj_num;
```

**自然连接：** 去掉重复列，同名属性必须加表名前缀。

### 4.2 内连接（显式连接）

**语法：** 表1 INNER JOIN 表2 ON 连接条件

**优势：** 显式连接在每次连接时通过ON过滤，效率高于隐式连接（先笛卡尔积再WHERE过滤）。

**例题17：** 内连接写法
```sql
SELECT salvaging.prj_num, prj_name, mat_num, amount 
FROM salvaging INNER JOIN out_stock ON salvaging.prj_num = out_stock.prj_num;
```

### 4.3 外连接

**三种外连接：**
- **LEFT OUTER JOIN** 保留左表所有元组，右表不匹配的填NULL
- **RIGHT OUTER JOIN** 保留右表所有元组
- **FULL OUTER JOIN** 保留两表所有元组

**例题18：** 左外连接（显示所有工程，包括未领料的）
```sql
SELECT Salvaging.prj_num, prj_name, mat_num, amount 
FROM Salvaging LEFT OUTER JOIN Out_stock ON Salvaging.prj_num = Out_stock.prj_num;
```

### 4.4 复合条件连接

WHERE子句中包含连接条件+其他限定条件。

**例题19：** 查询项目20100015使用的物资
```sql
SELECT Out_stock.mat_num, mat_name, speci, Out_stock.amount
FROM Stock JOIN Out_stock ON Stock.mat_num = Out_stock.mat_num
WHERE prj_num = '20100015';
```

### 4.5 自身连接

**关键：** 必须给表起别名，所有属性必须加前缀。

**例题20：** 查询同时使用m001和m002的工程
```sql
SELECT A.prj_num FROM Out_stock A, Out_stock B
WHERE A.prj_num = B.prj_num AND A.mat_num = 'm001' AND B.mat_num = 'm002';
```

---

## 五、嵌套查询

### 5.1 基本概念

**定义：** WHERE或HAVING中出现另一个SELECT语句。

**求解方法：**
- **不相关子查询：** 子查询条件不依赖父查询，由里向外逐层处理
- **相关子查询：** 子查询条件依赖父查询，取外层元组→传给内层→执行内层→判断WHERE→重复

**限制：** 子查询不能使用ORDER BY（只能对最终结果排序）。

### 5.2 带IN的嵌套查询

子查询结果是一个集合。

**例题21：** 查询与BVV-120护套绝缘电线同仓库的物资
```sql
SELECT mat_name, speci, amount FROM Stock
WHERE warehouse IN (
    SELECT warehouse FROM Stock 
    WHERE speci = 'BVV-120' AND mat_name = '护套绝缘电线'
);
```

**例题22：** 多层嵌套查询观澜站光缆抢修使用的物资
```sql
SELECT mat_num, mat_name FROM Stock
WHERE mat_num IN (
    SELECT mat_num FROM Out_stock WHERE prj_num IN (
        SELECT prj_num FROM Salvaging WHERE prj_name = '观澜站光缆抢修'
    )
);
```

### 5.3 带比较运算符的子查询

**要求：** 子查询返回单值。常用于相关子查询。

**例题23：** 查询库存量超过该仓库平均库存量的物资（相关子查询）
```sql
SELECT mat_num, mat_name, speci, amount FROM Stock s1
WHERE amount > (
    SELECT avg(amount) FROM Stock s2 WHERE s2.warehouse = s1.warehouse
);
```

### 5.4 带ANY或ALL的子查询

**必须同时使用比较运算符：**
- **>ANY** 大于某个值（等价于>MIN）
- **<ANY** 小于某个值（等价于<MAX）
- **>ALL** 大于所有值（等价于>MAX）
- **<ALL** 小于所有值（等价于<MIN）
- **=ANY** 等价于IN
- **!=ALL** 等价于NOT IN

**例题24：** 查询比供电局1#仓库某物资库存少的其他仓库物资
```sql
SELECT mat_name, speci, amount FROM Stock
WHERE warehouse <> '供电局1#仓库' AND amount < ANY (
    SELECT amount FROM Stock WHERE warehouse = '供电局1#仓库'
);
-- 等价于用MAX
WHERE warehouse <> '供电局1#仓库' AND amount < (
    SELECT MAX(amount) FROM Stock WHERE warehouse = '供电局1#仓库'
);
```

**注意：** 使用聚集函数比ANY/ALL效率更高。

### 5.5 带EXISTS的嵌套查询（难点）

**EXISTS存在量词：** 子查询结果非空返回TRUE，为空返回FALSE，不返回数据。
**NOT EXISTS：** 子查询结果为空返回TRUE。

**目标列用*：** 因为EXISTS只关心有无结果，给出列名无意义。

**例题25：** 查询使用了m001物资的工程
```sql
SELECT prj_name FROM Salvaging
WHERE EXISTS (
    SELECT * FROM Out_stock 
    WHERE prj_num = Salvaging.prj_num AND mat_num = 'm001'
);
```

**例题26：** 查询没使用m001物资的工程
```sql
SELECT prj_num, prj_name FROM Salvaging
WHERE NOT EXISTS (
    SELECT * FROM Out_stock 
    WHERE prj_num = Salvaging.prj_num AND mat_num = 'm001'
);
```

### 5.6 用EXISTS实现全称量词

**转换公式：** ∀xP ≡ ¬∃x(¬P) 即"对所有x满足P" = "不存在x不满足P"

**例题27：** 查询被所有工程都使用的物资（双重NOT EXISTS）
```sql
SELECT mat_num, mat_name, speci FROM Stock
WHERE NOT EXISTS (
    SELECT * FROM Salvaging WHERE NOT EXISTS (
        SELECT * FROM Out_stock 
        WHERE mat_num = Stock.mat_num AND prj_num = Salvaging.prj_num
    )
);
```
**理解：** 不存在某个工程，不存在使用该物资的出库记录。

### 5.7 用EXISTS实现逻辑蕴涵

**转换公式：** p→q ≡ ¬p∨q ≡ ¬(p∧¬q)

**例题28：** 查询包含工程20100016所用物资的工程
```sql
SELECT DISTINCT prj_num FROM Out_stock sx
WHERE NOT EXISTS (
    SELECT * FROM Out_stock sy WHERE sy.prj_num = '20100016' AND NOT EXISTS (
        SELECT * FROM Out_stock sz 
        WHERE sz.mat_num = sy.mat_num AND sz.prj_num = sx.prj_num
    )
);
```
**理解：** 不存在这样的物资：20100016用了但x没用。

---

## 六、集合查询

### 6.1 集合操作

**三种操作：** UNION并、INTERSECT交、EXCEPT差

**相容要求：** 属性个数和数据类型必须一致，属性名无关（用第一个结果的属性名）。

**自动去重：** 默认去除重复元组，用ALL保留重复。

**例题29：** 并操作
```sql
SELECT * FROM Stock WHERE warehouse = '供电局1#仓库'
UNION
SELECT * FROM Stock WHERE unit <= 50;
-- UNION ALL保留重复
```

**例题30：** 查询使用m001或m002的工程
```sql
SELECT prj_num FROM Out_stock WHERE mat_num = 'm001'
UNION
SELECT prj_num FROM Out_stock WHERE mat_num = 'm002';
```

### 6.2 通过中间表查询

子查询作为FROM子句中的临时表。

**例题31：** 查询使用物资数量前3的工程
```sql
select prj_num from (
    select prj_num, sum(amount) as sum_amount from out_stock group by prj_num
) as S order by sum_amount DESC limit 3;
```

---

## 七、数据更新

### 7.1 插入数据

**1) 插入单个元组：** INSERT INTO 表名[(列名...)] VALUES (常量...);
- 未指定列名：插入完整元组，顺序与表定义一致
- 指定部分列：其余列取空值（非空列必须指定）

**例题32：** 插入新物资
```sql
INSERT INTO Stock(mat_num, mat_name, speci, warehouse, unit, amount)
VALUES ('m020', '架空绝缘导线', '10KV-100', '供电局1#仓库', 12.8, 50);
```

**2) 插入多行元组：** VALUES后用逗号分隔多组值
```sql
INSERT INTO Out_stock VALUES 
    ('20110006', 'm001', 2, '2011-3-9', '工程4部'),
    ('20110006', 'm002', 3, '2011-3-9', '工程4部');
```

**3) 插入子查询结果：** INSERT INTO 表名[(列名...)] 子查询;

**例题33：** 统计每个工程的物资总费用并存入新表
```sql
-- 先建表
CREATE TABLE Prj_cost (prj_num char(8) PRIMARY KEY, cost decimal(18, 2));
-- 插入统计结果
INSERT INTO Prj_cost
SELECT prj_num, SUM(out_stock.amount * unit) 
FROM Out_stock, Stock WHERE Out_stock.mat_num = Stock.mat_num GROUP BY prj_num;
```

### 7.2 修改数据

**语法：** UPDATE 表名 SET 列名=表达式[, 列名=表达式...] [WHERE 条件];

**省略WHERE：** 修改表中所有元组。

**例题34：** 修改单个元组
```sql
UPDATE Stock SET unit = 44.5 WHERE mat_num = 'm020';
```

**例题35：** 修改多个元组
```sql
UPDATE Stock SET unit = unit + 1;  -- 所有物资单价加1
```

**例题36：** 带子查询的修改
```sql
UPDATE Out_stock SET amount = 0
WHERE mat_num IN (SELECT mat_num FROM Stock WHERE warehouse = '供电局1#仓库');
```

### 7.3 删除数据

**语法：** DELETE FROM 表名 [WHERE 条件];

**省略WHERE：** 删除表中所有元组（但不删表定义）。

**例题37：** 删除单个元组
```sql
DELETE FROM Out_stock WHERE prj_num = '20110001' AND mat_num = 'm001';
```

**例题38：** 删除所有元组
```sql
DELETE FROM Out_stock;
```

**例题39：** 带子查询的删除
```sql
DELETE FROM Out_stock
WHERE prj_num IN (
    SELECT prj_num FROM Salvaging WHERE prj_name = '观澜站光缆抢修'
);
```

---

## 八、视图

### 8.1 视图定义

**语法：** CREATE VIEW 视图名[(列名...)] AS 子查询 [WITH CHECK OPTION];

**视图特点：** 虚表、只存定义不存数据、基表数据变化视图数据也变。

**必须明确指定列名的情况：**
1. 目标列是集函数或表达式
2. 多表连接有同名列
3. 需要为列启用新名字

**例题40：** 行列子集视图
```sql
CREATE VIEW s1_stock AS
SELECT mat_num, mat_name, speci, amount, unit FROM Stock 
WHERE warehouse = '供电局1#仓库';
```

**例题41：** 带WITH CHECK OPTION
```sql
CREATE VIEW s2_stock AS
SELECT mat_num, mat_name, speci, amount, unit FROM Stock 
WHERE warehouse = '供电局1#仓库' WITH CHECK OPTION;
-- 确保后续INSERT/UPDATE仍满足warehouse条件
```

**例题42：** 多表连接视图
```sql
CREATE VIEW s1_outstock AS
SELECT prj_name, mat_name, speci, out_stock.amount
FROM Stock INNER JOIN Out_stock ON Stock.mat_num = Out_stock.mat_num
INNER JOIN Salvaging ON Salvaging.prj_num = Out_stock.prj_num;
```

**例题43：** 带表达式的视图（必须指定列名）
```sql
CREATE VIEW s1_salvaging(prj_name, start_date, end_date, days) AS
SELECT prj_name, start_date, end_date, datediff(day, start_date, end_date)
FROM Salvaging;
```

**例题44：** 分组视图
```sql
CREATE VIEW s4_stock(warehouse, counts) AS
SELECT warehouse, COUNT(mat_num) FROM Stock GROUP BY warehouse;
```

**例题45：** 基于视图的视图
```sql
CREATE VIEW s3_stock AS
SELECT mat_num, mat_name, speci, amount FROM s1_stock WHERE amount >= 50;
```

### 8.2 删除视图

**语法：** DROP VIEW 视图名;

**注意：** 
1. 只删视图定义，不删基表数据
2. 该视图导出的其他视图定义仍在但不能用，需显式删除
3. 删除基表时，其导出的视图都不能用

### 8.3 查询视图

**视图消解法：** DBMS将视图查询转换为对基本表的查询。

**例题46：** 查询视图
```sql
SELECT mat_name, speci, unit FROM s1_stock WHERE unit < 20;
-- 转换为：
SELECT mat_name, speci, unit FROM Stock 
WHERE warehouse = '供电局1#仓库' AND unit < 20;
```

**局限性：** 某些情况视图消解法无法正确转换（如分组视图的WHERE条件应转为HAVING）。

### 8.4 更新视图

**受限更新：** 通过视图消解法将更新转换为对基表的更新。

**例题47：** 更新视图
```sql
UPDATE s1_stock SET amount = 100 WHERE mat_num = 'm001';
-- 转换为：
UPDATE Stock SET amount = 100 
WHERE warehouse = '供电局1#仓库' AND mat_num = 'm001';
```

**例题48：** 插入视图
```sql
INSERT INTO s1_stock VALUES('m022', '护套绝缘电线', 'BVV-150', 100, 14.5);
-- 转换为对Stock表的插入，warehouse列取NULL（若有WITH CHECK OPTION会报错）
```

**不可更新的视图：**
1. 字段来自聚集函数
2. 含GROUP BY子句
3. 含DISTINCT短语
4. 基于不可更新视图的视图

### 8.5 视图的作用

1. **简化操作：** 隐藏复杂的连接查询
2. **多角度看数据：** 不同用户定义不同视图
3. **安全保护：** 限制用户只能看到授权数据
4. **逻辑独立性：** 基表结构改变时，通过重建视图保持应用程序不变

**例题49：** 数据库重构的逻辑独立性
```sql
-- Stock表垂直分成s1和s2后，建视图保持外模式不变
CREATE VIEW Stock(mat_num, mat_name, speci, warehouse, amount, unit, total) AS
SELECT s1.mat_num, s1.mat_name, s1.speci, s1.warehouse, s2.amount, s2.unit, s2.total
FROM s1, s2 WHERE s1.mat_num = s2.mat_num;
-- 原有查询程序无需修改
```

---

## 九、考前快速记忆

**1. 约束类型：** 主码PRIMARY KEY、唯一UNIQUE、非空NOT NULL、外键FOREIGN KEY、检查CHECK、默认DEFAULT

**2. 聚集函数：** COUNT计数、SUM求和、AVG平均、MAX最大、MIN最小（除COUNT外都忽略NULL）

**3. 模糊查询：** %任意长度、_单个字符、ESCAPE换码字符

**4. 连接类型：** 内连接INNER JOIN、左外LEFT OUTER JOIN、右外RIGHT OUTER JOIN、自身连接需别名

**5. 子查询：** IN集合、比较运算符单值、ANY/ALL范围、EXISTS存在性

**6. EXISTS转换：** 全称量词∀xP≡¬∃x(¬P)、逻辑蕴涵p→q≡¬(p∧¬q)

**7. 执行顺序：** FROM→WHERE→GROUP BY→HAVING→SELECT→ORDER BY

**8. 视图限制：** 不能含ORDER BY、不能用DISTINCT、聚集函数/GROUP BY的视图不可更新

**9. 集合操作：** UNION并（自动去重）、UNION ALL（保留重复）

**10. 空值判断：** 只能用IS NULL或IS NOT NULL，不能用=NULL

---

**考场提示：** 
- WHERE用于元组筛选，HAVING用于分组筛选
- 显式连接（INNER JOIN ON）效率高于隐式连接
- 双重NOT EXISTS实现"所有"的语义
- 子查询不能在WHERE中使用聚集函数，要用HAVING
- 空值在排序中是最小的
- 视图WITH CHECK OPTION确保更新时满足视图定义条件

---

## 【考场精简】第4章_存储过程与编程

# 考场精简 - 第4章 存储过程与编程

## 一、MySQL变量详解

### 局部变量
局部变量只能在BEGIN和END语句块中使用,比如存储过程中的BEGIN和END语句块,作用域仅限于该语句块。局部变量使用DECLARE语句定义,可以用DEFAULT说明默认值。

定义局部变量例子：declare m_amount int default 0;

局部变量赋值方式一：set m_amount = 5;

局部变量赋值方式二：select amount into m_amount from stock where mat_num='m001';

### 用户变量
MySQL中用户变量不用提前申明,直接用@变量名使用即可,作用域为当前连接。

用户变量赋值方式一：set @m_amount=5; 或者 set @m_amount :=5;

用户变量赋值方式二：select @m_amount :=5; 或者 select @m_amount:= amount from stock where mat_num='m001';

注意使用set时可以用等号或冒号等号两种赋值符号,使用select时必须用冒号等号赋值符号。

### 会话变量
服务器为每个连接的客户端维护一系列会话变量,作用域仅限于当前连接,即每个连接中的会话变量是独立的。

显示所有会话变量：show session variables;

设置会话变量的三种方式：set session auto_increment_increment=1; 或 set @@session.auto_increment_increment=2; 或 set auto_increment_increment=3;

当省略session关键字时默认缺省为session,即设置会话变量的值。

查询会话变量的三种方式：select @@auto_increment_increment; 或 select @@session.auto_increment_increment; 或 show session variables like '%auto_increment_increment%';

关键字session也可用关键字local替代,例如：set @@local.auto_increment_increment=1; 和 select @@local.auto_increment_increment;

### 全局变量
全局变量影响服务器整体操作,当服务启动时将所有全局变量初始化为默认值。要想更改全局变量必须具有super权限,作用域为server的整个生命周期。

显示所有全局变量：show global variables;

设置全局变量的两种方式：set global sql_warnings=ON; 或 set @@global.sql_warnings=OFF; 注意global不能省略。

查询全局变量的两种方式：select @@global.sql_warnings; 或 show global variables like '%sql_warnings%';

## 二、注释语句

### 单行注释方式一
两个减号加空格后面添加注释内容,注意减号后必须有一个空格。例如：SELECT * FROM table -- 这是一个单行注释

### 单行注释方式二
井号后面添加注释内容,无需空格。例如：SELECT * FROM table # 这是一个单行注释

### 多行注释
斜杠星号和星号斜杠之间添加注释内容,可以跨越多行。例如：SELECT * FROM table /* 这是一个多行注释 */

### 内联注释
斜杠星号感叹号和星号斜杠这种注释称为内联注释,通常用于指定特定MySQL版本执行的代码。例如：SELECT * FROM table /*!50110 WHERE condition */

## 三、流程控制语句

### BEGIN和END语句
使用BEGIN和END语句可以将多条SQL语句封装起来形成一个语句块,使这些语句作为一个整体执行。语法形式是BEGIN开头,中间写语句,最后END结尾。

### IF和ELSE语句
语法形式：IF 条件表达式 THEN 语句 ELSE 语句 END IF

执行过程为如果条件表达式为真则执行IF后面的语句或语句块,如果条件表达式为假则执行ELSE后面的语句或语句块。

考试例题：在电力抢修工程数据库中,如果Stock表中m001物资的库存量低于10就显示文本库存不足需要补货,否则显示库存充足。

DECLARE stock_amount INT;
SELECT amount INTO stock_amount FROM Stock WHERE mat_num = 'm001';
IF stock_amount < 10 THEN
    SELECT '库存不足,需要补货';
ELSE
    SELECT '库存充足';
END IF;

注意该语句段可以在存储过程中使用。

### WHILE循环语句
语法形式：WHILE 条件 DO 语句 END WHILE

考试例题：创建表CREATE TABLE numbers ( id INT AUTO_INCREMENT PRIMARY KEY, value INT );

下列语句段可以在存储过程中使用：
DECLARE counter INT DEFAULT 1;
WHILE counter <= 10 DO
    INSERT INTO numbers (value) VALUES (counter);
    SET counter = counter + 1;
END WHILE;

### CASE语句格式一
CASE后面跟表达式,然后WHEN条件表达式THEN表达式,可以有多个WHEN,最后ELSE表达式,用END结束。

考试例题：用CASE语句格式一实现在对stock表的查询中,当仓库号的值是供电局1号仓库、供电局2号仓库、供电局3号仓库时分别返回北京、上海、广州,否则返回未知。

SELECT mat_num,mat_name,speci,amount,unit,
    CASE warehouse
        WHEN '供电局1#仓库' THEN '北京'
        WHEN '供电局2#仓库' THEN '上海'
        WHEN '供电局3#仓库' THEN '广州'
        ELSE '未知'
    END AS warehouse
FROM Stock;

### CASE语句格式二
CASE后面不跟表达式,直接WHEN条件表达式THEN表达式,可以有多个WHEN,最后ELSE表达式,用END结束。

考试例题：用CASE语句格式二实现上面的例子。

SELECT mat_num,mat_name,speci,amount,unit,
    CASE
        WHEN warehouse='供电局1#仓库' THEN '北京'
        WHEN warehouse='供电局2#仓库' THEN '上海'
        WHEN warehouse='供电局3#仓库' THEN '广州'
        ELSE '未知'
    END as warehouse
FROM Stock;

### CASE语句应用例题
学生数据库查询各系平均成绩：

select sdept,
    avg(case when cname='数据结构' then grade end) 数据结构,
    avg(case when cname='数据库原理' then grade end) 数据库原理,
    avg(case when cname='操作系统' then grade end) 操作系统
from student s inner join Sc on s.Sno=SC.Sno
    inner join course c on SC.Cno=c.cno
group by Sdept

## 四、存储过程基本概念

存储过程是存储在数据库服务器中的一组编译成单个执行计划的SQL语句。使用Transact-SQL语言编程的过程中,可以将某些需要多次调用以实现某个特定任务的代码段编写成一个过程,将其保存在数据库中,并由SQL Server服务器通过过程名调用。

存储过程在创建时被编译和优化,可以包含程序控制流、查询子句、操作子句,还可以接受参数、输出参数、返回单个值或多个结果集。

### 存储过程分类
系统存储过程是SQL Server本身定义的当作命令来执行的一类存储过程,通常以sp下划线为前缀,主要功能是从系统表中获取信息。

用户自定义的存储过程是用户创建并完成某一特定功能的存储过程。

### 存储过程优点
第一运行效率高,提供了在服务器端快速执行SQL语句的有效途径。第二降低了客户机和服务器之间的通信量。第三方便实施企业规则。

## 五、MySQL存储过程创建和管理

### MySQL创建存储过程基本语法
CREATE PROCEDURE 存储过程名(参数列表)
BEGIN
    SQL语句
END

存储过程中的参数列表如果没有参数使用一个空参数列,多个参数之间通过逗号进行分割。参数列表中的每个参数都由输入输出类型、参数名称和参数类型组成,语法如IN或OUT或INOUT加参数名称加类型。其中IN表示输入参数,OUT表示输出参数,INOUT既可以是输入也可以是输出参数。

### 执行存储过程语法
CALL 存储过程名()

### 基本存储过程例题
创建一个最简单的存储过程用于查看Stock表中的所有记录。

DELIMITER &&
CREATE PROCEDURE pro1()
BEGIN
    SELECT * FROM stock;
END

执行存储过程：CALL pro1

### 带输入参数的存储过程例题
创建一个带输入参数的存储过程向Stock表中添加一个新的数据行。

DELIMITER &&
CREATE PROCEDURE pro2(mno char(8),mname varchar(50),mspeci varchar(20))
BEGIN
    INSERT INTO Stock(mat_num,mat_name,speci)
    VALUES(mno,mname,mspeci);
END

执行存储过程：CALL pro2 ('m030','护套绝缘电线','BVV-35');

### 带输出参数的存储过程例题
OUT用于指明参数为输出参数,可以返回到调用存储过程的语句或其他存储过程中。

创建一个存储过程根据输入的抢修工程项目号统计其领取物资的总数量并要求输出。

DELIMITER &&
CREATE PROCEDURE pro3(pn char(8), OUT total int)
BEGIN
    SELECT sum(amount) into total
    FROM out_stock
    WHERE prj_num=pn;
END

执行：call pro3('20100015', @total); 然后 select @total;

### 带INOUT参数的存储过程例题
创建一个存储过程根据输入的工程部门及起止时间段汇总该部门在对应时间段内所参与抢修的工程项目总数以及领取物资的总成本并要求输出。

DELIMITER &&
CREATE PROCEDURE pro4(INOUT depart varchar(50),start_date datetime, end_date datetime, OUT count_prj int ,out sum_cost decimal(18,2))
BEGIN
    SELECT COUNT(distinct salvaging.prj_num),sum(out_stock.amount*unit) into count_prj,sum_cost
    FROM salvaging INNER JOIN out_stock on out_stock.prj_num=salvaging.prj_num
        INNER JOIN stock on out_stock.mat_num =Stock.mat_num
    WHERE department = depart
        and get_date between start_date and end_date;
END

执行：set @depart='工程2部'; 然后 call pro4(@depart,'2011-1-1','2011-1-31',@prjcounts,@sumcosts); 最后 select @depart,@prjcounts,@sumcosts;

### 嵌套调用存储过程例题
嵌套调用存储过程查看使用抢修物资总数最多的工程项目信息。

DELIMITER &&
CREATE PROCEDURE pro5(OUT prj_no char(8))
BEGIN
    SELECT prj_num into prj_no
    FROM out_stock
    GROUP BY prj_num
    ORDER BY SUM(amount) DESC
    LIMIT 1;
END

DELIMITER &&
CREATE PROCEDURE pro6()
BEGIN
    DECLARE prj_id char(8);
    call pro5(@prj_id);
    SELECT *
    FROM Salvaging
    WHERE prj_num=@prj_id;
End

执行存储过程：call pro6();

### 在存储过程中使用游标
查询语句可能返回多条记录,如果数据量非常大需要在存储过程和函数中使用游标来逐条读取查询结果集中的记录。游标必须在程序之前且在变量和条件之后声明,而且游标使用完成一定要关闭。

声明游标语法：DECLARE 游标名 CURSOR FOR SELECT语句;

打开游标语法：OPEN 游标名;

使用游标语法：FETCH 游标名 INTO 参数名1,参数名2等;

其中参数名表示将游标中的SELECT语句查询出来的信息存入到该参数中,参数名必须在声明游标之前就已经定义。

关闭游标语法：CLOSE 游标名;

考试例题：在存储过程中使用游标把stock表中所有的仓库名称连接为一个字符串并进行显示输出。

DELIMITER &&
CREATE PROCEDURE pro7()
BEGIN
    DECLARE done INT DEFAULT 0;
    DECLARE whname varchar(10) DEFAULT '';
    DECLARE allname varchar(1000) DEFAULT '';
    DECLARE cur1 CURSOR FOR SELECT distinct warehouse FROM stock;
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done=1;
    OPEN cur1;
    REPEAT
        FETCH cur1 INTO whname;
        IF NOT done THEN
            SET allname = CONCAT(allname,whname);
        END IF;
    UNTIL done END REPEAT;
    CLOSE cur1;
    SELECT allname;
END

执行存储过程：call pro7();

### 查看存储过程
SHOW STATUS语句可以查看存储过程的状态。基本语法结构是SHOW PROCEDURE STATUS LIKE 模式; 其中LIKE模式为可选项用来匹配存储过程名称,如果不指定LIKE子句则查询当前数据库下的所有存储过程。例如：SHOW PROCEDURE STATUS like 'pro_';

注意SHOW STATUS语句只能查看存储过程的名称、类型、谁定义的、创建和修改时间、字符编码等信息,不能查询存储过程或函数的具体定义。

SHOW CREATE语句也可以查看存储过程的状态。基本语法结构是SHOW CREATE PROCEDURE 存储过程名; 例如：SHOW CREATE PROCEDURE pro1;

注意SHOW CREATE语句查询结果显示了存储过程的定义、字符集等信息。

### 修改和删除存储过程
修改存储过程的语句是：ALTER PROCEDURE 存储过程名(参数列表) BEGIN SQL语句 END

删除存储过程的语句是：DROP PROCEDURE存储过程名

## 六、SQL Server存储过程创建和管理

### SQL Server创建存储过程基本语法
CREATE PROCEDURE 存储过程名
    参数列表,格式为@参数 数据类型,可选默认值,可选OUTPUT
    WITH可选项如RECOMPILE或ENCRYPTION或两者
    FOR REPLICATION可选
AS
    SQL语句

### 基本存储过程例题
创建一个最简单的存储过程用于查看Stock表中的所有记录。

CREATE PROCEDURE exp1
AS
    SELECT *
    FROM Stock

执行存储过程：EXECUTE exp1 或者 EXEC exp1

### 带输入参数的存储过程例题
创建一个存储过程通过输入的仓库名称显示出该仓库的所有库存物资信息。

CREATE PROCEDURE exp
    @warehousename varchar(50)
AS
    SELECT *
    FROM stock
    WHERE warehouse=@warehousename

执行存储过程：exec exp '供电局1#仓库'

另一个带输入参数例题：创建一个带输入参数的存储过程向Stock表中添加一个新的数据行。

CREATE PROCEDURE exp2
    @mno char(8), @mname varchar(50), @mspeci varchar(20)
AS
    INSERT INTO Stock(mat_num,mat_name,speci)
    VALUES(@mno,@mname,@mspeci)

执行存储过程可以用三种方式：EXECUTE exp2 'm030','护套绝缘电线','BVV-35' 或 EXECUTE exp2 @mno='m030', @mname='护套绝缘电线', @mspeci='BVV-35' 或 EXECUTE exp2 @mname='护套绝缘电线', @mspeci='BVV-35', @mno='m030'

### 确保创建成功的注意事项
为了确保Create命令能成功执行可以在Create Procedure之前执行如下语句：IF EXISTS (SELECT name FROM sysobjects WHERE name='exp2' and type='P') DROP PROCEDURE exp2 然后 GO

### 带默认参数的存储过程例题
创建一个带默认参数的存储过程,通过传递的参数显示物资的名称、规格、项目名称、是否按期完工等信息,如果没有提供参数则使用预设的默认值。

CREATE PROCEDURE exp4
    @mname varchar(50)='%绝缘%', @pno char(8)='20110001'
AS
    SELECT mat_name,speci,prj_name,prj_status
    FROM stock, salvaging, out_stock
    WHERE stock.mat_num=out_stock.mat_num
        and salvaging.prj_num=out_stock.prj_num
        and mat_name like @mname
        and salvaging.prj_num=@pno

执行创建的存储过程exp4可以用多种方式：EXECUTE exp4 或 EXECUTE exp4 '%绝缘电线' 或 EXECUTE exp4 @pno='20110002' 或 EXECUTE exp4 '护套绝缘电线','20110002'

### 带输出参数的存储过程例题
OUTPUT指明输出参数可以返回到调用存储过程的批处理或其他存储过程中。

创建一个存储过程根据输入的抢修工程项目号统计其领取物资的总数量并要求输出。

CREATE PROCEDURE exp4
    @pn char(8), @sum int OUTPUT
AS
    SELECT @sum=sum(amount)
    FROM Out_stock
    WHERE prj_num=@pn

执行：DECLARE @total int 然后 EXECUTE exp4 '20110001', @total OUTPUT 最后 PRINT '该项目领取物资总量为：'+ CAST(@total AS varchar(20))

另一个带输出参数例题：创建一个存储过程根据输入的工程部门及起止时间段汇总该部门在对应时间段内所参与抢修的工程项目总数以及领取物资的总成本并要求输出。

CREATE PROCEDURE exp5
    @department varchar(50),@start_date datetime,@end_date datetime,
    @count_prj int OUTPUT, @sum_cost decimal(18,2) OUTPUT
AS
    select @count_prj=COUNT(DISTINCT out_stock.prj_num),
        @sum_cost=SUM(Out_stock.amount*Stock.unit)
    FROM salvaging,out_stock,stock
    WHERE out_stock.prj_num =salvaging.prj_num
        and out_stock.mat_num =Stock.mat_num
        and department = @department
        and get_date between @start_date and @end_date

执行：DECLARE @prjcounts int, @sumcosts decimal(18,2) 然后 EXEC exp5 '工程2部','2011-1-1','2011-1-31', @prjcounts OUTPUT, @sumcosts OUTPUT 最后 PRINT '该部门参与抢修工程项目'+ CAST(@prjcounts AS varchar(20))+'个,总成本为'+CAST(@sumcosts AS varchar(20))

### 嵌套调用存储过程例题
嵌套调用存储过程查看使用抢修物资总数最多的工程项目信息。

CREATE PROCEDURE exp6
    @prj_no char(8) OUTPUT
AS
    SELECT TOP 1 @prj_no=prj_num
    FROM out_stock
    GROUP BY prj_num
    ORDER BY SUM(amount) DESC
GO

CREATE PROCEDURE exp7
AS
    DECLARE @prj_id char(8)
    EXEC exp6 @prj_id OUTPUT
    SELECT *
    FROM Salvaging
    WHERE prj_num=@prj_id
GO

执行存储过程：EXECUTE exp7

### 修改和删除存储过程
修改存储过程的语句是：ALTER PROCEDURE 存储过程名,参数列表格式为@参数 数据类型可选默认值可选OUTPUT,WITH可选项如RECOMPILE或ENCRYPTION或两者,FOR REPLICATION可选,AS后面是SQL语句。

删除存储过程的语句是：DROP PROCEDURE 存储过程名

## 考场速记口诀

变量四类记心间：局部用户会话全局各有权限范围。

局部DECLARE需定义,用户@符号直接用,会话SESSION或LOCAL,全局GLOBAL权限重。

IF判断真假分支,WHILE循环条件控,CASE分支多选择,BEGIN END成块用。

存储过程效率高,减少通信规则巧,IN输入OUT输出,INOUT双向要记牢。

游标逐条读记录,声明打开取关闭,FETCH INTO存变量,循环处理要仔细。

查看SHOW STATUS和CREATE,修改ALTER删DROP,MySQL用CALL来执行,SQL Server用EXEC调。

带参灵活多变化,默认参数可省略,嵌套调用功能强,输出参数必OUTPUT标。

---

## 【考场精简】第5章_触发器

# 【考场精简】第5章 触发器和数据库完整性

## 一、触发器核心概念

触发器是用户定义在关系表上的一类由事件驱动的特殊过程，是一种保证数据完整性的方法，也可看作是一类特殊的存储过程。一旦定义，无须用户调用，任何对表的修改操作均由服务器自动激活相应的触发器。

主要作用：实现主键和外键所不能保证的复杂的参照完整性和数据一致性。具体功能包括：强化约束、跟踪变化、级联运行、存储过程的调用。

## 二、MySQL触发器

### 基本语法格式

CREATE TRIGGER 触发器名 BEFORE或AFTER INSERT或UPDATE或DELETE ON 表名 FOR EACH ROW SQL语句

关键点：BEFORE表示在激活语句之前触发，AFTER表示在激活语句之后触发。FOR EACH ROW表示任何一条记录上的操作满足触发事件都会触发该触发器。注意不能同时在一个表上建立2个相同类型的触发器。

### NEW表和OLD表的使用

NEW表：对于INSERT操作，NEW表里存放的是将要或已经插入的新数据。对于UPDATE操作，NEW表里存放的是将要或已经更新的新数据。使用方法是NEW.列名。

OLD表：对于DELETE操作，OLD表里存放的是将要或已经被删除的数据。对于UPDATE操作，OLD表里存放的是更新前的原数据。使用方法是OLD.列名。

重要提示：OLD表是只读的，而NEW表可以在触发器中使用SET赋值。

### 例题1：INSERT事件触发器求和

在对表stock插入物资记录前，对新插入的amount字段值进行求和计算。代码如下：

DELIMITER && CREATE TRIGGER tr1_stock BEFORE INSERT ON stock FOR EACH ROW SET @sum=@sum+NEW.amount;

测试语句：set @sum=0; insert into stock值('m030','护套绝缘电线','BVV-120','供电局1#仓库',10,100),('m031','护套绝缘电线','BVV-150','供电局1#仓库',20,100); select @sum; 结果会显示30。

### 例题2：INSERT事件自动修改日期

在对表salvaging插入抢修项目前，如果项目开始日期和项目结束日期相同，则将项目结束日期设为开始日期三天后。代码如下：

DELIMITER && CREATE TRIGGER tr1_salvaging BEFORE INSERT ON salvaging FOR EACH ROW BEGIN if(NEW.end_date=NEW.start_date) then set NEW.end_date=ADDDATE(NEW.start_date,3); end if; END;

测试语句：insert into salvaging values('20190001','抢修项目1','2019-6-1','2019-6-1',0),('20190002','抢修项目2','2019-6-1','2019-6-2',0); 第一条记录的结束日期会自动变成2019-6-4。

### 例题3：INSERT事件级联更新

在对表Out_stock插入一条记录后，更改对应物资在Stock表中的库存数量，完成级联更改操作。代码如下：

DELIMITER && CREATE TRIGGER tr1_outstock AFTER INSERT ON out_stock FOR EACH ROW BEGIN declare m_amout int(11); select amount INTO m_amout from out_stock where prj_num=NEW.prj_num and mat_num=NEW.mat_num; update stock set amount=amount-m_amout where mat_num=NEW.mat_num; END

测试语句：insert into Out_stock values('20110006','m003',10,'2011-3-8','工程1部'); 执行后Stock表中m003物资的库存量会减少10。

### 例题4：DELETE事件级联删除

当用户从stock表中删除数据时，同时将out_stock表中相关物资的出库情况一并删除。代码如下：

DELIMITER && CREATE TRIGGER tr2_stock AFTER DELETE ON stock FOR EACH ROW BEGIN delete from out_stock where mat_num=OLD.mat_num; END

注意：使用触发器作级联删除,前提是Out_stock表没有定义和Stock表相关的外键。

### 例题5：UPDATE事件记录变更

定义一个数据表modify_amount，用于存储领料出库表out_stock中领取数量发生变化的情况。表结构包含：prj_num项目号、mat_num物资号、username修改人、updatetime修改时间、amount_old修改前数量、amount_new修改后数量。触发器代码如下：

DELIMITER && CREATE TRIGGER tr2_outstock AFTER UPDATE ON out_stock FOR EACH ROW BEGIN insert into modify_amount values(OLD.prj_num,OLD.mat_num,USER(),NOW(),OLD.amount,NEW.amount); END

测试语句：UPDATE Out_stock SET amount=8 WHERE prj_num='20110005' and mat_num='m006'; 执行后modify_amount表中会插入一条变更记录。

## 三、SQL Server触发器

### 基本语法格式

CREATE TRIGGER 触发器名 ON 表名或视图名 WITH ENCRYPTION可选 AFTER或INSTEAD OF INSERT或UPDATE或DELETE NOT FOR REPLICATION可选 AS SQL语句

关键点：一个触发器只能应用在一个表上，但一个触发器可以包含很多动作。触发器可以建立在基本表上，也可以建立在视图上。

### AFTER触发器和INSTEAD OF触发器

AFTER触发器：表示触发器在SQL语句中指定操作成功执行后才激活。

INSTEAD OF触发器：表示在表或视图上执行增删改操作时，用该触发器中的SQL语句代替原语句。注意视图只能使用INSTEAD OF触发器，而不能使用AFTER触发器。

### INSERTED表和DELETED表

INSERTED表：对于INSERT操作，INSERTED表里存放的是要插入的数据。对于UPDATE操作，INSERTED表里存放的是要更新的记录即更新后的值。

DELETED表：对于DELETE操作，DELETED表里存放的是被删除的记录。对于UPDATE操作，DELETED表里存放的是更新前的记录。

### 例题6：AFTER INSERT验证数据

在对表Stock进行插入后验证库存量的大小，若库存量小于1，则撤销该插入操作。代码如下：

CREATE TRIGGER tr1_stock ON Stock AFTER INSERT AS declare @amount int select @amount=amount from INSERTED if @amount<1 BEGIN ROLLBACK TRAN RAISERROR('Amount must be greater than 1!',16,10) END

测试语句1：INSERT INTO stock值('m030','护套绝缘电线','BVV-120','供电局1#仓库',2,100); 由于库存量大于等于1符合规则，可以正常插入执行。

测试语句2：INSERT INTO stock值('m031','护套绝缘电线','BVV-120','供电局1#仓库',0,100); 由于库存量小于1不符合规则，将撤销表的插入操作。

### 例题7：AFTER INSERT级联更新

在对表Out_stock插入一条记录后，更改对应物资在Stock表中的库存数量。代码如下：

CREATE TRIGGER tr1_outstock ON Out_stock AFTER INSERT AS BEGIN declare @m_num char(8), @m_amount int select @m_num=mat_num,@m_amount=amount from INSERTED update Stock set amount=amount-@m_amount where mat_num=@m_num END

测试语句：insert into Out_stock values('20110006','m001',10,'2011-3-8','工程1部'); 执行后Stock表中m001物资的库存量会减少10。

### 例题8：AFTER DELETE级联删除

当用户从Stock表中删除数据时，同时将Out_stock表中相关物资的出库情况一并删除。代码如下：

CREATE TRIGGER tr2_stock ON Stock AFTER DELETE AS BEGIN TRANSACTION DECLARE @mat_num char(8) SELECT @mat_num=mat_num FROM DELETED DELETE FROM Out_stock WHERE mat_num=@mat_num COMMIT TRANSACTION

注意：使用触发器作级联删除,前提是Out_stock表没有定义和Stock表相关的外键。

### 例题9：AFTER UPDATE数据验证

当用户更新stock表中的数据时，从INSERTED表中读取修改的新的amount值，如果该值小于1，将撤销更新操作，即触发器从DELETED表中查询修改前的值，将其重新更新到stock表中。代码如下：

CREATE TRIGGER tr3_stock ON Stock AFTER UPDATE AS DECLARE @amount_new int,@amount_old int, @mat_num char(10) SELECT @amount_new=amount, @mat_num=mat_num FROM INSERTED IF @amount_new<1 BEGIN SELECT @amount_old=amount FROM DELETED UPDATE Stock SET amount=@amount_old WHERE mat_num=@mat_num PRINT 'the row can not be UPDATED!' END ROLLBACK TRAN

### 例题10：AFTER UPDATE检测特定列

先检测更新的列，当更新warehouse列时禁止更新；当更新库存量amount列时设置更新规则，若更新后的值小于1则撤销该更新操作。代码如下：

CREATE TRIGGER tr4_stock ON Stock AFTER UPDATE AS DECLARE @amount int IF UPDATE(warehouse) BEGIN ROLLBACK TRAN PRINT '不允许修改物资存放仓库！' END else IF UPDATE(amount) BEGIN SELECT @amount=amount FROM INSERTED IF @amount<1 BEGIN ROLLBACK TRAN PRINT '库存量小于1，不允许更新！' END END

注意：UPDATE函数可以检测到一个列的更新。

### 例题11：AFTER UPDATE记录变更历史

用于存储领料出库表Out_stock中领取数量发生变化的情况。表Modify_amount包含：prj_num项目号、mat_num物资号、username修改人、updatetime修改时间、amount_old修改前数量、amount_new修改后数量。触发器代码如下：

CREATE TRIGGER tr2_outstock on Out_stock AFTER UPDATE As If update(amount) Begin declare @amount_old int,@amount_new int declare @prj_no char(8),@mat_no char(8) select @prj_no=(select prj_num from DELETED) select @mat_no=(select mat_num from DELETED) select @amount_old=(select amount from DELETED) select @amount_new=(select amount from INSERTED) insert into Modify_amount values(@prj_no,@mat_no,USER_NAME(),GETDATE(),@amount_old, @amount_new) End

测试语句：UPDATE Out_stock SET amount=8 WHERE prj_num='20110005' and mat_num='m006'; 执行后Modify_amount表中会插入一条变更记录。

### 例题12：INSTEAD OF确保外键有效

对Out_stock表创建一个INSTEAD OF触发器，确保插入的抢修工程项目号在Salvaging表中存在。代码如下：

CREATE TRIGGER tr3_outstock on Out_stock INSTEAD OF INSERT AS if exists(select * from INSERTED where prj_num not in (select prj_num from salvaging)) print '对不起，有抢修工程项目号不在工程项目表中，不能正确插入！' else insert into Out_stock select * from INSERTED

测试语句：INSERT INTO out_stock VALUES ('20110006','m001',2,'2011-3-9','工程4部'),('20110007','m002',3,'2011-3-9','工程4部'); 如果20110006或20110007不在salvaging表中，会提示错误并不插入数据。

### 例题13：INSTEAD OF补充缺失列

创建一个INSTEAD OF触发器，在视图往基本表中插入数据行时补充speci的列值。首先创建视图view_stock，代码如下：

CREATE VIEW view_stock AS SELECT mat_num,mat_name,warehouse,amount,unit FROM stock

由于视图中不包括speci列，而基本表中speci列不能为空，若通过视图插入数据会出错。解决办法是创建触发器：

CREATE TRIGGER tr_viewstock ON view_stock INSTEAD OF INSERT AS DECLARE @mat_num char(10),@mat_name char(50),@speci char(50), @warehouse char(50), @amount int, @unit decimal(18,2) SELECT @mat_num=mat_num,@mat_name=mat_name, @warehouse=warehouse,@amount=amount,@unit=unit FROM INSERTED SET @speci='未知' INSERT INTO stock(mat_num,mat_name,speci,warehouse,amount,unit) VALUES(@mat_num,@mat_name,@speci,@warehouse,@amount,@unit)

测试语句：INSERT INTO view_stock VALUES('m100','护套绝缘电线','供电局1#仓库',10,110); 执行后会在stock表中插入一条记录，speci列的值自动设为"未知"。

### 例题14：复合触发器

创建一个复合触发器，不允许修改或删除存储在供电局1#仓库的物资信息。代码如下：

CREATE TRIGGER tr6_stock ON stock AFTERT DELETE,UPDATE AS DECLARE @warehouse char(50) SELECT @warehouse=warehouse FROM DELETED IF @warehouse= '供电局1#仓库' BEGIN ROLLBACK TRAN PRINT '不允许修改或删除供电局1#仓库的物资信息！' END

### 触发器的修改和删除

修改触发器：只有数据库所有者才能修改触发器。语法是ALTER TRIGGER 触发器名 ON 表名或视图名 WITH ENCRYPTION可选 AFTER或INSTEAD OF INSERT或UPDATE或DELETE NOT FOR REPLICATION可选 AS SQL语句

删除触发器：语法是DROP TRIGGER 触发器名

注意：在删除表时，依存于该表的触发器也将同时被删除。

## 四、数据库完整性

数据库的完整性是数据的正确性和相容性。为了维护数据库的完整性，DBMS必须提供一种机制来检查数据库的完整性。现代数据库技术采用对数据完整性予以约束和检查的方式来保护数据库的完整性。

除了实体完整性约束和参照完整性约束，其他与数据完整性有关的内容都是用户定义的数据完整性范畴。实现用户定义的完整性规则，除了CreateTable命令中的Check约束，更多的是使用触发器来实现灵活复杂的数据完整性要求。

### 例题15：使用触发器实现复杂完整性约束

在电力抢修工程数据库中，Out_stock表中的prj_num属性是外键，参照Salvaging表中prj_num属性，并且要求对于某一项抢修工程，其Out_stock表中的领料日期get_date的值必须介于Salvaging表中该工程的start_date和end_date值之间。例如prj_num为20110006的抢修工程的开始日期为2011-03-08结束日期为2011-03-10，则out_stock表中prj_num为20110006的记录的get_date值必须介于2011-03-08和2011-03-10之间。实现代码如下：

CREATE TRIGGER tr3_outstock BEFORE INSERT ON out_stock FOR EACH ROW BEGIN declare s_date datetime; declare e_date datetime; DECLARE msg varchar(50); select start_date,end_date into s_date,e_date from salvaging where prj_num=NEW.prj_num; if(NEW.get_date<s_date)or(NEW.get_date>e_date) then set msg=CONCAT(NEW.prj_num,'项目领取的',NEW.mat_num,'物资领料日期有误！'); signal sqlstate 'HY000' set message_text=msg; end if; END

测试语句：insert into out_stock values('20110006','m005',10,'2019-6-8','工程1部'); 如果日期不在工程的开始和结束日期之间，会抛出错误提示。

## 五、重要考点总结

1. 触发器的定义：由事件驱动的特殊过程，无须用户调用，任何对表的修改操作均由服务器自动激活。

2. MySQL触发器使用NEW表和OLD表，NEW表可以被修改，OLD表只读。

3. SQL Server触发器使用INSERTED表和DELETED表。

4. 触发时机：BEFORE在操作之前触发，AFTER在操作之后触发，INSTEAD OF代替原操作。

5. 触发事件：INSERT插入、DELETE删除、UPDATE更新。

6. FOR EACH ROW表示行级触发器，每条记录都会触发。

7. 不能在一个表上建立两个相同类型的触发器。

8. 触发器主要用于：强化约束、跟踪变化、级联运行、调用存储过程。

9. UPDATE触发器合并了DELETE和INSERT的作用，可以访问更新前后的数据。

10. 视图只能使用INSTEAD OF触发器，不能使用AFTER触发器。

11. UPDATE函数可以检测特定列是否被更新。

12. 使用ROLLBACK TRAN可以撤销操作。

13. 删除表时依存于该表的触发器也会被删除。

14. 触发器是实现复杂完整性约束的重要手段，可以实现主键和外键无法保证的复杂参照完整性。

---

## 【考场精简】第6章_索引及查询优化

# 【考场精简】第6章 索引及查询优化

## 一、索引的基本概念

建立索引的目的是加快查询速度，提高数据文件访问效率。但索引是有代价的，为了维护索引，对数据进行插入、更新、删除操作所花费的时间会更长。在设计和创建索引时，应确保对性能的提高程度大于在存储空间和处理资源方面的代价。

DBMS支持在表中任何列上定义索引。如果一个表没有创建索引，则数据行不按任何特定的顺序存储，这种结构称为堆集。

索引主要有两种类型：聚集索引和非聚集索引。

## 二、聚集索引

聚集索引的特点是数据文件中的记录按照索引键指定的顺序排序，使得具有相同索引键值的记录在物理上聚集在一起。一个表只能建立一个聚集索引。

MySQL将索引组织为B+树。索引内的每一页包含一个页首，页首后面跟着索引行。每个索引行都包含一个键值以及一个指向较低级页或数据行的指针。索引的每个页称为索引节点。B+树的顶端节点称为根节点，索引的底层节点称为叶节点，根和叶之间的任何索引级统称为中间级。同级索引中的页链接在双向链接列表中。

聚集索引的结构特征：非叶子节点只存储键值信息，数据记录都存放在叶子节点中，所有叶子节点之间形成链式结构。

聚集索引适用于：大量非重复值的列，经常被连续访问的列，经常使用联接或GROUP BY子句的查询访问的列。

聚集索引不适用于：频繁更改的列。

## 三、非聚集索引

非聚集索引的特点：索引与数据行的存放顺序无关，索引作为表的附加信息，有利于单行查询但不利于范围查询。一个表可以建立多个非聚集索引。

非聚集索引与聚集索引两个重大区别：第一，数据行不按非聚集索引键的顺序排序和存储；第二，非聚集索引的叶层不包含数据页，叶层是索引行。

非聚集索引包括以下几种类型：

唯一索引：唯一索引列的值必须唯一，允许有空值但至多只能有一个空值。如果是组合索引，则列值的组合必须唯一。

单值索引：这是最基本的非聚集索引，没有任何限制，但尽量选择区分度高的列作为索引。例如选择姓名做索引，而不会选择性别来做索引。

组合索引：即一个索引包含多个列。

## 四、MySQL索引的存储引擎

InnoDB存储引擎：使用B+树索引。聚集索引即主键索引，将表数据和主键索引存储在一起，表数据按照主键顺序存储，主键索引的叶子节点直接存储了表的行数据。辅助索引即除主键索引之外的其他索引，其叶子节点存储的是主键值。通过辅助索引查找数据时，首先找到主键值，然后通过主键值再查找聚集索引获取完整的行数据。InnoDB的B+树索引适合范围查询、排序操作和主键等值查询。

MyISAM存储引擎：使用B-树索引。数据可以存储在内部节点和叶子节点中。表数据和索引是分开存储的，索引文件中的叶子节点存储的是指向数据文件中数据行的指针。MyISAM的B-树索引适合等值查询，但在范围查询和排序操作方面不如B+树高效。由于不支持事务和行级锁，通常用于读多写少的场景。

MEMORY存储引擎：默认使用哈希索引，但也可以显式创建B-树索引。

## 五、创建索引的方法

在创建表时创建索引：
CREATE TABLE table_name (column1 datatype, column2 datatype, UNIQUE INDEX index_name (column1 ASC));

为已存在的表添加索引：
ALTER TABLE table_name ADD UNIQUE INDEX index_name (column1 DESC);

使用CREATE INDEX语句：
CREATE UNIQUE INDEX index_name ON table_name (column1 ASC);

全文索引：全文索引主要用于对文本数据进行全文搜索，可以快速定位到包含特定单词或短语的文本数据，适用于新闻文章、博客内容等场景。
CREATE TABLE table_name (column1 datatype, column2 datatype, FULLTEXT INDEX index_name (column_name));
ALTER TABLE table_name ADD FULLTEXT INDEX index_name (column_name);
CREATE FULLTEXT INDEX index_name ON table_name (column_name);

例题1：在Stock的mat_name列上建立一个非聚集索引：
CREATE INDEX Index_mat_name ON Stock(mat_name DESC);

例题2：创建一个组合索引：
CREATE INDEX Index_name_spec ON Salvaging(prj_name, spec);

## 六、何时创建索引

下列情况推荐在该列上创建索引：

需要在该列搜索符合特定搜索关键字值的行，即精确匹配查询，如在WHERE子句中指定mat_no='m01'。

需要在该列搜索关键字值属于某一特定范围值的行，即查询范围，例如在WHERE子句中指定amount between 200 and 300。

在表Table1中搜索根据连接谓词与表Table2中的某个行匹配的行。

在不进行显式排序操作的情况下产生经排序的查询输出。

使用Like进行比较查询，且模式以特定字符串如"abc%"开头。

搜索已定义了Foreign Key约束的两个表之间匹配的行。

查看索引是否起作用的例题：
explain select * from stock where mat_num>='m001' and mat_num<='m003';
explain select * from stock where mat_name like '绝缘%';
explain select * from stock where mat_name like '%绝缘%';

注意：第一个和第二个查询会使用索引，第三个查询因为模式以通配符开头不会使用索引。

## 七、查询优化技巧：数据库设计方面

对查询进行优化应尽量避免全表扫描，首先应考虑在where及order by涉及的列上建立索引。

应尽量避免在where子句中对字段进行null值判断，否则将导致引擎放弃使用索引而进行全表扫描。例如select id from t where num is null可以在num上设置默认值0，确保表中num列没有null值，改为select id from t where num=0。

并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时查询可能不会去利用索引。

索引并不是越多越好，索引固然可以提高相应的select的效率，但同时也降低了insert及update的效率。

应尽可能的避免更新聚集索引数据列。

尽量使用数字型字段，这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。

尽可能的使用varchar/nvarchar代替char/nchar，因为变长字段存储空间小可以节省存储空间。

## 八、查询优化技巧：SQL语句方面

应尽量避免在where子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描。

应尽量避免在where子句中使用or来连接条件，否则将导致引擎放弃使用索引而进行全表扫描。

例题：select prj_num from out_stock where mat_num='m001' or mat_num='m002';
可以改为：
select prj_num from out_stock where mat_num='m001' union all select prj_num from out_stock where mat_num='m002';

in和not in也要慎用，否则会导致全表扫描。

例题：select id from t where num in(1,2,3)
对于连续的数值能用between就不要用in：
select id from t where num between 1 and 3

应尽量避免在where子句中对索引字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。

例题：select id from t where num/2=100
例题：select id from t where name like '%abc%'
这两种写法都会导致全表扫描。

应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。

例题：select id from t where substring(name,1,3)='abc'
应改为：select id from t where name like 'abc%'

例题：select id from t where datediff(day,createdate,'2005-11-30')=0
应改为：select id from t where createdate>='2005-11-30' and createdate<'2005-12-1'

很多时候用exists代替in是一个好的选择。

例题：select num from a where num in(select num from b)
用下面的语句替换：select num from a where exists(select 1 from b where num=a.num)

任何地方都不要使用select * from t，用具体的字段列表代替*，不要返回用不到的任何字段。

能用DISTINCT的就不用GROUP BY。

例题：SELECT prj_num FROM out_stock GROUP BY prj_num
可改为：SELECT DISTINCT prj_num FROM out_stock

如果应用程序有很多JOIN查询，应该确认两个表中Join的字段是被建过索引的。

任何在order by语句的非索引项或者有计算表达式都将降低查询速度。

尽量避免使用游标，因为游标的效率较差。

尽量避免向客户端返回大数据量，若数据量过大应该考虑相应需求是否合理。

尽量避免大事务操作，提高系统并发能力。

## 九、查询优化技巧：优化数据库

硬件调整性能。

调整数据库配置。

使用存储过程。

优化应用程序结构和算法。

## 核心记忆要点

1. 一个表只能有一个聚集索引，但可以有多个非聚集索引
2. 聚集索引的数据行按索引键顺序物理存储，非聚集索引的索引和数据分开存储
3. InnoDB用B+树且主键索引是聚集索引，MyISAM用B-树且索引和数据分离
4. 避免全表扫描：不用null判断、不用!=或<>、慎用or和in、不对索引列做表达式或函数操作
5. Like查询只有前缀匹配才能用索引，如"abc%"可以，"%abc%"不行
6. 用exists代替in，用DISTINCT代替GROUP BY，用具体字段代替*
7. 索引不是越多越好，会降低insert和update效率
8. 连续数值用between不用in，能用数字型不用字符型，能用varchar不用char

---

## 【考场精简】第7章_关系数据库设计理论

# 【考场精简】第7章 关系数据库设计理论

## ⭐⭐⭐ 本章是大题/简答题主战场！必须掌握！

**核心考点：** 函数依赖（完全/部分/传递）、1NF/2NF/3NF判断、范式拆解步骤

---

## 考场做题速查卡（先看这个！）

### 题型1：判断关系属于第几范式
1. 写出所有函数依赖
2. 找候选码，分清主属性和非主属性
3. 检查部分依赖（看2NF）
4. 检查传递依赖（看3NF）

### 题型2：将关系分解到3NF
1. 先判断当前属于第几范式
2. 如果是1NF，找**部分依赖**，拆成2NF
3. 如果是2NF，找**传递依赖**，拆成3NF
4. **记住：** 必须按顺序拆，不能跳步！

### 关键口诀
- **部分依赖：** 码的真子集能决定非主属性
- **传递依赖：** 非主属性决定非主属性
- **拆表原则：** 把有问题的依赖分离出去，形成新表

---

## 一、问题的提出

**不好的数据库模式存在的问题：**
1. **数据冗余太大** - 浪费大量存储空间
2. **更新异常** - 更新代价大，可能导致数据不一致
3. **插入异常** - 该插的数据插不进去
4. **删除异常** - 不该删除的数据不得不删，造成某些数据丢失

**典型例题：** WAE关系模式 - WAE(仓库号, 所在区域, 区域主管, 设备号, 数量)。语义规定一个区域有多个仓库，一个仓库只能属于一个区域；一个区域只有一个区域主管；一个仓库可以存放多种设备，每种设备可以存放在多个仓库中；每个仓库的每种设备都有一个库存数量。这个模式存在上述所有问题。

**解决方法：** 通过分解关系模式来消除其中不合适的数据依赖。应该分解为三个关系模式：W(仓库号, 所在区域)、A(区域, 区域主管)、WE(仓库号, 设备号, 数量)。

---

## 二、函数依赖核心概念

### 1. 函数依赖定义

**函数依赖 X→Y：** 设R(U)是一个属性集U上的关系模式，X和Y是U的子集。若对于R(U)的任意一个可能的关系r，对任意两个元组t1和t2，若t1[X]=t2[X]，则t1[Y]=t2[Y]，则称X函数决定Y或Y函数依赖X，记作X→Y。X称为决定因素。

**三点说明：** 函数依赖是语义范畴的概念，只能根据数据的语义来确定；函数依赖不是指关系模式R的某个或某些关系实例满足的约束条件，而是指R的所有关系实例均要满足的约束条件；函数依赖存在时间无关性。

**函数依赖与属性间联系类型的关系：**
- 若属性X和Y之间有一对一的联系，则X→Y且Y→X，即X↔Y
- 若属性X和Y之间有多对一的联系，则X→Y，但Y不能推出X
- 若属性X和Y之间有多对多的联系，则X与Y之间不存在任何函数依赖

### 2. 函数依赖的分类

**平凡函数依赖与非平凡函数依赖：**
- **非平凡函数依赖：** 若X→Y，但Y不是X的子集，则称X→Y是非平凡函数依赖
- **平凡函数依赖：** 若X→Y，但Y是X的子集，则称X→Y是平凡函数依赖
- 注意：对任一关系模式，平凡函数依赖必然存在，一般讨论非平凡函数依赖

**完全函数依赖与部分函数依赖：** ⭐⭐⭐ 决定2NF
- **完全函数依赖：** 若X→Y，并且对于X的任何一个真子集X'，都有X'不能推出Y，则称Y完全函数依赖于X
  - 例：(学号, 课程号)→成绩，成绩必须依赖两个属性才能确定
- **部分函数依赖：** 若X→Y，但Y不完全函数依赖于X，则称Y部分函数依赖于X
  - 例：(学号, 课程号)→姓名，实际上学号就能确定姓名，这就是部分依赖
- **识别关键：** 看非主属性是否依赖于码的真子集

**传递函数依赖与直接函数依赖：** ⭐⭐⭐ 决定3NF
- **传递函数依赖：** 若X→Y，Y→Z，且Y不能推出X(即不是X↔Y)，则称Z对X传递函数依赖
  - 例：学号→系名→系主任（学号通过系名间接决定系主任）
  - **关键条件：** Y不能推出X，否则就不是传递依赖
- **直接函数依赖：** 如果Y→X(即X↔Y)，则Z对X直接函数依赖
- **识别关键：** 看是否存在 非主属性→非主属性 的依赖链

### 3. 码的概念

**候选码：** 设K为R<U,F>中的属性或属性组合，若K完全函数依赖推出U，则K称为R的一个候选码。

**主码：** 若关系模式R有多个候选码，则选定其中的一个作为主码。

**主属性：** 包含在任何一个候选码中的属性称为主属性。

**非主属性：** 不包含在任何一个候选码中的属性称为非主属性。

**全码：** 整个属性组全是码的情况称为全码。

---

## 三、范式与规范化

**范式定义：** 范式是符合某一种级别的关系模式的集合，是对关系数据库的规范化过程中为不同程度的规范化要求设立的不同标准。

**范式之间的关系：** 5NF ⊂ 4NF ⊂ BCNF ⊂ 3NF ⊂ 2NF ⊂ 1NF

**规范化：** 通过模式分解将一个低一级范式的关系模式转换为若干个高一级范式的关系模式集合的过程。

### 1. 第一范式（1NF）

**定义：** 如果一个关系模式R的所有属性都是不可分的基本数据项，则R∈1NF。

**说明：** 第一范式是对关系模式的最起码要求。不满足第一范式的数据库模式不能称为关系数据库。但满足第一范式的关系模式并不一定是一个好的关系模式。

### 2. 第二范式（2NF）⭐⭐⭐

**定义：** 若关系模式R∈1NF，并且每一个非主属性都**完全函数依赖**于R的码，则R∈2NF。

**核心要点：** 消除非主属性对码的**部分函数依赖**。

**识别技巧：** 当候选码是组合属性（多个属性组成）时，检查非主属性是否依赖于码的真子集。

**例题：** WAE(仓库号, 所在区域, 区域主管, 设备号, 数量)
- 码：(仓库号, 设备号)
- 主属性：仓库号、设备号
- 非主属性：所在区域、区域主管、数量
- 存在部分依赖：仓库号→所在区域，仓库号→区域主管（只依赖码的一部分）
- 结论：WAE∈1NF，但不属于2NF

**分解方法：** 
- WE(仓库号, 设备号, 数量) - 数量完全依赖于(仓库号, 设备号)
- WA(仓库号, 所在区域, 区域主管) - 所在区域、区域主管依赖于仓库号
- 结果：WE∈2NF, WA∈2NF

**⚠️ 注意：** 分解到2NF并不能完全消除异常！WA中仍存在问题（需要继续分解到3NF）。

### 3. 第三范式（3NF）⭐⭐⭐

**定义：** 如果关系模式R∈2NF，且每个非主属性都不**传递函数依赖**于R的候选码，则R∈3NF。

**核心要点：** 消除非主属性对码的**传递函数依赖**。

**识别技巧：** 检查是否存在 X→Y→Z 这样的依赖链，其中X是码，Y和Z都是非主属性。

**例题：** WA(仓库号, 所在区域, 区域主管)
- 码：仓库号
- 主属性：仓库号
- 非主属性：所在区域、区域主管
- 存在传递依赖：仓库号→所在区域→区域主管（非主属性决定非主属性）
- 结论：WA∈2NF，但不属于3NF

**分解方法：** 
- W(仓库号, 所在区域) - 直接依赖
- A(所在区域, 区域主管) - 直接依赖
- 结果：W∈3NF, A∈3NF

**⚠️ 易错点：** 传递依赖的关键是中间环节Y不能推出X（即不是X↔Y）。如果Y→X，那就不是传递依赖，而是直接依赖。

### 4. BC范式（BCNF）- 了解即可

**定义：** 设关系模式R∈1NF，若对于R的每个函数依赖X→Y，若Y不属于X，则X必含有候选码，那么R∈BCNF。

**核心要点：** 每一个决定因素都包含码。消除了主属性对码的部分和传递依赖。

**重要结论：** 若R∈BCNF则R∈3NF；若R∈3NF则R不一定属于BCNF。任何二元关系必定属于BCNF。

**例题：** WES(仓库号, 设备号, 职工号)。职工号→仓库号，(仓库号,设备号)→职工号。码为(仓库号,设备号)。属于3NF但不属于BCNF（因为职工号→仓库号中，职工号不包含候选码）。

### 5. 多值依赖与第四范式（4NF）- 了解即可

**多值依赖定义：** X→→Y表示给定X的值，对应一组Y值，且这组值与其他属性无关。

**典型例题：** Teaching(C, T, B)表示课程C、教师T和参考书B。某课程由多个教师讲授，使用相同参考书。C→→T且C→→B。全码(C,T,B)，属于BCNF但存在数据冗余和各种异常。

**多值依赖的性质：**
1. **对称性：** 若X→→Y，则X→→Z，其中Z=U-X-Y
2. **函数依赖是多值依赖的特殊情况：** 若X→Y，则X→→Y

**第四范式定义：** 关系模式R∈1NF，如果对于R的每个非平凡多值依赖X→→Y，X都含有候选码，则R∈4NF。

**拆解方法：** Teaching分解为CT(C,T)和CB(C,B)，都属于4NF。

---

## 四、规范化实战方法（重点掌握）

**规范化的基本思想：** 采用"一事一地"的模式设计原则，让一个关系描述一个概念、一个实体或者实体间的一种联系。若多于一个概念就把它"分离"出去。规范化实质上是概念的单一化。

### ⭐ 规范化的基本步骤（必须按顺序！）

**第一步：确保1NF** - 所有属性都是不可分的基本数据项

**第二步：1NF → 2NF** - 消除非主属性对码的**部分函数依赖**
- 方法：将部分依赖的属性分离出去，形成新的关系

**第三步：2NF → 3NF** - 消除非主属性对码的**传递函数依赖**
- 方法：将传递依赖的属性分离出去，形成新的关系

**第四步（了解）：3NF → BCNF** - 消除主属性对码的部分和传递函数依赖

**第五步（了解）：BCNF → 4NF** - 消除非平凡且非函数依赖的多值依赖

**⚠️ 重要提醒：** 规范化必须逐步进行，不能跳步！考试主要考查1NF→2NF→3NF的过程。

---

## 五、判断范式的标准步骤（简答题必考）

**给定关系模式和函数依赖集合，判断达到的最高范式：**

**步骤1：** 求出给定关系的函数依赖和候选码（可能不止一个）

**步骤2：** 根据码，写出主属性和非主属性

**步骤3：** 判断是否满足第一范式（属性的值域是否可以分解）

**步骤4：** 判断是否满足第二范式（检查：非主属性对码是否有部分函数依赖）

**步骤5：** 判断是否满足第三范式（检查：非主属性对码是否有传递函数依赖）

**步骤6：** 判断是否满足BCNF范式（检查：主属性对码的传递和部分函数依赖，即决定因素是否都包含候选码）

---

## 六、关系模式拆解标准流程（大题核心！）

### ⭐ 必须按照 1NF → 2NF → 3NF 顺序拆解，不能跳步！

**拆解原则：** 采用投影分解法，将一个低级范式关系分解为多个高级范式关系。

### 完整拆解流程示例

**原始关系：** WAE(仓库号, 所在区域, 区域主管, 设备号, 数量)

**步骤1：写出所有函数依赖**
- 仓库号 → 所在区域
- 所在区域 → 区域主管
- 仓库号 → 区域主管（传递）
- (仓库号, 设备号) → 数量

**步骤2：找出候选码**
- 候选码：(仓库号, 设备号)
- 主属性：仓库号、设备号
- 非主属性：所在区域、区域主管、数量

**步骤3：判断当前属于哪个范式**
- 属性不可再分 → 满足1NF
- 存在部分函数依赖：仓库号 → 所在区域（非主属性对码的真子集依赖）
- 结论：属于1NF，不属于2NF

**步骤4：拆解到2NF（消除部分函数依赖）**
- 找出所有部分函数依赖，将它们分离出去
- WE(仓库号, 设备号, 数量) - 码是(仓库号, 设备号)，数量完全依赖于码
- WA(仓库号, 所在区域, 区域主管) - 码是仓库号
- 现在两个关系都是2NF

**步骤5：检查2NF关系是否存在传递依赖**
- WE：无传递依赖 → 已经是3NF
- WA：存在传递依赖 仓库号 → 所在区域 → 区域主管
- 结论：WE∈3NF，WA∈2NF但不属于3NF

**步骤6：继续拆解到3NF（消除传递函数依赖）**
- 将WA中的传递依赖分离
- W(仓库号, 所在区域) - 码是仓库号
- A(所在区域, 区域主管) - 码是所在区域
- 现在三个关系都是3NF

**最终结果：**
- W(仓库号, 所在区域) ∈ 3NF
- A(所在区域, 区域主管) ∈ 3NF
- WE(仓库号, 设备号, 数量) ∈ 3NF

### 拆解口诀（考场速记）

**1NF → 2NF：** 看部分依赖，把"码的真子集能决定的非主属性"拆出去

**2NF → 3NF：** 看传递依赖，把"非主属性决定非主属性"的中间环节拆出去

**记住：** 拆解后的每个关系都要保留原来的码或者新的候选码！

---

## 七、典型大题练习（必练！考试原题类型）

**练习1：** 已知关系模式R<U,F>，U={A,B,C,D}，F={AB→D, AC→BD, B→C}。在函数依赖范围内该关系属于的最高范式是什么？

**解答：** 关系r的候选码为AB和AC。主属性为A、B、C，非主属性为D。判断：R的所有属性值域都不可再分，则r∈1NF；非主属性D不存在对任何码的部分函数依赖，则r∈2NF；非主属性D不存在对任何码的传递函数依赖，则r∈3NF；因为有函数依赖B→C，而B不是关系R的码，则r不属于BCNF。结论：r∈3NF。

**练习2：** 已知关系模式R<U,F>，U={A,B,C,D,E,F}，F={A→B, C→DF, AC→E, D→F}。在函数依赖范围内该关系属于的最高范式是什么？

**解答：** 关系r的候选码为AC。主属性为A、C，非主属性为B、D、E、F。判断：R的所有属性值域都不可再分，则r∈1NF；由于存在函数依赖A→B和C→DF，而A和C均不是关系的码，存在非主属性B、D、F对码的部分函数依赖，则r不属于2NF。结论：r∈1NF。

**练习3：** 某商业集团数据库中有一关系模式R，R(商店编号, 商品编号, 数量, 部门编号, 负责人)。规定：每个商店的每种商品只在一个部门销售；每个商店的每个部门只有一个负责人；每个商店的每种商品只有一个库存数量。

**问题1：** 写出关系模式R的基本函数依赖。
**解答：** (商店编号, 商品编号)→部门编号；(商店编号, 部门编号)→负责人；(商店编号, 商品编号)→数量。

**问题2：** 找出关系模式R的候选码。
**解答：** R的候选码为(商店编号, 商品编号)。

**问题3：** 关系模式R最高已经达到第几范式？为什么？
**解答：** 因为R中存在着非主属性"负责人"对候选码(商店编号, 商品编号)的传递函数依赖，但无部分函数依赖，所以R属于2NF，R不属于3NF。

**问题4：** 如果R不属于3NF，请将R分解成3NF模式集。
**解答：** 将R分解为R1(商店编号, 商品编号, 数量, 部门编号)和R2(商店编号, 部门编号, 负责人)。

---

## 八、考前速记重点（背熟！）

### ⭐ 三种函数依赖（必考）
1. **完全函数依赖：** X→Y，且X的任何真子集都不能推出Y
2. **部分函数依赖：** X→Y，但X存在真子集也能推出Y
3. **传递函数依赖：** X→Y，Y→Z，且Y不能推出X

### ⭐ 三个范式的核心区别（必考）
1. **1NF：** 属性不可再分
2. **2NF：** 1NF + 消除非主属性对码的**部分函数依赖**
3. **3NF：** 2NF + 消除非主属性对码的**传递函数依赖**

### ⭐ 拆表步骤（必考）
- **1NF → 2NF：** 找部分依赖，拆出"码的真子集决定的非主属性"
- **2NF → 3NF：** 找传递依赖，拆出"非主属性决定非主属性"的链条
- **记住：** 必须按顺序，不能跳步！

### ⭐ 判断范式流程（必考）
1. 求候选码
2. 分清主属性和非主属性
3. 检查部分依赖（决定2NF）
4. 检查传递依赖（决定3NF）

### 其他重要结论
- **函数依赖只能根据语义确定**，不能只看数据实例
- **任何二元关系必定属于BCNF**
- **全是主属性的关系必定是3NF**
- **范式包含关系：** 5NF ⊂ 4NF ⊂ BCNF ⊂ 3NF ⊂ 2NF ⊂ 1NF
- **多值依赖对称性：** 若X→→Y，则X→→Z（Z=U-X-Y）

---

## 【考场精简】第8章_数据库设计

# 【考场精简】第8章 数据库设计

## 一、数据库设计概述

**数据库设计定义**：为给定应用环境构造最优数据库模式，建立数据库及应用系统，有效存储数据，满足用户的信息要求和处理要求。

**设计目标**：为用户和各种应用系统提供信息基础设施和高效率运行环境。

**数据库建设基本规律**：三分技术，七分管理，十二分基础数据。

### 设计方法

**规范设计法**：基本思想是过程迭代和逐步求精。典型方法包括基于E-R模型的设计方法、3NF第三范式设计方法。

**计算机辅助设计法**：使用工具如Rational Rose、PowerDesigner、Oracle Designer等。

### 数据库设计六个阶段

**1. 需求分析阶段**：了解并收集用户需求，形成需求分析说明书。

**2. 概念设计阶段**：对用户需求进行综合、归纳与抽象，形成独立于DBMS的概念数据模型，通常使用E-R图表示。

**3. 逻辑设计阶段**：将概念数据模型转化为某一DBMS所支持的数据模型，形成数据库逻辑模式，建立必要的视图形成外模式。

**4. 物理设计阶段**：为逻辑数据模型选择最适合应用环境的物理结构，形成数据库内模式。

**5. 数据库实施阶段**：在计算机系统中建立数据库结构、载入数据、测试程序、试运行。

**6. 数据库运行与维护阶段**：数据库系统正式投入运行，由DBA承担日常维护工作。

### 设计特点

**结构设计与行为设计相结合**：结构设计是静态稳定的，包括概念设计、逻辑设计和物理设计。行为设计是动态的，包括应用程序设计、事务处理设计等。

---

## 二、需求分析

**需求分析任务**：通过详细调查现实世界要处理的对象，充分了解原系统工作概况，明确用户各种需求，确定新系统功能。必须充分考虑今后可能的扩充和改变。

### 需求分析步骤

**第一步：调查分析用户活动**，调查组织机构情况以及各部门业务活动情况。

**第二步：收集和分析需求数据，确定系统边界**，明确用户的信息需求、处理需求、安全性和完整性需求等。

**第三步：编写系统需求分析报告**，包括数据流图、功能模块图、数据字典等。

### 需求分析重点

**信息要求**：用户需要从数据库中获得的信息内容与性质，由此导出数据要求，即需要在数据库中存储哪些数据。

**处理要求**：对处理功能的要求、对处理响应时间的要求、对处理方式的要求如批处理或联机处理。

**安全性与完整性要求**：确保数据的安全性和一致性。

### 数据字典

**数据字典定义**：各类数据描述的集合，用来说明系统中数据的静态组成结构，是数据库系统中各类数据属性的清单。

**数据字典内容包括五部分**：

**1. 数据项**：不可再分的数据单位。描述包括数据项名、含义说明、别名、数据类型、长度、取值范围、取值含义、与其他数据项的逻辑关系。

例：物资编号，含义为库存物资唯一标识，类型为字符型，长度为4，取值范围m001到m999。

**2. 数据结构**：反映数据之间的组合关系，由若干数据项或数据结构组成。描述包括数据结构名、含义说明、组成。

例：抢修物资数据结构，组成包括物资编号、物资名称、物资规格、保存的仓库、库存数量、单价。

**3. 数据流**：数据结构在系统内传输的路径。描述包括数据流名、说明、数据流来源、数据流去向、组成、平均流量、高峰期流量。

**4. 数据存储**：数据结构停留或保存的地方。描述包括数据存储名、说明、编号、输入输出的数据流、组成、数据量、存取频度、存取方式。

**5. 处理过程**：描述包括处理过程名、说明、输入输出数据流、处理逻辑。

---

## 三、概念设计

**概念设计任务**：将需求分析得到的用户需求抽象为信息结构即概念模型的过程。

**概念结构特点**：能真实充分反映现实世界、易于理解、易于更改、易于向各种数据模型转换。

**描述工具**：实体联系模型，即E-R模型。

### E-R模型基本概念

**实体**：现实世界中客观存在并可相互区别的事物。

**属性**：实体所具有的某一特性。

**码**：唯一表示实体的属性集。

**域**：属性的取值范围。

**实体型**：用实体名及其属性名集合来抽象和刻画同类实体。例：员工（员工编号、姓名、部门、性别、年龄、职称）。

**实体集**：具有相同特征的实体集合。

**联系**：实体之间的关系，分为三类。

### 实体间联系类型

**1对1联系1:1**：对于实体集A中的每一个实体，实体集B中至多有一个实体与之联系，反之亦然。

例：部门与负责人之间的关系，一个部门只有一个负责人，一个负责人只负责一个部门。

**1对多联系1:n**：对于实体集A中的每一个实体，实体集B中有n个实体与之联系，反之对于实体集B中的每一个实体，实体集A中至多只有一个实体与之联系。

例：部门与员工之间的关系，一个部门有多个员工，一个员工只属于一个部门。

**多对多联系m:n**：对于实体集A中的每一个实体，实体集B中有n个实体与之联系，反之对于实体集B中的每一个实体，实体集A中也有m个实体与之联系。

例：学生与课程之间的关系，一个学生可以选修多门课程，一门课程可被多个学生选修。

**弱实体集**：属性不足以形成主码，需要依赖其他实体集中的部分属性的实体集。例：工作履历实体集依赖于员工实体集而存在。

### E-R图表示方法

**矩形**：表示实体，矩形内写实体名。

**椭圆形**：表示属性，键值属性加下划线。

**菱形**：表示联系。

**连线**：连接实体型与联系类型，并注明联系种类1:1、1:n、m:n。

**虚边矩形和虚边菱形**：分别表示弱实体和弱实体之间的联系。

### E-R图设计步骤

**第一步**：确定实体类型及相应的实体名。

**第二步**：确定联系类型，包括各实体类型之间的联系种类及相应的联系名。

**第三步**：连接实体类型和联系类型，组合成E-R图。

**第四步**：确定实体类型和联系类型的属性。

**第五步**：确定实体类型的码。

### 概念结构设计方法

**常用策略**：自顶向下地进行需求分析，自底向上地设计概念结构。

**自底向上设计步骤**：

**第1步：抽象数据并设计局部视图**。选择中层数据流图作为设计分E-R图的依据，将各局部应用涉及的数据从数据字典中抽取出来，标定局部应用中的实体、实体属性、实体的码，确定实体之间的联系及其类型。

**第2步：集成局部视图，得到全局概念结构**。

### 局部E-R图集成方法

**集成方式**：多元集成法适用于局部视图比较简单时；二元集成法首先集成两个关键的局部视图，然后每次将一个新的局部视图集成进来。

**集成步骤**：

**第一步：合并**，解决各局部E-R图之间的冲突，将各分E-R图合并起来生成初步E-R图。

**第二步：优化**，消除不必要的冗余，生成全局E-R图。

### 合并时需解决的三种冲突

**属性冲突**：

**属性域冲突**：属性值的类型、取值范围或取值集合不同。

**属性取值单位冲突**：同一属性在不同局部应用中使用不同单位。

例：课程属性中，选课管理用学分属性，教师开课管理用学时属性，而学时和学分是互通的，应统一用一种。

**命名冲突**：

**同名异义**：不同意义的对象在不同局部应用中具有相同名字。

**异名同义**：同一意义的对象在不同局部应用中具有不同名字。

例：学籍管理和选课管理都用学院实体，而教师开课管理中用部门实体，其实学院和部门表示同一种实体，应统一为学院。

**结构冲突**：

**同一对象在不同应用中具有不同抽象**。

例：专业在学籍管理中被当作实体，而在选课管理中则被当作属性。

解决方法准则：属性不能再具有需要描述的性质；属性不能与其他实体具有联系；为了简化E-R图的处理，现实世界中的事物凡能够作为属性对待的应尽量作为属性。

**同一实体在不同分E-R图中所包含的属性不完全相同或排列次序不同**。

解决方法：使该实体的属性取各分E-R图中属性的并集，再适当调整属性次序。

**实体之间的联系在不同局部视图中呈现不同类型**。

解决方法：根据应用语义对实体联系的类型进行综合或调整。

### 优化：消除冗余

**冗余的数据**：可由基本数据导出的数据。

**冗余的联系**：可由其他联系导出的联系。

冗余容易破坏数据库完整性，给数据库维护增加困难。

**消除冗余方法**：以数据字典和数据流图为依据，根据数据字典中关于数据项之间逻辑关系的说明来消除冗余。

例：选课联系中的绩点属性可以由成绩推算出来，属于冗余数据可以去掉。学院实体与课程实体之间的开设联系，可以由学院与教师实体之间的属于联系、教师与课程实体之间的讲授联系推导出来，属于冗余联系。

---

## 四、逻辑设计

**逻辑设计任务**：将概念结构设计好的E-R图转化为相应的数据模型。

### 逻辑设计步骤

**第一步**：将概念结构转化为一般的关系模型。

**第二步**：将转化来的关系模型向特定DBMS支持下的数据模型转换。

**第三步**：对数据模型进行优化。

### E-R图转化为关系模型的转换原则

**原则1：一个实体型转换为一个关系模式**。

关系的属性为实体型的属性，关系的码为实体型的码。

例：学院（学院编号，学院名）、专业（专业号，专业名）、班级（班级号，班级名）、学生（学号，姓名，性别，出生日期）、课程（课程号，课程名）、教师（工号，姓名，性别，职称）。

**原则2：一个1:1联系可转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并**。

转换为独立关系模式时：关系的属性为与该联系相连的各实体的码以及联系本身的属性；关系的码为每个实体的码均是该关系的候选码。

与某一端合并时：关系的属性为在该关系模式中加入对应关系的码和联系本身的属性；关系的码不变。

例：负责联系为1:1联系，有三种转换方法：转换为独立关系模式负责（学院编号，工号）；或与系关系合并系（学院编号，系名，工号）；或与负责人关系合并负责人（工号，姓名，性别，学院编号）。

注意：从理论上讲1:1联系可以与任意一端对应的关系模式合并，但在一些情况下与不同的关系模式合并效率会大不一样，应以尽量减少连接操作为目标。

**原则3：一个1:n联系可转换为一个独立的关系模式，也可以与n端对应的关系模式合并**。

转换为独立关系模式时：关系的属性为与该联系相连的各实体的码以及联系本身的属性；关系的码为n端实体的码。

与n端合并时：关系的属性为在n端关系模式中加入1端关系的码和联系本身的属性；关系的码不变。

例：开设联系为1:n联系，有两种转换方法：转换为独立关系模式开设（学院编号，专业号）；或与专业关系合并专业（专业号，专业名，学院编号）。

**原则4：一个m:n联系可转换为一个关系模式**。

关系的属性为与该联系相连的各实体的码以及联系本身的属性；关系的码为各实体码的组合。

例：选修联系是m:n联系，转换为选修（学号，课程号，成绩），其中学号与课程号为关系的组合码。

**原则5：三个或三个以上实体间的一个多元联系可转换为一个关系模式**。

关系的属性为与该多元联系相连的各实体的码以及联系本身的属性；关系的码为各实体码的组合。

例：供应联系转换为供应（供应商号，项目号，零件号，数量）。

**原则6：具有相同码的关系模式可合并**。

目的是减少系统中的关系个数。合并方法是将其中一个关系模式的全部属性加入到另一个关系模式中，然后去掉其中的同义属性，并适当调整属性次序。

例：开设（系号，专业号）和专业（专业号，专业名）可合并为专业（专业号，专业名，系号）。

### 关系模式优化

**为什么要优化**：数据库逻辑设计的结果不是唯一的，得到初步数据模型后还应适当修改调整数据模型的结构，以进一步提高数据库应用系统的性能。优化通常以规范化理论为指导。

**优化步骤**：

**第1步**：确定数据依赖，按需求分析阶段所得到的语义，分别写出每个关系模式内部各属性之间的数据依赖以及不同关系模式属性之间的数据依赖。

**第2步**：对于各个关系模式之间的数据依赖进行极小化处理，消除冗余的联系。

**第3步**：按照数据依赖的理论对关系模式逐一进行分析，考查是否存在部分函数依赖、传递函数依赖、多值依赖等，确定各关系模式分别属于第几范式。

例：在关系模式工资（工号，姓名，基本工资，岗位补贴，应发工资，五险一金，实发工资）中存在函数依赖：工号→姓名基本工资岗位工资；基本工资岗位工资→应发工资；应发工资→五险一金；应发工资五险一金→实发工资。显然有工号→应发工资五险一金实发工资，因此该关系模式中存在传递函数依赖，是2NF关系。

**注意**：并不是规范化程度越高的关系就越优。当一个应用的查询中经常涉及到两个或多个关系模式的属性时，系统必须经常地进行联接运算，而联接运算的代价相当高。对于一个具体应用，规范化进行到什么程度需要权衡响应时间和潜在问题两者的利弊才能决定。

虽然应发工资、五险一金、实发工资可以由其他属性推算出来，但如果应用中需要经常查询职工的这些工资项，为提高效率仍然可保留该冗余数据，对关系模式不再做进一步分解。一种更好的方法是把冗余数据定义在视图中。

**第4步**：按照需求分析阶段得到的各种应用对数据处理的要求，分析对于这样的应用环境这些模式是否合适，确定是否要对它们进行合并或分解。

**第5步**：对关系模式进行必要的分解，以提高数据操作的效率和存储空间的利用率。

### 关系模式的分解

**水平分解**：把基本关系的元组分为若干子集合，定义每个子集合为一个子关系，以提高系统效率。

适用范围：

满足80/20原则的应用，即一个大关系中经常被使用的数据只是关系的一部分约20%，把经常使用的数据分解出来形成子关系，可以减少查询的数据量。

例：某网站注册用户关系用户（用户ID，用户名等），只有少部分是活跃用户，其他用户很少登录。水平分割为活跃用户和非活跃用户两个关系。

并发事务经常存取不相交的数据。

例：某大学学生信息表学生（学号，姓名，出生年月等），多数查询一次仅涉及其中一类学生。水平分割为本科生、硕士生、博士生三个关系。

**垂直分解**：把关系模式R的属性分解为若干子集合，形成若干子关系模式。

适用范围：取决于分解后R上的所有事务的总效率是否得到了提高。

原则：垂直分解必须保持无损连接性和保持函数依赖。

优点：减少数据传递量，提高查询速度。

例：学生情况的关系模式学生（学号，姓名，性别，出生年月，专业班级，家庭住址，联系方式，家庭联系人），经常查询前五项，较少使用后三项。垂直模式分解为Student1（学号，姓名，性别，出生年月，专业班级）和Student2（学号，家庭住址，联系方式，家庭联系人）。

一个表中的字段同时存在经常查询和非经常查询的属性，均可采用垂直分割的方法。

### 设计用户子模式

**定义外模式原则**：从系统的时间效率、空间效率、易维护等角度出发定义数据库模式；定义用户外模式时应更注重考虑用户的习惯与方便。

**包括三个方面**：

**使用更符合用户习惯的别名**。

例：负责学籍管理的用户习惯于称教师模式的工号为教师编号，因此可以定义视图，在视图中职工号重定义为教师编号。

**针对不同级别的用户定义不同的外模式以满足系统对安全性的要求**。

例：关系模式学生（学号、姓名、性别、出生日期、班级、入学年份、家庭住址），教务管理系统只能查询学生的学号、姓名、性别、班级、入学年份，定义外模式视图学生_教务系统（学号、姓名、性别、班级、入学年份）。这样可以防止用户非法访问本来不允许他们查询的数据，保证了系统的安全性。

**简化用户对系统的使用**。

如果某些局部应用中经常要使用某些很复杂的查询，为了方便用户可以将这些复杂查询定义为视图。

---

## 五、物理设计

**物理设计定义**：为一个给定的逻辑数据模型选取一个最适合应用要求的物理结构的过程。

**数据库的物理结构**：数据库在物理设备上的存储结构与存取方法，依赖于给定的计算机系统。

**设计准备工作**：

充分了解应用环境，详细分析要运行的事务，以获得选择数据库物理设计所需参数，特别是应用的处理频率和响应时间要求。

充分了解所用RDBMS的内部特征，特别是系统提供的存取方法和存储结构。有哪些存储结构如行存储、列存储、聚簇存储，如何选择。有哪些索引如B加树索引、HASH索引等，如何建立索引。

熟悉外存设备的特性，如分块原则、块因子大小的规定、设备的I/O特性等。

**注意**：不同的DBMS产品物理环境、存取方法和存储结构有很大差别，能供设计人员使用的设计变量、参数范围很不相同，没有通用的物理设计方法，只能给出一般的设计内容和原则。

### 物理设计步骤

**第一步：确定数据库的物理结构，包括存取方法和存储结构**。

**确定数据的存储结构**：考虑因素包括存取时间、存储空间利用率和维护代价等。

**设计合适的存取路径**：主要指确定如何建立索引。

**确定数据的存放位置**：根据应用情况将易变部分与稳定部分、存取频率较高部分与存取频率较低部分分开存放，以提高系统性能。

**确定系统配置**：DBMS产品一般都提供了一些系统配置变量和存储分配参数。

**第二步：对物理结构进行评价**。

评价内容：对数据库物理设计过程中产生的多种方案对其时间效率、空间效率、维护代价和各种用户需求进行细致的评价，从中选择一个较优的方案作为数据库的物理结构。

评价方法：定量估算各种方案的存储空间、存取时间以及维护代价；对估算结果进行权衡比较选择出一个较优的合理的物理结构；如果该结构不符合用户需求则需要修改设计。

**注意**：数据库的物理设计不是一劳永逸的，要根据应用的变化及时收集设计信息，调整数据库的物理结构。

---

## 六、数据库实施、运行与维护

### 数据库实施的工作内容

**第一步：用DDL定义数据库结构**。

例：CREATE TABLE stocks（mat_no char(8) primary key，……check……）；CREATE VIEW view1（……）；CREATE INDEX ……。

**第二步：组织数据入库**，即数据装载ETL。

数据装载方法：人工方法适用于小型系统；计算机辅助数据入库适用于中大型系统。

**第三步：编制与调试应用程序**。

数据库应用程序的设计应与数据库设计同时进行。在数据库实施阶段当数据库结构建立好后就可以开始编制与调试数据库的应用程序。调试应用程序时由于数据入库尚未完成，可先使用模拟数据。

**第四步：数据库试运行**。

也称为联合调试，主要工作包括：

**功能测试**：实际运行应用程序执行对数据库的各种操作，测试应用程序的各种功能。

**性能测试**：测试系统的性能指标分析是否符合设计目标。如果结果不符合设计目标则需要返回物理设计阶段调整物理结构修改参数，有时甚至需要返回逻辑设计阶段调整逻辑结构。

### 数据库实施过程中注意事项

**组织数据分批分期入库**，先输入小批量数据做调试使用，待试运行基本合格后再大批量输入数据。

**首先调试运行DBMS的恢复功能**，做好数据库的转储和恢复工作。在数据库试运行阶段系统还不稳定，硬软件故障随时都可能发生，系统的操作人员对新系统还不熟悉，误操作也不可避免。

**整理文档**。在应用程序编制调试及试运行时应该随时将发现的问题的解决方案记录下来整理成文档，以备运行维护和改进时参考。试运行成功后还应编写测试报告、应用系统的技术说明书和使用说明书，在正式使用时一并交给用户。完整的文档是应用系统的重要组成部分。

### 数据库运行与维护

在数据库运行阶段对数据库经常性的维护工作主要是由DBA完成的，包括：

**1. 数据库的转储和恢复**。

转储和恢复是系统正式运行后最重要的维护工作之一。DBA要针对不同的应用要求制定不同的转储计划，定期对数据库和日志文件进行备份。一旦发生介质故障即利用数据库备份及日志文件备份，尽快将数据库恢复到某种一致性状态。

**2. 数据库的安全性、完整性控制**。

DBA必须根据用户的实际需要授予不同的操作权限。在数据库运行过程中由于应用环境的变化，对安全性的要求也会发生变化，DBA需要根据实际情况修改原有的安全性控制。由于应用环境的变化数据库的完整性约束条件也会变化，也需要DBA不断修正以满足用户要求。

**3. 数据库性能的监督、分析和改进**。

在数据库运行过程中DBA必须监督系统运行，对监测数据进行分析找出改进系统性能的方法。利用监测工具获取系统运行过程中一系列性能参数的值，通过仔细分析这些数据判断当前系统是否处于最佳运行状态。如果不是则需要通过调整某些参数来进一步改进数据库性能。

**4. 数据库的重组织和重构造**。

**数据库的重组织**：

重组织形式包括全部重组织和部分重组织，只对频繁增删的表进行重组织。

重组织工作：按原设计要求重新安排存储位置、回收垃圾、减少指针链等，以提高系统性能。

重组织实质：不会修改原设计的逻辑和物理结构。

**数据库的重构造**：

重构造工作：根据新环境调整数据库的模式和内模式，比如增加新的数据项、改变数据项的类型、改变数据库的容量、增加或删除索引、修改完整性约束条件。

重构造实质：部分修改数据库的模式和内模式。

重构造局限：部分重构造。若变化太大无法通过重构数据库来满足新的需求，或重构数据库的代价太大，则表明现有数据库应用系统的生命周期已经结束，应该重新设计新的数据库应用系统了。

---

## 七、典型例题

### 例题1：教务管理系统E-R图转换

**题目**：某教务管理系统有以下语义，请转换为关系模式。

语义描述：一个学院开设多个专业（1:n），一个专业有多个班级（1:n），一个班级有多个学生（1:n），一个学生可选修多门课程（m:n），一门课程可为多个学生选修，一个学院可开设多门课程（1:n），一名教师可讲授多门课程（m:n），一门课程可为多名教师讲授，一个学院有多名教师（1:n），一个学院只有一个负责人（1:1）。

**解答**：

学院（学院编号，学院名）

专业（专业号，专业名，学院编号）——将1:n的开设联系与n端合并

班级（班级号，班级名，专业号）——将1:n的拥有联系与n端合并

学生（学号，姓名，性别，出生日期，班号）——将1:n的包含联系与n端合并

课程（课程号，课程名，学院编号）——将1:n的开设联系与n端合并

教师（工号，姓名，性别，职称，学院编号）——将1:n的属于联系与n端合并

选修（学号，课程号，成绩）——m:n联系转换为独立关系，组合码

讲授（工号，课程号，学时）——m:n联系转换为独立关系，组合码

负责人（工号，姓名，性别，学院编号）——1:1联系与负责人端合并

### 例题2：关系模式优化判断

**题目**：关系模式工资（工号，姓名，基本工资，岗位补贴，应发工资，五险一金，实发工资）中，应发工资等于基本工资加岗位补贴，实发工资等于应发工资减五险一金，五险一金根据应发工资计算。请分析该关系属于第几范式，是否需要分解。

**解答**：

存在函数依赖：工号→姓名基本工资岗位补贴；基本工资岗位补贴→应发工资；应发工资→五险一金；应发工资五险一金→实发工资。

显然有工号→应发工资五险一金实发工资，存在传递函数依赖，该关系模式是2NF。

是否分解需要根据应用需求：如果经常查询这些工资项，为提高效率可保留冗余数据不分解。更好的方法是把冗余数据定义在视图中，基表只保留工号、姓名、基本工资、岗位补贴，应发工资、五险一金、实发工资通过视图计算得到。

### 例题3：水平分解与垂直分解

**题目**：某大学学生表学生（学号，姓名，性别，出生年月，专业班级，家庭住址，联系方式，家庭联系人，入学年份，学生类别），其中学生类别包括本科生、硕士生、博士生。查询统计显示80%的查询只涉及前五个属性，且多数查询一次只针对某一类学生。请给出优化方案。

**解答**：

可以同时采用水平分解和垂直分解：

**水平分解**：按学生类别分为本科生（学号，姓名，性别，出生年月，专业班级，家庭住址，联系方式，家庭联系人，入学年份）、硕士生（学号，姓名，性别，出生年月，专业班级，家庭住址，联系方式，家庭联系人，入学年份）、博士生（学号，姓名，性别，出生年月，专业班级，家庭住址，联系方式，家庭联系人，入学年份）三个关系。

**垂直分解**：将常用属性和非常用属性分开，每类学生分为两个关系。如本科生基本信息（学号，姓名，性别，出生年月，专业班级）和本科生详细信息（学号，家庭住址，联系方式，家庭联系人，入学年份）。

这样既减少了查询时扫描的数据量，又将常用数据与非常用数据分离，大大提高了查询效率。

### 例题4：物理设计中的索引选择

**题目**：某仓库管理系统中，零件表零件（零件号，零件名，规格，单价，库存量），经常执行以下操作：按零件号精确查找零件信息；按零件名模糊查找零件；统计库存量小于100的零件；按单价排序输出零件清单。请设计索引方案。

**解答**：

在零件号上建立**主键索引**（唯一索引）：因为零件号是主键，需要频繁精确查找，建立B加树索引可以快速定位。

在零件名上建立**普通索引**：虽然有模糊查询，但建立索引后至少可以加速前缀匹配的模糊查询。

在库存量上建立**普通索引**：因为经常按库存量范围查询，B加树索引适合范围查询。

在单价上建立**普通索引**：因为需要按单价排序，索引可以避免额外的排序操作。

注意：索引会占用存储空间并降低更新速度，需要根据查询频率和更新频率权衡。如果某个字段更新非常频繁而查询很少，可以不建索引。

---

## 八、重点记忆口诀

**数据库设计六阶段**：需概逻物实运维。

**E-R图转关系原则**：实体变关系码不变，1:1随意合并，1:n合n端，m:n独立建，多元联系码组合。

**三种冲突**：属性冲突看域和单位，命名冲突同名异义异名同义，结构冲突同一对象不同抽象。

**优化不是越高越好**：权衡响应时间和潜在问题，连接代价高时低范式更优。

**水平分解**：80/20原则，按类别分，常用与不常用分。

**垂直分解**：常查与非常查分开，减少数据传递量。

**物理设计关键**：存储结构选择，索引建立，数据存放位置，系统配置。

**DBA运维四大任务**：转储恢复，安全完整性控制，性能监督改进，重组织重构造。

---

## 考场提示

1. **E-R图转关系时注意**：1:n联系优先与n端合并可减少连接操作；m:n联系必须独立建立关系。

2. **判断范式时**：先找候选码，再看是否存在非主属性对码的部分依赖和传递依赖。

3. **优化决策时**：如果经常联合查询多个表不要过度分解；如果只查单表某些字段考虑垂直分解。

4. **物理设计时**：频繁查询的字段建索引，频繁更新的字段慎建索引；范围查询用B加树，精确查询可用HASH。

5. **实施阶段**：先小批量数据调试，先测恢复功能，文档要完整。

---

**本章完**

---

## 【考场精简】第9章_数据库安全

# 【考场速记】第9章 - 数据库安全

> ⭐ 老师说不咋考，内容多但点集中，偏选择/简答

---

## 一、安全模型层次 ⭐⭐

**一级一级层层设置**（从外到内）：
1. **用户标识和鉴别** - 最外层
2. **存取控制** - DBMS层（DAC/MAC）
3. **视图、审计** - 细粒度控制
4. **操作系统安全保护** - OS层
5. **密码保护** - 数据库层

---

## 二、安全要求与威胁 ⭐

### 三大安全要求
- **保密性** - 数据不泄露
- **完整性与一致性** - 数据正确可靠
- **有效性** - 数据可用

### 三大安全威胁
- **外部攻击** - 黑客入侵
- **权限滥用** - 合法用户越权
- **内部人员窃取** - 内鬼泄密

---

## 三、用户标识与鉴别 ⭐

**作用**：最外层安全保护

**常用方法**：
1. **用户名/口令** - 简单易行，易被窃取
2. **随机数+函数计算** - 系统提供随机数，用户计算验证

---

## 四、存取控制 ⭐⭐⭐

### DAC（自主存取控制）⭐⭐⭐

**特点**：用户可以控制

**实现**：
- **授权**：`GRANT` - 给权限
- **收回**：`REVOKE` - 收回权限

**机制**：查数据字典检查权限

---

### MAC（强制存取控制）⭐⭐

**特点**：
- 系统强制执行，用户**不能直接感知或控制**
- 按TDI/TCSEC安全标准
- 适用于**严格密级分类部门**（如军事）

**与DAC区别**：

| 对比项 | DAC（自主） | MAC（强制） |
|--------|------------|-------------|
| 控制者 | 用户可控 | 系统强制 |
| 灵活性 | 灵活 | 固定 |
| 感知度 | 用户感知 | 用户无感 |
| 适用场景 | 一般企业 | 高密级部门 |

---

## 五、视图机制 ⭐⭐

**作用**：把保密数据对无权用户隐藏

**使用方式**：**视图 + 授权机制配合**
1. 先建视图（屏蔽部分数据）
2. 再在视图上授权

**示例逻辑**：
```
CREATE VIEW 视图名 AS SELECT ...  -- 先建视图
GRANT SELECT ON 视图名 TO 用户   -- 再授权
```

---

## 六、审计 ⭐⭐⭐

### 核心概念
**审计 = 专用审计日志（Audit Log）记录用户所有操作**

### 作用
- **监视措施** - 跟踪记录数据访问活动
- **DBA利用审计日志** - 找出非法存取的人、时间、内容

### 实现方式
**触发器 + 审计表**：
- 创建审计表（记录：谁、何时、改了什么、旧值、新值）
- 创建触发器（`AFTER UPDATE` → 自动记录）

### 注意
- **很费时间和空间**
- DBA可灵活打开/关闭

---

## 七、数据加密 ⭐⭐⭐

### 解决的问题
1. DBA可无限制访问数据
2. 非法用户盗取文件/磁盘/内存
3. 存储设备被盗
4. **网络传输被窃听**

---

### 加密算法 ⭐⭐⭐

| 类型 | 密钥特点 | 典型算法 |
|------|----------|----------|
| **对称加密** | 加密解密用**同一密钥** | **DES、AES** |
| **非对称加密** | 需**公钥+私钥**两个密钥 | **RSA** |

**记忆**：对称=一把钥匙，非对称=两把钥匙

---

### 加密实现层次

**3个层次**（从底层到顶层）：
1. **操作系统层** - 最底层
2. **DBMS内核层** - 中间层
3. **DBMS外层** - 最外层（客户端）

---

### 加密优点
- **对用户透明** - 用户无感知
- **独立于应用系统** - 无需改动应用
- **客户端加解密** - 不影响服务器效率

### 需考虑的问题
- 加密粒度：字段/记录/表
- 加密数据选择
- 密钥动态管理
- 加密透明性

---

## 八、MySQL安全 ⭐⭐

### 权限系统两阶段
1. **身份认证** - IP地址+用户名联合认证
2. **权限赋予** - 通过后赋予权限

### 重要权限表 ⭐

| 权限表 | 作用范围 |
|--------|----------|
| **user表** | 针对**所有数据库**的全局权限（39字段） |
| **db表** | 针对**某个数据库**的权限（22字段） |
| tables_priv | 针对**单个表**的权限 |
| columns_priv | 针对**单个列**的权限 |
| procs_priv | 针对**存储过程/函数**的权限 |

**检查顺序**：user → db → tables_priv → columns_priv（权限范围递减）

**规则**：全局权限Y则全Y，不再检查后面

---

### MySQL用户管理

```sql
-- 创建用户
CREATE USER '用户'@'主机' IDENTIFIED BY '密码'

-- 修改用户
RENAME USER '旧用户'@'主机' TO '新用户'@'主机'

-- 删除用户
DROP USER '用户'@'主机'
```

**注意**：`'root'@'localhost'` vs `'root'@'%'`（%=任意主机）

---

### MySQL权限管理 ⭐⭐⭐

```sql
-- 授权
GRANT 权限 ON 数据库.表 TO 用户 [WITH GRANT OPTION]

-- 收回
REVOKE 权限 ON 数据库.表 FROM 用户

-- 查看权限
SHOW GRANTS FOR '用户'@'主机'
```

**WITH GRANT OPTION**：被授权用户可将权限转授他人

---

### MySQL角色管理 ⭐

```sql
CREATE ROLE '角色'           -- 创建角色
GRANT 权限 TO '角色'          -- 给角色授权
GRANT 角色 TO 用户            -- 给用户赋角色
SET DEFAULT ROLE 角色 TO 用户 -- 激活角色
DROP ROLE 角色                -- 删除角色
```

---

## 九、SQL Server安全 ⭐⭐

### 身份验证模式 ⭐

| 模式 | 说明 | 安全性 |
|------|------|--------|
| **Windows验证** | 用Windows账户，系统验证 | 更安全（默认） |
| **混合验证** | Windows + SQL Server账户 | 灵活但需强密码 |

---

### 安全主体三级别 ⭐⭐

1. **服务器级别** - 登录名、固定服务器角色
2. **数据库级别** - 用户、角色、证书等
3. **架构级别** - 表、视图、存储过程等（默认架构dbo）

**验证流程**：登录名登录 → 映射用户 → 检查权限

---

### 登录用户 vs 数据库用户 ⭐⭐

| 概念 | 作用 | 管理者 |
|------|------|--------|
| **登录用户** | 登录SQL Server服务器 | 系统管理员 |
| **数据库用户** | 访问具体数据库 | 数据库管理员 |

**关系**：必须先是登录用户，才能成为数据库用户

**默认登录名**：
- **sa** - 系统管理员，拥有所有权限，不能删除
- **BUILTIN\Administrator** - Windows管理员

---

### SQL Server用户管理

```sql
-- 创建登录名（Windows）
CREATE LOGIN [计算机名\用户] FROM WINDOWS

-- 创建登录名（SQL Server）
CREATE LOGIN 用户 WITH PASSWORD='密码'

-- 创建数据库用户
CREATE USER 用户 FROM LOGIN 登录名 WITH DEFAULT_SCHEMA=dbo

-- 删除
DROP LOGIN 登录名
DROP USER 用户
```

---

### SQL Server角色管理 ⭐⭐

**创建角色**：
```sql
CREATE ROLE 角色名 [AUTHORIZATION 所有者]
```

**用户与角色**：
```sql
SP_ADDROLEMEMBER '角色', '用户'     -- 添加用户到角色
SP_DROPROLEMEMBER '角色', '用户'    -- 从角色删除用户
```

---

### 固定服务器角色 ⭐⭐

| 角色 | 权限 |
|------|------|
| **SYSADMIN** | 系统管理员，**所有权限** |
| SERVERADMIN | 服务器管理员，配置服务器 |
| SECURITYADMIN | 安全管理员，管理登录/密码 |
| DBCREATOR | 数据库创建者，创建/修改数据库 |
| PROCESSADMIN | 进程管理员 |
| DISKADMIN | 磁盘管理员 |
| BULKADMIN | 块数据操作管理员 |

---

### 固定数据库角色 ⭐⭐

| 角色 | 权限 |
|------|------|
| **DB_OWNER** | 数据库所有者，**全部权限** |
| DB_ACCESSADMIN | 访问权限管理员 |
| DB_SECURITYADMIN | 安全管理员 |
| DB_DDLADMIN | DDL管理员 |
| DB_BACKUPOPERATOR | 备份操作员 |
| **DB_DATAREADER** | 可读所有数据 |
| **DB_DATAWRITER** | 可改所有数据 |
| DB_DENYDATAREADER | 拒绝读数据 |
| DB_DENYDATAWRITER | 拒绝写数据 |

---

### PUBLIC角色 ⭐

**特点**：
- 初始状态**无权限**
- **所有数据库用户都是其成员**
- 给PUBLIC授权 = 给所有用户授权

---

### SQL Server权限管理 ⭐⭐⭐

**授予**：
```sql
-- 语句权限
GRANT CREATE DATABASE, CREATE TABLE TO 用户

-- 对象权限
GRANT SELECT, INSERT, UPDATE, DELETE ON 表 TO 用户
GRANT UPDATE(列) ON 表 TO 用户  -- 列级权限

-- 带转授权
GRANT INSERT ON 表 TO 用户 WITH GRANT OPTION
```

**收回**：
```sql
REVOKE INSERT ON 表 FROM 用户

-- 级联收回（自动收回从此用户获得的权限）
```

**禁止**：
```sql
DENY UPDATE, DELETE ON 表 TO 用户

-- DENY优先级最高，即使在有权限的角色中也被禁止
-- 解除禁止需用GRANT显式授权
```

**权限优先级**：**DENY > GRANT > 无权限**

---

## 速记口诀 ⭐⭐⭐

1. **安全模型** = 用户鉴别 → 存取控制 → 视图审计 → OS保护 → 加密
2. **DAC vs MAC** = 自主可控 vs 强制固定
3. **视图** = 先建视图后授权
4. **审计** = 触发器+审计表（谁、何时、改啥）
5. **加密** = 对称一钥匙（DES/AES）、非对称两钥匙（RSA）
6. **MySQL权限表** = user（全局）→ db（库）→ tables（表）→ columns（列）
7. **SQL Server** = 登录名登录 → 用户访问库 → 检查权限
8. **角色** = 权限集合，简化授权
9. **权限三操作** = GRANT授、REVOKE收、DENY禁

---

## 选择题速记 ⭐⭐⭐

### DAC相关
- ✓ 用户可控，用GRANT/REVOKE
- ✓ 查数据字典检查权限
- ✓ 定义权限+检查权限=安全子系统

### MAC相关
- ✓ 系统强制，用户无感
- ✓ 按TDI/TCSEC标准
- ✓ 适用严格密级部门
- ✗ 用户可直接控制（错！）

### 视图相关
- ✓ 视图+授权配合使用
- ✓ 隐藏保密数据
- ✗ 视图单独可实现安全（错！需配合授权）

### 审计相关
- ✓ 审计日志记录所有操作
- ✓ 费时费空间
- ✓ DBA可灵活开关
- ✓ 找出非法存取的人/时间/内容

### 加密相关
- ✓ 对称加密：DES、AES（同一密钥）
- ✓ 非对称加密：RSA（公钥+私钥）
- ✓ 客户端加解密不影响服务器
- ✓ 三层次：OS层/内核层/外层

### MySQL相关
- ✓ IP+用户名联合认证
- ✓ user表=全局权限
- ✓ 权限范围：user > db > tables_priv > columns_priv
- ✓ `'root'@'%'` = 任意主机连接
- ✓ `'root'@'localhost'` = 仅本地连接

### SQL Server相关
- ✓ Windows验证更安全
- ✓ sa=系统管理员，不能删除
- ✓ 登录用户≠数据库用户
- ✓ PUBLIC角色所有用户都是成员
- ✓ DENY优先级最高
- ✓ 权限级联收回
- ✗ 混合模式最安全（错！Windows验证最安全）

---

## 简答题速记 ⭐⭐⭐

### Q1：DAC和MAC的区别？
**DAC（自主）**：
- 用户可控制
- 用GRANT/REVOKE实现
- 灵活，适用一般企业

**MAC（强制）**：
- 系统强制，用户无感
- 按安全标准执行
- 固定密级，适用军事等高密部门

---

### Q2：视图机制如何实现安全？
1. 先建视图屏蔽保密数据
2. 再在视图上定义存取权限
3. 视图+授权配合使用

---

### Q3：审计的作用和实现？
**作用**：
- 跟踪记录数据访问活动
- 找出非法存取的人、时间、内容

**实现**：
- 创建审计日志表
- 用触发器自动记录操作

**注意**：费时费空间，可灵活开关

---

### Q4：对称加密和非对称加密的区别？

| 项目 | 对称加密 | 非对称加密 |
|------|----------|------------|
| 密钥 | 同一密钥 | 公钥+私钥 |
| 算法 | DES、AES | RSA |
| 速度 | 快 | 慢 |
| 安全性 | 密钥易泄露 | 更安全 |

---

### Q5：MySQL权限表的作用和检查顺序？
**4个主要权限表**：
1. user - 全局权限
2. db - 数据库权限
3. tables_priv - 表权限
4. columns_priv - 列权限

**检查顺序**：user → db → tables_priv → columns_priv  
**规则**：全局权限覆盖局部权限

---

### Q6：SQL Server登录用户和数据库用户的关系？
- **登录用户**：登录服务器（服务器级别）
- **数据库用户**：访问具体数据库（数据库级别）
- **关系**：必须先是登录用户，再成为数据库用户
- **映射**：登录名 → 数据库用户

---

### Q7：GRANT、REVOKE、DENY的区别？

| 操作 | 作用 | 优先级 | 特点 |
|------|------|--------|------|
| **GRANT** | 授权 | 中 | 给予权限 |
| **REVOKE** | 收回 | - | 撤销权限，级联收回 |
| **DENY** | 禁止 | **最高** | 明确禁止，需GRANT解除 |

**记忆**：DENY最狠，即使有GRANT也无效

---

## 考前必记 ⭐⭐⭐

### 概念必记
1. **DAC = 自主 = GRANT/REVOKE**
2. **MAC = 强制 = 用户无感 = 高密部门**
3. **视图 = 屏蔽+授权**
4. **审计 = 日志+触发器**
5. **对称(DES/AES) vs 非对称(RSA)**

### MySQL必记
- **user表 = 全局**，**db表 = 数据库级**
- **IP+用户名联合认证**
- **权限检查顺序**：user → db → tables → columns

### SQL Server必记
- **Windows验证 > 混合验证**
- **sa = 系统管理员**
- **登录用户 → 数据库用户**
- **DENY > GRANT > 无权限**
- **PUBLIC角色 = 所有用户**

### 对比必记
- DAC vs MAC
- 对称加密 vs 非对称加密
- 登录用户 vs 数据库用户
- GRANT vs REVOKE vs DENY
- 固定服务器角色 vs 固定数据库角色

---

**考场提醒**：本章选择/简答为主，重概念理解和对比，不考复杂SQL实现！

---

## 【考场精简】第10章_数据库保护

# 【考场速记】第10章 - 数据库保护

> ⭐ 不考大题，主要选择/判断

---

## 一、事务ACID ⭐⭐⭐

- **A 原子性**：全做或全不做
- **C 一致性**：正确状态到正确状态
- **I 隔离性**：并发事务互不干扰
- **D 持续性**：提交后永久保存

**事务状态**：活动 → 部分提交 → 提交（或失败 → 异常结束）

---

## 二、并发5大问题 ⭐⭐⭐

1. **丢失修改** - 两事务同时改，一个覆盖另一个
2. **读脏数据** - 读到未提交的临时数据
3. **不可重复读** - 同一事务两次读同一数据不一致
4. **幻影行** - 同一事务两次查询记录数不同
5. **错误聚集** - 聚集函数计算时数据被修改

---

## 三、锁 ⭐⭐⭐

### 锁类型
- **S锁（共享锁）**：读锁，可多个事务同时持有
- **X锁（互斥锁）**：写锁，独占，不能与任何锁共存

### 三级封锁协议对比 ⭐⭐⭐

| 级别 | 读 | 写 | 防止问题 |
|------|----|----|----------|
| 一级 | 不锁 | X锁到底 | 丢失修改 |
| 二级 | S锁即释 | X锁到底 | 丢失修改 + 读脏数据 |
| 三级 | S锁到底 | X锁到底 | 丢失修改 + 读脏数据 + 不可重复读 |

**记忆口诀**：一级只写锁，二级读后放，三级全到底

---

## 四、死锁 ⭐⭐

### 死锁 vs 活锁
- **活锁**：某事务一直等（解决：先来先服务）
- **死锁**：多个事务互相等待对方的锁（循环等待）

### 死锁解决
- **预防**：一次加锁法、顺序加锁法
- **诊断**：超时法、等待图法（有回路=死锁）
- **解除**：撤销代价最小的事务

---

## 五、两段锁(2PL) ⭐⭐⭐

- **加锁阶段**：只能加锁，不能放锁
- **解锁阶段**：只能放锁，不能加锁

**作用**：保证调度可串行性

**关系**：
- 三级封锁 → 必遵守两段锁 ✓
- 两段锁 → 可能死锁 ✓
- 一次加锁法 → 遵守两段锁 ✓

---

## 六、意向锁 ⭐

- **IS锁**：准备在下层加S锁
- **IX锁**：准备在下层加X锁
- **SIX锁** = S锁 + IX锁

**强度**：X > SIX > S > IX > IS

**规则**：申请自上而下，释放自下而上

---

## 七、恢复技术 ⭐⭐⭐

### 日志格式
- `<T, start>` - 开始
- `<T, X, V1, V2>` - 修改（V1旧，V2新）
- `<T, commit>` - 提交

### 推迟更新 vs 即时更新

| 项目 | 推迟更新 | 即时更新 |
|------|----------|----------|
| 更新时机 | 提交时才更新 | 立即更新数据库 |
| 日志格式 | `<T,X,V2>` | `<T,X,V1,V2>` |
| 恢复操作 | 只需REDO | 需UNDO+REDO |
| 规则 | 有commit→REDO | 有commit→REDO<br>无commit→UNDO |

**REDO**：重做（用新值V2）  
**UNDO**：撤销（用旧值V1）  
**幂等性**：执行多次=执行一次

---

## 八、检测点 ⭐⭐

**作用**：减少恢复时搜索日志的时间

**操作**：
1. 日志写入永恒存储器
2. 修改的数据写入磁盘
3. 写`<checkpoint>`

**优点**：只需处理检测点后的事务

---

## 九、备份类型 ⭐⭐

| 类型 | 内容 | 优点 | 缺点 |
|------|------|------|------|
| **完全备份** | 全部数据 | 恢复简单 | 大、慢 |
| **差异备份** | 自上次完全备份的变化 | 较快 | 需完全+差异 |
| **增量备份** | 自上次任何备份的变化 | 最小最快 | 需完全+所有增量 |
| **日志备份** | 事务日志 | 恢复到时间点 | 配合其他使用 |

---

## 十、SQL Server备份/恢复 ⭐

### 备份
```sql
-- 完全
BACKUP DATABASE db TO DISK='path'

-- 差异
BACKUP DATABASE db TO DISK='path' WITH DIFFERENTIAL

-- 日志
BACKUP LOG db TO DISK='path'
```

### 恢复（按顺序）
```sql
-- 1.完全（不恢复）
RESTORE DATABASE db FROM DISK='path' WITH NORECOVERY

-- 2.差异（不恢复）
RESTORE DATABASE db FROM DISK='path' WITH NORECOVERY

-- 3.日志（恢复+时间点）
RESTORE LOG db FROM DISK='path' WITH RECOVERY, STOPAT='time'
```

**关键**：前面用`NORECOVERY`，最后一步用`RECOVERY`

---

## 速记口诀 ⭐⭐⭐

1. **ACID** = 原一隔持
2. **并发5问题** = 丢读脏、不重复、幻影行、聚集错
3. **三级封锁** = 一X二S放三S底
4. **两段锁** = 先加后放、保串行
5. **死锁** = 预（一次/顺序）诊（超时/图）解（撤小）
6. **恢复** = 推迟REDO、即时UNDO+REDO
7. **备份** = 完全最大、增量最小、差异居中
8. **恢复顺序** = 完全→差异→日志（按时间）

---

## 判断速记 ⭐

✓ 三级封锁→两段锁  
✓ 两段锁→可能死锁  
✓ 锁粒度小→并发大  
✓ 推迟更新只记V2  
✓ 即时更新记V1+V2  
✗ 一级防读脏（需二级）  
✗ 二级防不可重复读（需三级）  
✗ 一次加锁会死锁（不会）

---

**考前必记**：ACID、三级封锁对比表、REDO/UNDO区别、备份恢复顺序！
