# 数据库第5章 - 触发器

> 整理自数据库期末复习PPT

---

## 5  触发器 .pptx


### 幻灯片 1

数据库原理


### 幻灯片 2

第五章    触发器和数据库完整性

	5.1 触发器        
        5.2 数据库的完整性


### 幻灯片 3

5.1 触发器
5.1.1 触发器的基本概念
用户定义在关系表上的一类由事件驱动的特殊过程，是一种保证数据完整性的方法,也可看作是一类特殊的存储过程，一旦定义，无须用户调用，任何对表的修改操作均由服务器自动激活相应的触发器。
     
主要作用：实现主键和外键所不能保证的复杂的参照完整性和数据一致性。除此之外还有以下几个功能：
1．强化约束
2．跟踪变化
3．级联运行
4．存储过程的调用


### 幻灯片 4

5.1 触发器
5.1.2 创建MySQL触发器
触发器是指对某一个表执行某种数据操作时（INSERT、UPDATE、DELETE等）自动完成的一段程序，用以完成这些操作在引起数据变化后的完善工作。
NEW表：对于INSERT操作来说，NEW表里存放的是将要（BEFORE）或已经（AFTER）插入的新数据；而对于UPDATE操作来说，NEW表里存放的是将要或已经更新的新数据（即更新后的新值）。
OLD表：对于DELETE操作来说，OLD表里存放的是将要或已经被删除的数据；而对于UPDATE操作来说，OLD表里存放的将要或已经更新前的原数据。
两个特殊的表:  触发器的实现离不开两张特定的表
使用方法： NEW.columnName （columnName 为相应数据表某一列名）
注意：OLD 表是只读的，而 NEW表则可以在触发器中使用 SET 赋值。
1．MySQL触发器的工作原理


### 幻灯片 5

5.1 触发器
5.1.2 创建MySQL触发器
定义触发器的语句：
CREATE TRIGGER <触发器名>
   BEFORE | AFTER 
   INSERT | UPDATE | DELETE 
   ON  表名   FOR EACH ROW
　SQL语句
注：不能同时在一个表上建立2个相同类型的触发器。
触发器名称
触发器所依存的表
标识触发时机，表示触发器是在激活它的语句之前或之后触发
触发器所要执行的一组SQL语句
标识触发事件
表示任何一条记录上的操作满足触发事件都会触发该触发器


### 幻灯片 6

5.1 触发器
5.1.2 创建MySQL触发器
2．INSERT事件触发器
每次向基本表插入数据时触发执行，该数据被复制到NEW表中。
可用来检验要输入的数据是否符合规则、在插入的数据中增加数据、级联改变数据库中其他的数据表。
【例5.1】创建一个INSERT事件触发器，在对表stock插入一条物资记录前，对新插入的amount字段值进行求和计算。
DELIMITER &&
CREATE TRIGGER tr1_stock 
BEFORE INSERT
ON stock FOR EACH ROW
  SET @sum=@sum+NEW.amount;
若在stock表中执行如下插入语句，则触发该触发器：
set @sum=0; 
insert into stock(mat_num,mat_name,speci,warehouse,amount,unit) 
values('m030','护套绝缘电线','BVV-120','供电局1#仓库',10,100),
          ('m031','护套绝缘电线','BVV-150','供电局1#仓库',20,100);
select @sum;


### 幻灯片 7

5.1 触发器
5.1.2 创建MySQL触发器
【例5.2】创建一个INSERT事件触发器，在对表salvaging插入一条抢修项目前，如果项目开始日期和项目结束日期相同，则将项目结束日期设为开始日期三天后。
DELIMITER &&
CREATE TRIGGER tr1_salvaging 
BEFORE INSERT
ON salvaging FOR EACH ROW
BEGIN
  if(NEW.end_date=NEW.start_date) then
    set NEW.end_date=ADDDATE(NEW.start_date,3);
  end if;
END;
若在stock表中执行如下插入语句：
insert into salvaging
values('20190001','抢修项目1','2019-6-1','2019-6-1',0),
      ('20190002','抢修项目2','2019-6-1','2019-6-2',0);


### 幻灯片 8

5.1 触发器
5.1.2 创建MySQL触发器
【例5.3】创建一个INSERT事件触发器，在对表Out_stock插入一条记录后，更改对应物资在Stock表中的库存数量，完成级联更改操作。
DELIMITER &&
CREATE TRIGGER tr1_outstock 
AFTER INSERT
ON out_stock FOR EACH ROW
BEGIN
   declare m_amout int(11);
   select amount INTO m_amout
   from out_stock
   where prj_num=NEW.prj_num and mat_num=NEW.mat_num;    
   update stock
   set amount=amount-m_amout
   where mat_num=NEW.mat_num;        
END


### 幻灯片 9

5.1 触发器
5.1.2 创建MySQL触发器
若在Out_stock表中执行如下插入语句，则Stock表中对应字段前后对比如下图所示。
insert 
into Out_stock    
values('20110006','m003',10,'2011-3-8','工程1部')
（a）执行插入语句之前的stock表                （b）执行插入语句之后的stock表


### 幻灯片 10

5.1 触发器
5.1.2 创建MySQL触发器
3．DELETE事件触发器
从基本表中删除数据时触发执行，在用户执行了DELETE触发器后，将删除的数据行保存在OLD表中，即数据行并没有消失，还可在SQL语句中引用。
主要用于：防止删除数据库中的某些数据行、级联删除数据库中其他表中的数据行。
【例5.4】创建一个DELETE触发器，当用户从stock表中删除数据时，同时将out_stock 
表中相关物资的出库情况一并删除。
DELIMITER &&
CREATE TRIGGER tr2_stock 
AFTER DELETE
ON stock FOR EACH ROW
BEGIN
   delete 
   from out_stock
   where mat_num=OLD.mat_num;       
END
注意：使用触发器作级联删除,前提是Out_stock表没有定义和Stock表相关的外键。


### 幻灯片 11

5.1 触发器
5.1.2 创建MySQL触发器
4．UPDATE 事件触发器
UPDATE触发器在用户发出UPDATE语句后触发执行，即为用户修改数据行增加限制规则。
UPDATE触发器合并了DELETE触发器和INSERT触发器的作用。
在用户执行了UPDATE语句后，原来的数据行从基本表中删除，但保存在OLD表中，同时基本表更新后的新数据行也在NEW表中保存了一个副本。
可利用OLD表和NEW表获取更新前后的数据行，完成比较操作。


### 幻灯片 12

5.1 触发器
5.1.2 创建MySQL触发器
【例5.5】定义一个数据表modify_amount，用于存储领料出库表out_stock中领取数量发生变化的情况。
表Modify_amount的创建语句如下：
CREATE TABLE modify_amount
(  prj_num     char(8),        /*被修改的工程项目号*/
   mat_num     char(8),        /*被修改的抢修物资号*/
   username   char(6) ,        /*修改人*/
   updatetime datetime,       /*修改时间*/
   amount_old   int,           /*修改前的领取数量*/
   amount_new  int             /*修改后的领取数量*/
);


### 幻灯片 13

5.1 触发器
5.1.2 创建MySQL触发器
DELIMITER &&
CREATE TRIGGER tr2_outstock 
AFTER UPDATE
ON out_stock FOR EACH ROW
BEGIN
   insert 
   into modify_amount
  values(OLD.prj_num,OLD.mat_num,USER(),NOW(),OLD.amount,NEW.amount);
END
UPDATE Out_stock
SET amount=8
WHERE prj_num='20110005' and mat_num='m006'


### 幻灯片 14

5.1 触发器
5.1.3 创建SQL Server触发器
定义触发器的语句：
CREATE TRIGGER <触发器名>
ON  { 表名 | 视图名 }
[ WITH ENCRYPTION ] 
{AFTER|INSTEAD OF}{[INSERT][,][UPDATE][,][DELETE]}
[ NOT FOR REPLICATION ]
AS [ SQL 语句 ]
注：一 个触发器只能应用在一个表上，但一个触发器可以包含很多动作，执行很多功能，触发器可以建立在基本表上，也可以建立在视图上。
触发器名称
触发器所依存的表
激活触发器的触发条件
触发器所要执行的一组SQL语句，可以包含流程控制语句


### 幻灯片 15

5.1 触发器
5.1.3 创建SQL Server触发器
After触发器：表示触发器在SQL语句中指定操作成功执行后才激活。
Instead Of触发器：表示在表或视图上执行增、删、改操作时，用该触发器中的SQL语句代替原语句。
INSERTED表：对于INSERT操作来说，INSERTED表里存放的是要插入的数据；对于UPDATE操作来说，INSERTED表里存放的是要更新的记录（即更新后的值）。

DELETED表：对于DELETE操作来说，DELETED表里存放的是被删除的记录；而对于UPDATE操作来说，DELETED表里存放的是更新前的记录（更新完毕后即被删除）。
两个特殊的表:  触发器的实现离不开两张特定的表


### 幻灯片 16

5.1触发器
5.1.3 创建SQL Server触发器
1. AFTER INSERT 触发器
该触发器在每次往基本表中插入数据时触发执行，该数据同时复制到基本表和内存中的INSERTED表中。
 INSERT触发器主要有三个作用：检验要输入的数据是否符合规则、在插入的数据中增加数据、级联改变数据库中其他的数据表。
INSERTED表用于存储INSERT和UPDATE语句所影响的行的复本，执行INSERT和UPDATE语句时，新的数据行被添加到基本表中，同时这些数据行的备份被复制到INSERTED临时表中。


### 幻灯片 17

5.1 触发器
5.1.3 创建SQL Server触发器
【例4.12】创建一个INSERT触发器，在对表Stock进行插入后验证库存量的大小，若库存量小于1，则撤销该插入操作。
CREATE TRIGGER tr1_stock
   ON Stock
   AFTER INSERT
AS  
  declare @amount int
  select @amount=amount   from INSERTED

  if @amount<1
  BEGIN 
    ROLLBACK TRAN
    RAISERROR('Amount must be greater than 1!',16,10)
 END


### 幻灯片 18

5.1触发器
5.1.3 创建SQL Server触发器
触发该触发器的语句：
INSERT  
      INTO stock(mat_num,mat_name,speci,warehouse, amount, unit) 
  VALUES('m030','护套绝缘电线','BVV-120','供电局1#仓库',2,100)
由于库存量>=1符合规则，可以正常插入执行。

INSERT  
      INTO stock(mat_num,mat_name,speci,warehouse, amount,unit) 
  VALUES('m031','护套绝缘电线','BVV-120','供电局1#仓库',0,100)
 由于库存量<1不符合规则，将撤销表的插入操作：


### 幻灯片 19

5.1 触发器
5.1.3 创建SQL Server触发器
【例4.13 】创建一个INSERT触发器，在对表Out_stock插入一条记录后，更改对应物资在Stock表中的库存数量，完成级联更改操作。
CREATE TRIGGER tr1_outstock 
ON Out_stock
AFTER INSERT
AS  
BEGIN
   declare @m_num char(8), @m_amount  int
   select @m_num=mat_num,@m_amount=amount 
   from INSERTED 
   update Stock  set amount=amount-@m_amount
   where mat_num=@m_num           
END


### 幻灯片 20

5.1 触发器
5.1.3 创建SQL Server触发器
若在Out_stock表中执行如下插入语句，则Stock表中对应字段前后对比如下图所示。
insert 
into Out_stock    
values('20110006','m001',10,'2011-3-8','工程1部')
（a）执行插入语句之前的stock表       （b）执行插入语句之后的stock表


### 幻灯片 21

5.1 触发器
5.1.3 创建SQL Server触发器
2. AFTER DELETE 触发器
该触发器在从基本表中删除数据时触发执行，在用户执行了DELETE触发器后，SQL Server将删除的数据行保存在DELETED表中，即数据行并没有消失，还可在SQL语句中引用。
DELETE触发器主要用于以下两种情况：防止删除数据库中的某些数据行；级联删除数据库中其他表中的数据行。
DELETED表用于存储DELETE和UPDATE语句所影响的行的复本。在执行DELETE或UPDATE语句时，行从触发器表中删除，并传输到DELETED表中，DELETED表和原数据表通常没有相同的行。


### 幻灯片 22

5.1 触发器
5.1.3 创建SQL Server触发器
【例4.14】创建一个DELETE触发器，当用户从Stock表中删除数据时，同时将Out_stock表中相关物资的出库情况一并删除。
CREATE TRIGGER tr2_stock
   ON Stock
   AFTER DELETE
AS 
  BEGIN TRANSACTION 
     DECLARE @mat_num char(8)
     SELECT @mat_num=mat_num   FROM DELETED
     DELETE   
     FROM Out_stock   
     WHERE mat_num=@mat_num
  COMMIT TRANSACTION
注意：使用触发器作级联删除,前提是Out_stock表没有定义和Stock表相关的外键。


### 幻灯片 23

5.1 触发器
5.1.3 创建SQL Server触发器
3. AFTER UPDATE 触发器
该触发器在用户发出UPDATE语句后触发执行，即为用户修改数据行增加限制规则。
UPDATE触发器合并了DELETE触发器和INSERT触发器的作用。
在用户执行了UPDATE语句后，原来的数据行从基本表中删除，但保存在DELETED表中，同时基本表更新后的新数据行也在INSERTED表中保存了一个副本。可利用DELETED表和INSERTED表，获取更新前后的数据行，完成比较操作。


### 幻灯片 24

5.1 触发器
5.1.3 创建SQL Server触发器
【例4.15】创建一个UPDATE触发器，当用户更新stock表中的数据时，从INSERTED表中读取修改的新的amount值，如果该值小于1，将撤销更新操作，即触发器从DELETED 表中查询中修改前的值，将其重新更新到stock表中。
CREATE TRIGGER tr3_stock
   ON Stock
   AFTER UPDATE
AS 
  DECLARE @amount_new int,@amount_old int,
                    @mat_num char(10)
  SELECT @amount_new=amount, @mat_num=mat_num
  FROM INSERTED
  IF @amount_new<1
   BEGIN 
        SELECT @amount_old=amount   FROM DELETED   
        UPDATE Stock      
        SET amount=@amount_old
        WHERE mat_num=@mat_num        
        PRINT 'the row can not be UPDATED!'
  END
ROLLBACK TRAN


### 幻灯片 25

5.1 触发器
5.1.3 创建SQL Server触发器
【例4.16】修改前面创建的UPDATE触发器，使其先检测更新的列，当更新warehouse列时，禁止更新；当更新库存量amount列时，设置更新规则，若更新后的值小于1，则撤销该更新操作。
CREATE TRIGGER tr4_stock  
ON Stock   
AFTER UPDATE
AS 
  DECLARE @amount int
  IF UPDATE(warehouse)
   BEGIN 
      ROLLBACK TRAN
      PRINT '不允许修改物资存放仓库！'   
   END
 else  IF UPDATE(amount)
   BEGIN 
       SELECT @amount=amount  FROM INSERTED
       IF @amount<1
       BEGIN 
          ROLLBACK TRAN
          PRINT  '库存量小于1，不允许更新！'
       END
   END
注意：UPDATE函数可以检测到一个列的更新。


### 幻灯片 26

5.1 触发器
5.1.3 创建SQL Server触发器
【例4.17】定义一个数据表Modify_amount，用于存储领料出库表Out_stock中领取数量发生变化的情况。
表Modify_amount的创建语句如下：
CREATE TABLE Modify_amount
(  prj_num     char(8),        /*被修改的工程项目号*/
   mat_num     char(8),        /*被修改的抢修物资号*/
   username   char(6) ,        /*修改人*/
   updatetime datetime,       /*修改时间*/
   amount_old   int,           /*修改前的领取数量*/
   amount_new  int             /*修改后的领取数量*/
);


### 幻灯片 27

5.1 触发器
5.1.3 创建SQL Server触发器
CREATE TRIGGER  tr2_outstock  
on Out_stock
AFTER UPDATE
As  
If update(amount)
Begin
   declare @amount_old int,@amount_new  int
   declare @prj_no char(8),@mat_no char(8)
   select @prj_no=(select prj_num from DELETED)       --被修改的项目号
   select @mat_no=(select mat_num from DELETED)       --被修改的物资号
   select @amount_old=(select amount from DELETED) --修改前的领取数量             
   select @amount_new=(select amount from INSERTED) --修改后的领取数量
   insert 
   into Modify_amount
   values(@prj_no,@mat_no,USER_NAME(),GETDATE(),@amount_old,  @amount_new)
End
UPDATE Out_stock
    SET amount=8
    WHERE prj_num='20110005' and mat_num='m006'


### 幻灯片 28

5.1 触发器
5.1.3 创建SQL Server触发器
4. INSTEAD OF 触发器
INSTEAD OF触发器为替代操作触发器，用于视图操作。因为视图有时显示的是表中的部分列，因此用视图修改基本表中的数据行时有可能导致失败。解决方法之一就是针对视图建立INSTEAD OF触发器，通过触发器插入所缺的列值，完成更新。
当视图执行到对基本表的插入、删除和更新操作时，用触发器的操作替代视图的操作。
注意：视图只能使用INSTEAD OF触发器，而不能使用AFTER触发器。


### 幻灯片 29

5.1 触发器
5.1.3 创建SQL Server触发器
【例4.18】对Out_stock表创建一个INSTEAD OF触发器，确保插入的抢修工程项目号在Salvaging表中存在。
CREATE TRIGGER  tr3_outstock  
on Out_stock
INSTEAD OF INSERT
AS
  if exists( select * from INSERTED 
                where prj_num not in (select prj_num from salvaging))
     print  '对不起，有抢修工程项目号不在工程项目表中，不能正确插入！' 
  else
    insert into Out_stock
       select * from INSERTED
INSERT 
INTO out_stock
VALUES ('20110006','m001',2,'2011-3-9','工程4部'),
               ('20110007','m002',3,'2011-3-9','工程4部');


### 幻灯片 30

5.1 触发器
5.1.3 创建SQL Server触发器
【例4.19】创建一个INSTEAD OF触发器，在视图往基本表中插入数据行时，补充speci 的列值。
首先生成基于stock表的视图view_stock，代码如下：
CREATE VIEW view_stock
AS
 SELECT mat_num,mat_name,warehouse,amount,unit
 FROM stock
若通过下面的语句向基本表中插入数据:
INSERT INTO view_stock
VALUES(‘m100’,'护套绝缘电线',’ 供电局1#仓库',10,110)
由于视图中不包括speci列，而基本表中speci列不能为空，则该语句会出错。


### 幻灯片 31

5.1 触发器
5.1.3 创建SQL Server触发器
解决办法： 创建一个INSTEAD OF触发器，在通过视图往基本表中插入数据时，补充speci列的值。
CREATE TRIGGER tr_viewstock     
 ON view_stock    INSTEAD OF INSERT  
AS   
  DECLARE   @mat_num char(10),@mat_name   char(50),@speci char(50),   
                   @warehouse char(50), @amount int,  @unit decimal(18,2)
  SELECT     @mat_num=mat_num,@mat_name=mat_name,
   	        @warehouse=warehouse,@amount=amount,@unit=unit
  FROM INSERTED
  SET  @speci=‘未知'
  INSERT   INTO stock(mat_num,mat_name,speci,warehouse,amount,unit)     
  VALUES(@mat_num,@mat_name,@speci,@warehouse,@amount,@unit)


### 幻灯片 32

5.1 触发器
5.1.3 创建SQL Server触发器
5. 复合触发器
多个触发器可以组合在一起形成复合触发器。
【例4.20】创建一个复合触发器，不允许修改或删除存储在供电局1#仓库的物资信息。
CREATE TRIGGER tr6_stock      
 ON stock
 AFTERT DELETE,UPDATE 
AS   
  DECLARE @warehouse char(50)
  SELECT @warehouse=warehouse    FROM  DELETED
  IF @warehouse= '供电局1#仓库'
   BEGIN 
      ROLLBACK TRAN
      PRINT '不允许修改或删除供电局1#仓库的物资信息！'
   END


### 幻灯片 33

5.1 触发器
5.1.3 创建SQL Server触发器
只有数据库所有者才能修改触发器，修改触发器的语句是：
ALTER TRIGGER <触发器名>
ON  { 表名 | 视图名 }
[ WITH ENCRYPTION ] 
{AFTER | INSTEAD OF } { [ INSERT ] [ , ] [ UPDATE ] [ , ] [ DELETE ] }
[ NOT FOR REPLICATION ]
AS      [ SQL 语句 ] 

删除触发器的语句是：
DROP TRIGGER   触发器名
注意：在删除表时，依存于该表的触发器也将同时被删除。


### 幻灯片 34

数据库的完整性是数据的正确性和相容性。
为了维护数据库的完整性，DBMS必须提供一种机制来检查数据库的完整性。现代数据库技术采用对数据完整性予以约束和检查的方式来保护数据库的完整性。
事实上，除了实体完整性约束和参照完整性约束，其他与数据完整性有关的内容都是用户定义的数据完整性范畴。 
实现用户定义的完整性规则，除了CreateTable命令中的Check约束，更多的是使用触发器来实现灵活、复杂的数据完整性要求。
5.2 数据库完整性


### 幻灯片 35

在电力抢修工程数据库中:
Salvaging（prj_num, prj_name, start_date, end_date, prj_status）
Out_stock（prj_num, mat_num, amount, get_date, department）
Stock（mat_num, mat_name, speci, warehouse, amount, unit, total）
        Out_stock表中的prj_num属性是外键，参照Salvaging表中prj_num属性，并且要求对于某一项抢修工程，其Out_stock表中的领料日期get_date的值必须介于Salvaging 表中该工程的start_date和end_date值之间。
        例如:prj_num为20110006的抢修工程的开始日期为2011-03-08，结束日期为2011-03-10，则out_stock表中prj_num为20110006的记录的get_date值必须介于2011-03-08和2011-03-10之间。
5.2 数据库完整性


### 幻灯片 36

CREATE TRIGGER tr3_outstock 
BEFORE INSERT
ON out_stock FOR EACH ROW
BEGIN
  declare s_date datetime;
  declare e_date datetime; 
  DECLARE msg varchar(50);  
  select start_date,end_date into s_date,e_date
  from salvaging
  where prj_num=NEW.prj_num;
  if(NEW.get_date<s_date)or(NEW.get_date>e_date) then
   set msg=CONCAT(NEW.prj_num,'项目领取的',NEW.mat_num,'物资领料日期有误！');
   signal sqlstate 'HY000' set message_text=msg;
  end if;
END
insert into out_stock
values('20110006','m005',10,'2019-6-8','工程1部');
5.2 数据库完整性


### 幻灯片 37

小结
触发器的基本概念
创建触发器
修改和删除触发器
谢谢观看！

---

