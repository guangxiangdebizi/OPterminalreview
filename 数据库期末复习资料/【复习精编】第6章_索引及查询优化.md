# 【复习精编】第6章 - 索引及查询优化

> 数据库期末复习 - 核心知识点整理

---

## 一、索引基础

### 1.1 索引的概念

**目的**：加快查询速度，提高数据文件访问效率

**优点**：
- 显著提高查询性能
- 加快数据检索速度

**缺点**（代价）：
- **时间代价**：对数据进行插入、更新、删除操作所花费的时间会更长
- **空间代价**：索引需要占用存储空间

**设计原则**：
- 确保对性能的提高程度大于在存储空间和处理资源方面的代价
- 不是所有情况都适合创建索引

### 1.2 堆集（Heap）
- 如果一个表没有创建索引，则数据行不按任何特定的顺序存储
- 这种无序存储结构称为堆集

---

## 二、索引类型

### 2.1 聚集索引（Clustered Index）

#### 定义
数据文件中的记录按照索引键指定的顺序排序，使得具有相同索引键值的记录在物理上聚集在一起

#### 关键特点
- ✅ **唯一性**：一个表只能建立一个聚集索引
- ✅ **物理排序**：数据行按索引键顺序物理存储
- ✅ **叶节点存储**：数据记录都存放在叶子节点中
- ✅ **链式结构**：所有叶子节点之间形成链式结构

#### 结构（B+树）
```
根节点（Root）
    ↓
中间节点（Intermediate）
    ↓
叶节点（Leaf）- 存储实际数据记录
    ↓
形成双向链表
```

**B+树特点**：
- 非叶子节点只存储键值信息
- 数据记录都存放在叶子节点中
- 所有叶子节点之间形成链式结构（双向链表）

#### 适用场景
✅ **适合**：
- 大量非重复值的列
- 经常被连续访问的列（范围查询）
- 经常使用JOIN或GROUP BY子句的列

❌ **不适合**：
- 频繁更改的列（因为会引起物理重排）

### 2.2 非聚集索引（Non-Clustered Index）

#### 定义
索引与数据行的存放顺序无关，索引作为表的附加信息

#### 关键特点
- ✅ **多个索引**：一个表可以建立多个非聚集索引
- ✅ **逻辑排序**：索引有序，但数据行物理存储无序
- ✅ **叶节点指针**：叶层是索引行（不包含数据页），包含指向数据行的指针

#### 与聚集索引的区别
1. 数据行不按非聚集索引键的顺序排序和存储
2. 非聚集索引的叶层不包含数据页，只包含指向数据的指针

#### 特性
- 有利于单行查询
- 不利于范围查询

### 2.3 其他非聚集索引类型

#### 唯一索引（Unique Index）
- 索引列的值必须唯一
- 允许有空值，但至多只能有一个空值
- 如果是组合索引，则列值的组合必须唯一

#### 单值索引（Single-Column Index）
- 最基本的非聚集索引
- 没有任何限制
- 建议选择区分度高的列作为索引（如姓名，而不是性别）

#### 组合索引（Composite Index）
- 一个索引包含多个列
- 用于多列组合查询

#### 全文索引（Fulltext Index）
- 主要用于对文本数据进行全文搜索
- 可以快速定位到包含特定单词或短语的文本数据
- 适用场景：新闻文章、博客内容等大量文本数据

---

## 三、MySQL索引结构

### 3.1 InnoDB存储引擎

#### 索引类型
**B+树索引**

#### 特点
1. **聚集索引（Clustered Index）**：
   - InnoDB将表数据和主键索引存储在一起
   - 主键索引就是表的聚集索引
   - 表数据按照主键的顺序存储
   - 主键索引的叶子节点直接存储了表的行数据

2. **辅助索引（Secondary Index）**：
   - 除了主键索引之外的其他索引
   - 也是B+树结构
   - 叶子节点存储的是主键值（不是行数据的直接指针）
   - 查找流程：先找到主键值 → 再通过主键值查找聚集索引 → 获取完整行数据

#### 适用场景
- ✅ 范围查询（BETWEEN、>、<）
- ✅ 排序操作（ORDER BY）
- ✅ 主键等值查询（=）
- 原因：叶子节点之间通过链表连接，可以高效地进行顺序扫描

### 3.2 MyISAM存储引擎

#### 索引类型
**B-树索引**（注意：不是B+树）

#### 特点
- 数据可以存储在内部节点和叶子节点中
- 表数据和索引分开存储：
  - 索引文件存储索引信息
  - 数据文件存储实际的表数据
- 索引文件中的叶子节点存储的是指向数据文件中数据行的指针

#### 适用场景
- ✅ 等值查询（=）
- ❌ 范围查询和排序操作不如B+树高效
- 适用于读多写少的场景（如日志表、统计表）
- 不支持事务和行级锁

### 3.3 MEMORY存储引擎
- 默认使用哈希索引
- 也可以显式创建B-树索引

---

## 四、索引操作

### 4.1 创建索引

#### 方法1：创建表时创建索引
```sql
CREATE TABLE table_name (
    column1 datatype,
    column2 datatype,
    ...
    [UNIQUE] INDEX index_name (column1 [ASC|DESC], ...)
);
```

#### 方法2：为已存在的表添加索引
```sql
ALTER TABLE table_name 
ADD [UNIQUE] INDEX index_name (column1 [ASC|DESC], ...);
```

#### 方法3：使用CREATE INDEX语句
```sql
CREATE [UNIQUE] INDEX index_name 
ON table_name (column1 [ASC|DESC], ...);
```

#### 方法4：创建全文索引
```sql
-- 创建表时
CREATE TABLE table_name (
    column1 datatype,
    column2 datatype,
    ...
    FULLTEXT INDEX index_name (column_name)
);

-- 为已存在的表添加
ALTER TABLE table_name 
ADD FULLTEXT INDEX index_name (column_name);

-- 使用CREATE语句
CREATE FULLTEXT INDEX index_name 
ON table_name (column_name);
```

### 4.2 创建索引示例

**示例1：单列索引**
```sql
CREATE INDEX Index_mat_name 
ON Stock(mat_name DESC);
```

**示例2：组合索引**
```sql
CREATE INDEX Index_name_spec 
ON Salvaging(prj_name, spec);
```

---

## 五、何时创建索引

### 5.1 推荐创建索引的场景

✅ **1. 精确匹配查询**
- WHERE子句中指定特定值
- 例如：`WHERE mat_no='m01'`

✅ **2. 范围查询**
- 查询某一范围内的值
- 例如：`WHERE amount BETWEEN 200 AND 300`

✅ **3. JOIN连接查询**
- 在连接谓词中使用的列
- 搜索与另一个表匹配的行

✅ **4. 排序操作**
- ORDER BY子句中的列
- 可以避免显式排序操作

✅ **5. LIKE模式匹配（特定条件）**
- 模式以特定字符串开头
- 例如：`LIKE 'abc%'`（✅索引有效）
- 注意：`LIKE '%abc%'`（❌索引无效）

✅ **6. 外键约束的列**
- 定义了Foreign Key约束的两个表之间匹配的行

### 5.2 验证索引是否生效

使用`EXPLAIN`命令查看执行计划：

```sql
-- 示例1：范围查询（索引有效）
EXPLAIN SELECT * FROM stock 
WHERE mat_num>='m001' AND mat_num<='m003';

-- 示例2：前缀匹配（索引有效）
EXPLAIN SELECT * FROM stock 
WHERE mat_name LIKE '绝缘%';

-- 示例3：模糊匹配（索引无效）
EXPLAIN SELECT * FROM stock 
WHERE mat_name LIKE '%绝缘%';
```

---

## 六、查询优化技巧

### 6.1 数据库设计方面

#### 1. 建立合适的索引
✅ **原则**：
- 在WHERE及ORDER BY涉及的列上建立索引
- 避免全表扫描

#### 2. 避免NULL值判断
❌ **错误**：
```sql
SELECT id FROM t WHERE num IS NULL
```

✅ **正确**：
```sql
-- 在num上设置默认值0，确保没有NULL值
SELECT id FROM t WHERE num=0
```

#### 3. 合理使用索引
⚠️ **注意**：
- 并不是所有索引对查询都有效
- 当索引列有大量数据重复时，查询可能不会使用索引
- 索引不是越多越好：
  - 提高SELECT效率
  - 降低INSERT和UPDATE效率

#### 4. 避免更新聚集索引列
- 更新聚集索引列会导致数据行物理位置的改变
- 代价非常高

#### 5. 数据类型选择
✅ **优先使用数字型字段**：
- 引擎处理数字型只需比较一次
- 字符串需要逐个字符比较

✅ **使用变长字段**：
- 尽可能使用VARCHAR/NVARCHAR代替CHAR/NCHAR
- 节省存储空间

### 6.2 SQL语句方面

#### 1. 避免使用!=或<>操作符
❌ **会导致全表扫描**：
```sql
SELECT * FROM t WHERE num != 10
SELECT * FROM t WHERE num <> 10
```

#### 2. 慎用OR连接条件
❌ **会导致全表扫描**：
```sql
SELECT prj_num FROM out_stock 
WHERE mat_num='m001' OR mat_num='m002';
```

✅ **使用UNION ALL替代**：
```sql
SELECT prj_num FROM out_stock WHERE mat_num='m001' 
UNION ALL 
SELECT prj_num FROM out_stock WHERE mat_num='m002';
```

#### 3. 慎用IN和NOT IN
❌ **可能导致全表扫描**：
```sql
SELECT id FROM t WHERE num IN(1,2,3)
```

✅ **对于连续数值，使用BETWEEN**：
```sql
SELECT id FROM t WHERE num BETWEEN 1 AND 3
```

#### 4. 避免在索引字段上进行表达式操作
❌ **会导致全表扫描**：
```sql
SELECT id FROM t WHERE num/2=100
SELECT id FROM t WHERE name LIKE '%abc%'
```

✅ **正确写法**：
```sql
SELECT id FROM t WHERE num=200
SELECT id FROM t WHERE name LIKE 'abc%'
```

#### 5. 避免在WHERE子句中对字段进行函数操作
❌ **会导致全表扫描**：
```sql
SELECT id FROM t WHERE SUBSTRING(name,1,3)='abc'
SELECT id FROM t WHERE DATEDIFF(day,createdate,'2005-11-30')=0
```

✅ **正确写法**：
```sql
SELECT id FROM t WHERE name LIKE 'abc%'
SELECT id FROM t 
WHERE createdate>='2005-11-30' 
  AND createdate<'2005-12-1'
```

#### 6. 用EXISTS代替IN
✅ **EXISTS通常性能更好**：
```sql
-- 使用IN（性能较差）
SELECT num FROM a WHERE num IN(SELECT num FROM b)

-- 使用EXISTS（性能较好）
SELECT num FROM a 
WHERE EXISTS(SELECT 1 FROM b WHERE num=a.num)
```

#### 7. 不要使用SELECT *
❌ **错误**：
```sql
SELECT * FROM t
```

✅ **正确**：
```sql
SELECT id, name, age FROM t
```
- 用具体的字段列表代替"*"
- 不要返回用不到的字段

#### 8. 用DISTINCT代替GROUP BY
当只需要去重时：

❌ **效率较低**：
```sql
SELECT prj_num FROM out_stock GROUP BY prj_num
```

✅ **效率较高**：
```sql
SELECT DISTINCT prj_num FROM out_stock
```

#### 9. JOIN字段建立索引
- 如果应用程序有很多JOIN查询
- 确认两个表中Join的字段都建过索引

#### 10. 避免在ORDER BY中使用非索引项或表达式
- 任何在ORDER BY语句的非索引项都将降低查询速度
- 任何有计算表达式都将降低查询速度

#### 11. 其他优化建议
- ❌ 尽量避免使用游标（效率较差）
- ⚠️ 尽量避免向客户端返回大数据量
- ⚠️ 尽量避免大事务操作，提高系统并发能力

### 6.3 优化数据库

1. **硬件调整性能**：
   - 升级CPU、内存、磁盘

2. **调整数据库配置**：
   - 缓冲池大小
   - 连接数
   - 其他参数

3. **使用存储过程**：
   - 预编译，执行效率高
   - 减少网络传输

4. **应用程序结构和算法**：
   - 优化业务逻辑
   - 减少数据库访问次数

---

## 七、考试重点总结

### 7.1 核心概念（必考）
1. ✅ 索引的定义、优缺点
2. ✅ 聚集索引和非聚集索引的区别
3. ✅ 一个表只能有一个聚集索引，但可以有多个非聚集索引
4. ✅ B+树和B-树的区别
5. ✅ InnoDB和MyISAM的索引结构差异
6. ✅ 何时应该创建索引，何时不应该创建

### 7.2 常考题型

#### 概念题
1. 什么是聚集索引？什么是非聚集索引？
2. 聚集索引和非聚集索引有什么区别？
3. 一个表可以有多少个聚集索引？多少个非聚集索引？
4. InnoDB的辅助索引和MyISAM的索引有什么区别？
5. 什么情况下应该创建索引？

#### 选择题
1. 以下哪种情况适合创建聚集索引？
2. 以下哪种查询可以有效使用索引？
3. InnoDB使用什么数据结构实现索引？

#### 应用题
1. 为指定的表创建合适的索引
2. 分析给定的SQL语句，指出哪些可以优化
3. 解释为什么某个查询没有使用索引

### 7.3 重点对比

| 特性 | 聚集索引 | 非聚集索引 |
|------|---------|-----------|
| 数量限制 | 一个表只能有一个 | 一个表可以有多个 |
| 数据排序 | 按索引键物理排序 | 逻辑排序，物理无序 |
| 叶节点内容 | 存储实际数据记录 | 存储指向数据的指针 |
| 查询性能 | 范围查询性能好 | 单行查询性能好 |
| 更新代价 | 高（可能引起物理重排） | 较低 |

| 存储引擎 | 索引结构 | 数据存储 | 特点 |
|---------|---------|---------|------|
| InnoDB | B+树 | 数据和索引一起 | 主键索引=聚集索引 |
| MyISAM | B-树 | 数据和索引分开 | 索引存指针 |

### 7.4 查询优化口诀

记住这些要点：
- ✅ WHERE、ORDER BY建索引
- ❌ 避免NULL值判断
- ❌ 避免!=、<>操作符
- ❌ 慎用OR、IN、NOT IN
- ❌ 避免索引列上用表达式
- ❌ 避免索引列上用函数
- ✅ 用EXISTS代替IN
- ✅ 用DISTINCT代替GROUP BY
- ❌ 不要SELECT *
- ✅ JOIN字段建索引

---

## 八、典型例题

### 例题1：索引类型判断
**题目**：判断以下说法是否正确
1. 一个表可以有多个聚集索引
2. 聚集索引的叶节点存储实际数据
3. 非聚集索引不能用于范围查询

**答案**：
1. ❌ 错误。一个表只能有一个聚集索引
2. ✅ 正确。聚集索引的叶节点存储实际数据记录
3. ❌ 错误。非聚集索引可以用于范围查询，只是性能不如聚集索引

### 例题2：创建索引
**题目**：为student表的(name, age)创建组合索引

**答案**：
```sql
CREATE INDEX idx_name_age ON student(name, age);
```

### 例题3：SQL优化
**题目**：优化以下SQL语句
```sql
SELECT * FROM employee 
WHERE salary/12 > 5000 
  OR department='IT' 
  OR department='HR';
```

**答案**：
```sql
-- 优化1：避免在索引列上使用表达式
-- 优化2：用UNION ALL替代OR
-- 优化3：用具体字段代替*
SELECT emp_id, name, salary, department 
FROM employee 
WHERE salary > 60000
UNION ALL
SELECT emp_id, name, salary, department 
FROM employee 
WHERE department='IT'
UNION ALL
SELECT emp_id, name, salary, department 
FROM employee 
WHERE department='HR';
```

### 例题4：EXPLAIN分析
**题目**：使用EXPLAIN分析以下查询是否使用了索引
```sql
EXPLAIN SELECT * FROM stock WHERE mat_name LIKE '%绝缘%';
```

**答案**：
- 不会使用索引
- 原因：LIKE以通配符开头（'%绝缘%'）无法使用索引
- 改进：如果可能，改为 `mat_name LIKE '绝缘%'`

---

**复习建议**：
1. 重点理解聚集索引和非聚集索引的区别
2. 掌握InnoDB和MyISAM的索引结构差异
3. 熟记查询优化的各种技巧
4. 多练习使用EXPLAIN分析查询计划
5. 理解索引的适用场景和代价

