# 数据库第6章 - 索引及查询优化

> 整理自数据库期末复习PPT

---

## 6第六章 索引及查询优化.pptx


### 幻灯片 1

数据库原理


### 幻灯片 2

第六章    索引及查询优化

	6.1 索引
	6.2 查询优化技巧


### 幻灯片 3

❁建立索引的目的：加快查询速度，提高数据文件访问效率。
❁缺点：索引是有代价的（时、空）。为了维护索引，对数据进行插入、更新、删除操作所花费的时间会更长。
❁在设计和创建索引时，应确保对性能的提高程度大于在存储空间和处理资源方面的代价。
6.1 索引
6.1.1 索引的概念


### 幻灯片 4

6.1 索引
6.1.1 索引的概念
1、DBMS支持在表中任何列上定义的索引。
2、如果一个表没有创建索引，则数据行不按任何特定的顺序存储。这种结构称为堆集。
索引一般的两种类型为：
        聚集索引 、非聚集索引


### 幻灯片 5

6.1 索引
6.1.2  聚集索引
特点：数据文件中的记录按照索引键指定的顺序排序，使得具有相同索引键值的记录在物理上聚集在一起。
一个表只能建立一个聚集索引。
创建聚集索引前，mat_no无序


### 幻灯片 6

6.1 索引
6.1.2  聚集索引
特点：数据文件中的记录按照索引键指定的顺序排序，使得具有相同索引键值的记录在物理上聚集在一起。
一个表只能建立一个聚集索引。
创建聚集索引后，mat_no有序


### 幻灯片 7

6.1 索引
6.1.2  聚集索引
聚集索引结构
1） My SQL  将索引组织为B+树。索引内的每一页包含一个页首，页首后面跟着索引行。
2）每个索引行都包含一个键值以及一个指向较低级页或数据行的指针。
3）索引的每个页称为索引节点。
   B+树的顶端节点称为根节点。
   索引的底层节点称为叶节点。
   根和叶之间的任何索引级统称为中间级。
4）同级索引中的页链接在双向链接列表中。


### 幻灯片 8

6.1 索引
6.1.2  聚集索引
聚集索引的结构
非叶子节点只存储键值信息
数据记录都存放在叶子节点中
所有叶子节点之间形成链式结构


### 幻灯片 9

6.1 索引
6.1.2  聚集索引
聚集索引的例子


### 幻灯片 10

6.1 索引
6.1.2  聚集索引
◆聚集索引适用于： 
• 大量非重复值的列。
• 经常被连续访问的列。
• 经常使用联接或 GROUP BY 子句的查询访问的列。
◆聚集索引不适用于： 
   频繁更改的列


### 幻灯片 11

6.1 索引
6.1.3  非聚集索引
❀特点：1）索引与数据行的存放顺序无关
   2）索引作为表的附加信息
   3）有利于单行查询，不利于范围查询
❀一个表可以建立多个非聚集索引。
❀ 非聚集索引与聚集索引两个重大区别： 
（1）数据行不按非聚集索引键的顺序排序和存储。
（2）非聚集索引的叶层不包含数据页。


### 幻灯片 12

6.1 索引
6.1.3  非聚集索引
聚集索引的结构
叶层是索引行，不包含数据页


### 幻灯片 13

6.1 索引
6.1.3  非聚集索引
非聚集索引的例子


### 幻灯片 14

6.1 索引
6.1.3  非聚集索引
除了聚集索引以外的索引都是非聚集索引，非聚集索引包含如下几种索引：
❀唯一索引：唯一索引列的值必须唯一，允许有空值，但至多只能有一个空值。如果是组合索引，则列值的组合必须唯一。
❀单值索引：这是最基本的非聚集索引，它没有任何限制，但是尽量选择区分度高的列作为索引。例如选择姓名做索引，而不会选择性别来做索引。
❀组合索引：即一个索引包含多个列。


### 幻灯片 15

6.1 索引
6.1.4  MYSQL 索引的结构
❀ InnoDB 存储引擎
索引类型：InnoDB 存储引擎使用的是 B + 树索引。
特点：
聚集索引（Clustered Index）：InnoDB 将表数据和主键索引存储在一起，主键索引就是表的聚集索引。这意味着表数据是按照主键的顺序存储的，主键索引的叶子节点直接存储了表的行数据。
辅助索引（Secondary Index）：除了主键索引之外的其他索引称为辅助索引。辅助索引也是 B + 树结构，但其叶子节点存储的是主键值（而不是行数据的直接指针）。通过辅助索引查找数据时，首先找到主键值，然后通过主键值再查找聚集索引以获取完整的行数据。
适用场景：
InnoDB 的 B + 树索引非常适合范围查询（BETWEEN、>、<）和排序操作（ORDER BY），因为叶子节点之间通过链表连接，可以高效地进行顺序扫描。
由于主键索引和表数据存储在一起，使用主键进行等值查询（=）也非常高效。


### 幻灯片 16

6.1 索引
6.1.4  MYSQL 索引的结构
❀ MyISAM 存储引擎
索引类型：MyISAM 存储引擎使用的是 B - 树索引。
特点：
MyISAM 的索引是典型的 B - 树结构，数据可以存储在内部节点和叶子节点中。
MyISAM 的表数据和索引是分开存储的。索引文件存储索引信息，数据文件存储实际的表数据。索引文件中的叶子节点存储的是指向数据文件中数据行的指针。
适用场景：
MyISAM 的 B - 树索引适合等值查询（=），但在范围查询和排序操作方面可能不如 B + 树高效。
由于 MyISAM 不支持事务和行级锁，它通常用于读多写少的场景，例如日志表或统计表。


### 幻灯片 17

6.1 索引
6.1.4  MYSQL 索引的结构
❀其他存储引擎
MEMORY 存储引擎：
默认使用哈希索引，但也可以显式创建 B - 树索引。
其他存储引擎：
一些其他存储引擎（如 NDB Cluster）可能使用不同的索引结构，具体取决于其设计目标和应用场景。


### 幻灯片 18

6.1 索引
6.1.4  创建MySQL索引
❀在创建表时创建索引：
CREATE TABLE table_name (
 column1 datatype,column2 datatype, ... 
[UNIQUE] INDEX index_name (column1 [ASC|DESC] ,…) );
❀为已存在的表添加普通索引： 
ALTER TABLE table_name ADD [UNIQUE] INDEX index_name index_name (column1 [ASC|DESC] ,….) ;
❀使用 CREATE INDEX 语句： 
CREATE INDEX [UNIQUE] index_name ON table_name (column1 [ASC|DESC] …) ;


### 幻灯片 19

6.1 索引
6.1.4  创建MySQL索引
❀全文索引:全文索引主要用于对文本数据进行全文搜索。它可以快速定位到包含特定单词或短语的文本数据。全文索引适用于对大量文本数据进行搜索的场景，如新闻文章、博客内容等
CREATE TABLE table_name ( column1 datatype, column2 datatype, ... FULLTEXT INDEX index_name (column_name) );
ALTER TABLE table_name ADD FULLTEXT INDEX index_name (column_name);
CREATE FULLTEXT INDEX index_name ON table_name (column_name);


### 幻灯片 20

6.1 索引
6.1.4  创建索引
【例】下列命令在Stock的mat_name 列上建立一个非聚簇索引：
CREATE INDEX  Index_mat_name  ON Stock(mat_name DESC);

【例】下列命令可以创建一个组合索引：
CREATE INDEX  Index_name_spec  ON Salvaging(prj_name,spec);


### 幻灯片 21

6.1 索引
6.1.5  何时创建索引
下列情况，推荐在该列上创建索引：
❀需要在该列搜索符合特定搜索关键字值的行，即精确匹配查询，如在WHERE子句中指定mat_no=' m01'。
❀需要在该列搜索关键字值属于某一特定范围值的行，即查询范围，例如在WHERE子句中指定：amount between 200 and 300。
❀在表Table1中搜索根据连接谓词与表Table2中的某个行匹配的行。
❀在不进行显式排序操作的情况下（如不用order by子句）产生经排序的查询输出。
❀使用Like进行比较查询，且模式以特定字符串如“abc%”开头。
❀搜索已定义了Foreign Key约束的两个表之间匹配的行。


### 幻灯片 22

6.1 索引
6.1.5  何时创建索引
MYSQL下查看索引是否起作用：
explain select * from stock 
where mat_num>='m001' and mat_num<='m003';


explain select * from stock where mat_name like '绝缘%';

 explain select * from stock where mat_name like '%绝缘%';


### 幻灯片 23

第六章    索引及查询优化

	6.1 索引
	6.2 查询优化技巧


### 幻灯片 24

6.2 查询优化技巧
1  数据库设计方面
❀对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。
❀应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描。
【例】 select id from t where num is null
 可以在num上设置默认值0，确保表中num列没有null值
  select id from t where num=0。
❀并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时,查询可能不会去利用索引。


### 幻灯片 25

6.2 查询优化技巧
1  数据库设计方面
❀索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率。
❀应尽可能的避免更新聚集索引数据列。
❀尽量使用数字型字段，这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。
❀尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为变长字段存储空间小，可以节省存储空间。


### 幻灯片 26

6.2 查询优化技巧
2  SQL 语句方面
❀应尽量避免在 where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描。
❀应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：
     select prj_num  fromout_stock  where mat_num=’m001’ or mat_num=’m002’;
可以这样查询：
select prj_num  fromout_stock  where mat_num=’m001’ 
union all 
select prj_num  fromout_stock  where mat_num=’m002’;
（3）in 和 not in 也要慎用，否则会导致全表扫描，如：
     select id from t where num in(1,2,3)
对于连续的数值，能用 between 就不要用 in 了：
     select id from t where num between 1 and 3


### 幻灯片 27

6.2 查询优化技巧
2  SQL 语句方面
❀in 和 not in 也要慎用，否则会导致全表扫描
 例如：    select id from t where num in(1,2,3)
对于连续的数值，能用 between 就不要用 in ：
     select id from t where num between 1 and 3
❀应尽量避免在 where 子句中对索引字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。
 例如：   select id from t where num/2=100 
               select id from t where name like ‘%abc%’


### 幻灯片 28

6.2 查询优化技巧
2  SQL 语句方面
❀应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。
例如：    select id from t where substring(name,1,3)=’abc’
              select id from t where datediff(day,createdate,’2005-11-30′)=0
应改为：
    select id from t where name like ‘abc%’
    select id from t where createdate>=’2005-11-30′ 
                                 and createdate<’2005-12-1′


### 幻灯片 29

6.2 查询优化技巧
2  SQL 语句方面
❀很多时候用 exists 代替 in 是一个好的选择： 
 例如：    select num from a where num in(select num from b) 
用下面的语句替换：
    select num from a where exists(select 1 from b where num=a.num)
❀任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。
❀能用DISTINCT的就不用GROUP BY
例如：SELECT prj_num FROM out_stock GROUP BY prj_num
可改为：
          SELECT DISTINCT prj_num FROM out_stock


### 幻灯片 30

6.2 查询优化技巧
2  SQL 语句方面
❀如果应用程序有很多JOIN 查询，应该确认两个表中Join的字段是被建过索引的。
❀任何在order by语句的非索引项或者有计算表达式都将降低查询速度。
❀尽量避免使用游标，因为游标的效率较差。
❀尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。
❀尽量避免大事务操作，提高系统并发能力。


### 幻灯片 31

6.2 查询优化技巧
3  优化数据库
❀硬件调整性能
❀调整数据库
❀使用存储过程
❀应用程序结构和算法


### 幻灯片 32

小结
索引的概念 
通过索引提高查询效率
谢谢观看！

---

