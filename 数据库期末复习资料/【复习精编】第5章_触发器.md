# 【复习精编】第5章 - 触发器

> 数据库期末复习 - 核心知识点整理

---

## 一、触发器基本概念

### 1.1 什么是触发器
- **定义**：用户定义在关系表上的一类由事件驱动的特殊过程
- **特点**：
  - 一种保证数据完整性的方法
  - 特殊的存储过程
  - 一旦定义，无须用户调用
  - 任何对表的修改操作均由服务器自动激活相应的触发器

### 1.2 触发器的作用
1. **强化约束**：实现主键和外键所不能保证的复杂的参照完整性和数据一致性
2. **跟踪变化**：记录数据变更历史
3. **级联运行**：自动执行相关表的操作
4. **存储过程的调用**：触发其他程序逻辑

---

## 二、MySQL触发器

### 2.1 触发器工作原理 - 两个特殊表

#### NEW表
- **INSERT操作**：存放将要（BEFORE）或已经（AFTER）插入的新数据
- **UPDATE操作**：存放将要或已经更新的新数据（更新后的新值）
- **使用方法**：`NEW.columnName`
- **特点**：可以在触发器中使用SET赋值

#### OLD表
- **DELETE操作**：存放将要或已经被删除的数据
- **UPDATE操作**：存放将要或已经更新前的原数据
- **使用方法**：`OLD.columnName`
- **特点**：只读的，不能修改

### 2.2 MySQL触发器语法

```sql
CREATE TRIGGER <触发器名>
   BEFORE | AFTER 
   INSERT | UPDATE | DELETE 
   ON 表名 FOR EACH ROW
   SQL语句
```

**语法要素**：
- **触发器名称**：唯一标识
- **触发时机**：BEFORE（语句之前触发）或 AFTER（语句之后触发）
- **触发事件**：INSERT、UPDATE、DELETE
- **FOR EACH ROW**：表示任何一条记录上的操作满足触发事件都会触发
- **SQL语句**：触发器要执行的操作

**注意**：不能同时在一个表上建立2个相同类型的触发器

### 2.3 INSERT事件触发器

**作用**：
- 检验要输入的数据是否符合规则
- 在插入的数据中增加数据
- 级联改变数据库中其他的数据表

**示例1**：求和计算
```sql
DELIMITER &&
CREATE TRIGGER tr1_stock 
BEFORE INSERT
ON stock FOR EACH ROW
  SET @sum=@sum+NEW.amount;
```

**示例2**：自动修改日期
```sql
DELIMITER &&
CREATE TRIGGER tr1_salvaging 
BEFORE INSERT
ON salvaging FOR EACH ROW
BEGIN
  IF(NEW.end_date=NEW.start_date) THEN
    SET NEW.end_date=ADDDATE(NEW.start_date,3);
  END IF;
END;
```

**示例3**：级联更新库存
```sql
DELIMITER &&
CREATE TRIGGER tr1_outstock 
AFTER INSERT
ON out_stock FOR EACH ROW
BEGIN
   DECLARE m_amout INT(11);
   SELECT amount INTO m_amout
   FROM out_stock
   WHERE prj_num=NEW.prj_num AND mat_num=NEW.mat_num;    
   UPDATE stock
   SET amount=amount-m_amout
   WHERE mat_num=NEW.mat_num;        
END
```

### 2.4 DELETE事件触发器

**作用**：
- 防止删除数据库中的某些数据行
- 级联删除数据库中其他表中的数据行

**示例**：级联删除
```sql
DELIMITER &&
CREATE TRIGGER tr2_stock 
AFTER DELETE
ON stock FOR EACH ROW
BEGIN
   DELETE FROM out_stock
   WHERE mat_num=OLD.mat_num;       
END
```

**注意**：使用触发器作级联删除，前提是相关表没有定义外键

### 2.5 UPDATE事件触发器

**特点**：
- 合并了DELETE触发器和INSERT触发器的作用
- 原来的数据行保存在OLD表中
- 更新后的新数据行保存在NEW表中
- 可利用OLD表和NEW表获取更新前后的数据行，完成比较操作

**示例**：记录修改历史
```sql
DELIMITER &&
CREATE TRIGGER tr2_outstock 
AFTER UPDATE
ON out_stock FOR EACH ROW
BEGIN
   INSERT INTO modify_amount
   VALUES(OLD.prj_num, OLD.mat_num, USER(), NOW(), 
          OLD.amount, NEW.amount);
END
```

---

## 三、SQL Server触发器

### 3.1 SQL Server触发器语法

```sql
CREATE TRIGGER <触发器名>
ON { 表名 | 视图名 }
[ WITH ENCRYPTION ] 
{AFTER | INSTEAD OF}{[INSERT][,][UPDATE][,][DELETE]}
[ NOT FOR REPLICATION ]
AS [ SQL 语句 ]
```

**注意**：
- 一个触发器只能应用在一个表上
- 一个触发器可以包含很多动作，执行很多功能
- 触发器可以建立在基本表上，也可以建立在视图上

### 3.2 两种触发器类型

#### AFTER触发器
- 表示触发器在SQL语句中指定操作成功执行后才激活

#### INSTEAD OF触发器
- 表示在表或视图上执行增、删、改操作时，用该触发器中的SQL语句代替原语句
- **用途**：主要用于视图操作
- **原因**：视图可能显示表中的部分列，直接修改可能导致失败
- **注意**：视图只能使用INSTEAD OF触发器，不能使用AFTER触发器

### 3.3 两个特殊表

#### INSERTED表
- **INSERT操作**：存放要插入的数据
- **UPDATE操作**：存放要更新的记录（更新后的值）

#### DELETED表
- **DELETE操作**：存放被删除的记录
- **UPDATE操作**：存放更新前的记录（更新完毕后即被删除）

### 3.4 AFTER INSERT触发器

**示例1**：验证数据
```sql
CREATE TRIGGER tr1_stock
   ON Stock
   AFTER INSERT
AS  
  DECLARE @amount INT
  SELECT @amount=amount FROM INSERTED
  IF @amount<1
  BEGIN 
    ROLLBACK TRAN
    RAISERROR('Amount must be greater than 1!',16,10)
  END
```

**示例2**：级联更新
```sql
CREATE TRIGGER tr1_outstock 
ON Out_stock
AFTER INSERT
AS  
BEGIN
   DECLARE @m_num CHAR(8), @m_amount INT
   SELECT @m_num=mat_num, @m_amount=amount FROM INSERTED 
   UPDATE Stock SET amount=amount-@m_amount
   WHERE mat_num=@m_num           
END
```

### 3.5 AFTER DELETE触发器

**示例**：级联删除
```sql
CREATE TRIGGER tr2_stock
   ON Stock
   AFTER DELETE
AS 
  BEGIN TRANSACTION 
     DECLARE @mat_num CHAR(8)
     SELECT @mat_num=mat_num FROM DELETED
     DELETE FROM Out_stock   
     WHERE mat_num=@mat_num
  COMMIT TRANSACTION
```

### 3.6 AFTER UPDATE触发器

**示例1**：撤销不符合规则的更新
```sql
CREATE TRIGGER tr3_stock
   ON Stock
   AFTER UPDATE
AS 
  DECLARE @amount_new INT, @amount_old INT, @mat_num CHAR(10)
  SELECT @amount_new=amount, @mat_num=mat_num FROM INSERTED
  IF @amount_new<1
   BEGIN 
        SELECT @amount_old=amount FROM DELETED   
        UPDATE Stock SET amount=@amount_old
        WHERE mat_num=@mat_num        
        PRINT 'the row can not be UPDATED!'
   END
ROLLBACK TRAN
```

**示例2**：检测更新的列（使用UPDATE函数）
```sql
CREATE TRIGGER tr4_stock  
ON Stock   
AFTER UPDATE
AS 
  DECLARE @amount INT
  IF UPDATE(warehouse)  -- 检测warehouse列是否被更新
   BEGIN 
      ROLLBACK TRAN
      PRINT '不允许修改物资存放仓库！'   
   END
  ELSE IF UPDATE(amount)  -- 检测amount列是否被更新
   BEGIN 
       SELECT @amount=amount FROM INSERTED
       IF @amount<1
       BEGIN 
          ROLLBACK TRAN
          PRINT '库存量小于1，不允许更新！'
       END
   END
```

**注意**：`UPDATE(列名)` 函数可以检测到一个列的更新

### 3.7 INSTEAD OF触发器

**用途**：用于视图操作，替代视图的插入、删除和更新操作

**示例1**：验证外键约束
```sql
CREATE TRIGGER tr3_outstock  
ON Out_stock
INSTEAD OF INSERT
AS
  IF EXISTS(SELECT * FROM INSERTED 
            WHERE prj_num NOT IN (SELECT prj_num FROM salvaging))
     PRINT '对不起，有抢修工程项目号不在工程项目表中，不能正确插入！' 
  ELSE
    INSERT INTO Out_stock SELECT * FROM INSERTED
```

**示例2**：补充视图中缺失的列
```sql
CREATE TRIGGER tr_viewstock     
 ON view_stock
 INSTEAD OF INSERT  
AS   
  DECLARE @mat_num CHAR(10), @mat_name CHAR(50), @speci CHAR(50),   
          @warehouse CHAR(50), @amount INT, @unit DECIMAL(18,2)
  SELECT @mat_num=mat_num, @mat_name=mat_name,
         @warehouse=warehouse, @amount=amount, @unit=unit
  FROM INSERTED
  SET @speci='未知'
  INSERT INTO stock(mat_num,mat_name,speci,warehouse,amount,unit)     
  VALUES(@mat_num, @mat_name, @speci, @warehouse, @amount, @unit)
```

### 3.8 复合触发器

**定义**：多个触发器可以组合在一起形成复合触发器

**示例**：组合DELETE和UPDATE事件
```sql
CREATE TRIGGER tr6_stock      
 ON stock
 AFTER DELETE, UPDATE 
AS   
  DECLARE @warehouse CHAR(50)
  SELECT @warehouse=warehouse FROM DELETED
  IF @warehouse='供电局1#仓库'
   BEGIN 
      ROLLBACK TRAN
      PRINT '不允许修改或删除供电局1#仓库的物资信息！'
   END
```

### 3.9 修改和删除触发器

**修改触发器**：
```sql
ALTER TRIGGER <触发器名>
ON { 表名 | 视图名 }
[ WITH ENCRYPTION ] 
{AFTER | INSTEAD OF}{[INSERT][,][UPDATE][,][DELETE]}
[ NOT FOR REPLICATION ]
AS [ SQL 语句 ]
```

**删除触发器**：
```sql
DROP TRIGGER 触发器名
```

**注意**：
- 只有数据库所有者才能修改触发器
- 在删除表时，依存于该表的触发器也将同时被删除

---

## 四、数据库完整性

### 4.1 基本概念
- **数据库的完整性**：数据的正确性和相容性
- **维护机制**：DBMS提供约束和检查的方式来保护数据库的完整性

### 4.2 完整性类型
1. **实体完整性约束**：主键约束
2. **参照完整性约束**：外键约束
3. **用户定义的完整性**：除了实体和参照完整性之外的其他完整性要求

### 4.3 实现方式
- **CHECK约束**：在CREATE TABLE命令中定义
- **触发器**：实现灵活、复杂的数据完整性要求（更常用）

### 4.4 复杂完整性示例

**需求**：领料日期必须在工程开始和结束日期之间

```sql
-- MySQL实现
CREATE TRIGGER tr3_outstock 
BEFORE INSERT
ON out_stock FOR EACH ROW
BEGIN
  DECLARE s_date DATETIME;
  DECLARE e_date DATETIME; 
  DECLARE msg VARCHAR(50);  
  SELECT start_date, end_date INTO s_date, e_date
  FROM salvaging
  WHERE prj_num=NEW.prj_num;
  IF (NEW.get_date<s_date) OR (NEW.get_date>e_date) THEN
   SET msg=CONCAT(NEW.prj_num,'项目领取的',NEW.mat_num,'物资领料日期有误！');
   SIGNAL SQLSTATE 'HY000' SET message_text=msg;
  END IF;
END
```

---

## 五、考试重点总结

### 5.1 核心概念（必考）
1. ✅ 触发器的定义和特点
2. ✅ NEW表和OLD表的区别和使用
3. ✅ BEFORE和AFTER的区别
4. ✅ INSERT、UPDATE、DELETE三种事件触发器的特点
5. ✅ MySQL和SQL Server触发器语法的区别
6. ✅ AFTER和INSTEAD OF触发器的区别

### 5.2 常考题型
1. **概念题**：
   - 什么是触发器？触发器有什么作用？
   - NEW表和OLD表的区别？
   - AFTER触发器和INSTEAD OF触发器的区别？

2. **语法题**：
   - 编写INSERT触发器实现数据验证
   - 编写DELETE触发器实现级联删除
   - 编写UPDATE触发器记录修改历史
   - 使用UPDATE函数检测特定列的更新

3. **应用题**：
   - 使用触发器维护数据完整性
   - 使用触发器实现复杂的业务逻辑
   - 针对视图编写INSTEAD OF触发器

### 5.3 注意事项
- ⚠️ 不能同时在一个表上建立2个相同类型的触发器
- ⚠️ OLD表是只读的，NEW表可以修改
- ⚠️ 使用触发器作级联删除，前提是没有定义外键
- ⚠️ 视图只能使用INSTEAD OF触发器，不能使用AFTER触发器
- ⚠️ UPDATE触发器合并了DELETE和INSERT触发器的作用

### 5.4 对比记忆

| 特性 | MySQL | SQL Server |
|------|-------|------------|
| 特殊表 | NEW、OLD | INSERTED、DELETED |
| 触发时机 | BEFORE、AFTER | AFTER、INSTEAD OF |
| 语法关键字 | FOR EACH ROW | 无此关键字 |
| 视图触发器 | 支持 | 仅INSTEAD OF |

---

## 六、典型例题

### 例题1：创建INSERT触发器验证数据
**题目**：在stock表上创建触发器，确保插入的库存量必须大于0

**MySQL答案**：
```sql
DELIMITER &&
CREATE TRIGGER check_amount
BEFORE INSERT ON stock
FOR EACH ROW
BEGIN
  IF NEW.amount <= 0 THEN
    SIGNAL SQLSTATE '45000' 
    SET MESSAGE_TEXT = '库存量必须大于0！';
  END IF;
END &&
DELIMITER ;
```

**SQL Server答案**：
```sql
CREATE TRIGGER check_amount
ON stock
AFTER INSERT
AS
  DECLARE @amount INT
  SELECT @amount=amount FROM INSERTED
  IF @amount <= 0
  BEGIN
    ROLLBACK TRAN
    RAISERROR('库存量必须大于0！', 16, 1)
  END
```

### 例题2：创建UPDATE触发器记录变更
**题目**：创建触发器，当stock表的amount列被修改时，将修改前后的值记录到history表

**答案**：
```sql
-- MySQL
DELIMITER &&
CREATE TRIGGER log_amount_change
AFTER UPDATE ON stock
FOR EACH ROW
BEGIN
  IF OLD.amount <> NEW.amount THEN
    INSERT INTO history(mat_num, old_amount, new_amount, update_time, user)
    VALUES(OLD.mat_num, OLD.amount, NEW.amount, NOW(), USER());
  END IF;
END &&
```

### 例题3：创建INSTEAD OF触发器
**题目**：为视图view_stock创建触发器，补充缺失的speci列默认值为'未知'

**答案**：
```sql
CREATE TRIGGER tr_view_insert
ON view_stock
INSTEAD OF INSERT
AS
  INSERT INTO stock(mat_num, mat_name, speci, warehouse, amount, unit)
  SELECT mat_num, mat_name, '未知', warehouse, amount, unit
  FROM INSERTED
```

---

**复习建议**：
1. 重点掌握触发器的语法和NEW/OLD表的使用
2. 理解BEFORE、AFTER、INSTEAD OF的区别
3. 多做练习题，熟练编写各类触发器
4. 注意MySQL和SQL Server的语法差异

