# 数据库第10章 - 数据库保护

> 整理自数据库期末复习PPT

---

## 10. 第十章 数据库保护v2.pptx


### 幻灯片 1

数据库原理


### 幻灯片 2

第十章 数据库保护

10.1 事务的概念
10.2 并发控制
10.3 数据库恢复技术
10.4 MySQL备份恢复技术


### 幻灯片 3

3
掌握事务的概念、状态、性质；
掌握并发调度的可串行性；
掌握锁及两段锁协议；
掌握死锁的概念、解决方法；
掌握数据库恢复概念、实现技术；
掌握故障的种类及恢复策略；
主要知识点要求


### 幻灯片 4

4
事务是一系列数据库操作序列：一条或一组SQL语句；存储过程或其中的一部分。

一个事务是一个完整的操作， 是一个整体----它或者完全执行,或者完全不执行。

事务是数据库应用程序的基本逻辑单元。

一个应用程序通常包含多个事务。
10.1 事务
10.1.1 事务的概念


### 幻灯片 5

5
（1）原子性(Atomicity)：每个事务的所有操作要么被成功地执行，要么一个也不被执行。
（2）一致性（数据库正确保持性） (Consistency)：一个事务的正确执行必须数据库从一个正确状态转换为另一个正确的状态。
例如:从帐户A转10000元到帐户B:
Update  account set 余额=余额-10000 where 帐号=A
Update  account set 余额=余额+10000 where 帐号=B
           如果因为某种原因,只执行了第一条语句,数据库中的数据将出现不正确状态。
（3）隔离性(Isolation) ，又称为独立性：多个并发事务之间不能相互干扰；并发不影响事务的执行。
例如:有多个售票窗口同时售火车票(多个并发事务),它们之间互不影响。
（4）持续性（操作结果永久保持性） (Durability)：事务对数据库的更新必须是永久的；事务一旦提交，则永久改变数据库中的数据。
10.1 事务
10.1.2 事务的ACID性质


### 幻灯片 6

6
事务控制语句(显式事务):
开始事务:Begin transaction
提交事务:Commit transaction
回滚事务:Rollback transaction
隐式事务
      如果语句中没有用到begin或commit,每个DML语句都会隐式地构造自己的事务
10.1 事务
10.1.3 事务的状态


### 幻灯片 7

（1）活动状态：事务开始运行就进入活动状态，直到部分提交或失败。
BEGIN-TRANSACTION：事务进入活动状态。
（2）部分提交状态：事务执行完最后一条语句，即执行完END-TRANSACTION命令之后进入部分提交状态，把事务的所有操作对数据库的影响存入数据库。
（3）失败状态：发现一个事务不能正常运行下去时。
ABORT-TRANSACTION：进入失败状态。DBMS消除事务中所有操作对数据库和其他事务的影响，结束事务的运行。
（4）异常结束状态：当一个失败事务对数据库和其他事务的影响被消除，数据库恢复到该事务开始执行前的状态之后，该失败事务退出DBS，进入异常结束状态。
（5）提交状态：当一个事务成功地完成了所有操作，并且所有操作对数据库的影响都已永久地存入数据库之后，该事务退出DBS，进入提交状态，正常结束。
COMMIT-TRANSACTION：事务进入提交状态。
10.1 事务
10.1.3 事务的状态


### 幻灯片 8

8
串行事务
一个事务结束，另一个事务才开始。
并行事务
多个事务同时执行：
单处理器：分时并发（交叉并发）。
 能够减少处理机的空闲时间，提高系统的效率。
多处理器：每个处理器处理一个事务，同时并行。
10.2 并发控制
10.2.1 并发控制的概念


### 幻灯片 9

9
一、并发控制的必要性
❀存在问题：多个事务同时存取同一数据，导致数据一致性被破坏。
数据更新丢失问题
读脏数据问题
错误聚集计算问题
不可重复读问题
幻影数据行

实例：在飞机订票数据库系统中，设X和Y分别是航班A1和A2对应的数据库记录。
事务T1：取消A1上已经预订的5个座位，并为A2加上5个座位。
事务T2：为航班A1加上3个座位。
10.2 并发控制
10.2.1 并发控制的概念


### 幻灯片 10

（1）T1和T2的第一种并发运行方式
          T1                                     T2
    READ(X);
    X:=X-5;
                                             READ(X);
                                             X:=X+3;
    WRITE(X);
     READ(Y);
                                             WRITE(X);   
     Y:=Y+5;
     WRITE(Y); 

分析：若运行前：X=80;则运行后应为：X=78 。但运行结果为：X=83。
时间
10.2 并发控制
10.2.1 并发控制的概念
数据丢失更新


### 幻灯片 11

（2）T1和T2的第二种并发运行方式
          T1                                     T2
    READ(X);
    X:=X-5;
    WRITE(X);
                                             READ(X);
                                             X:=X+3;
                                             WRITE(X); 
     READ(Y);

 此时T1失败，X的值必须恢复为原来的值，但T2已经使用了X的不正确的临时值。
时间
10.2 并发控制
10.2.1 并发控制的概念
读“脏”数据


### 幻灯片 12

聚集计算函数     在事务中经常出现，如果两个事务并发运行，第一个事务计算数据库的所有记录的某个数据域的和，而第二个事务在更新这个数据域，从而使得第一个事务的计算结果可能出错。
在飞机订票系统中，若定义了事务T3,计算所有航班已经预订出的座位数之和。
3、错误聚集计算问题
（3）T1和T3的一种并发运行方式
          T1                                     T3
                                              SUM:=0
                                              READ(A);
                                              SUM:=SUM+A;
    READ(X);
    X:=X-5;
    WRITE(X);
                                             READ(X);
                                             SUM:=SUM+X;
                                             READ(Y);
                                             SUM:=SUM+Y;
     READ(Y);   
     Y:=Y+5;
     WRITE(Y);
时间
10.2 并发控制
10.2.1 并发控制的概念


### 幻灯片 13

并发控制中存在的其它典型问题： 
不可重复读：
事务T1读取数据C；
并发事务T2读取数据C，并作修改，然后提交；
事务T1继续（再次）读取数据C，同一事务中两次读取的数据C，是不一致的。
10.2 并发控制
10.2.1 并发控制的概念


### 幻灯片 14

幻影数据行（Phantom row )
事务A读取数据C（满足某条件的数据）；
并发事务B插入数据（满足该条件的数据），然后提交；
事务A继续（再次）读取数据C（满足该条件的数据），发现多出一些数据（而其他数据未被修改），就像是幻影一样。
即：同一事务中两次读数据的条数不一致。
10.2 并发控制
10.2.1 并发控制的概念


### 幻灯片 15

15
一、事务的调度
定义１：Ｎ个事务的一个调度Ｓ是Ｎ个事务的所有操作的一个序列，表示这些操作的执行顺序，并且满足对于Ｎ个事务的每个事务Ｔ，若操作i在Ｔ中先于操作j执行，则在Ｓ中操作i也须先于操作j执行。
１、调度的类型
串行调度：一个事务的所有操作都执行完后才执行另一个事务的所有操作。
　　对于Ｎ个事务，有Ｎ!个串行调度。
并行调度：除串行调度的其它调度。
10.2 并发控制
10.2.2 事务的调度


### 幻灯片 16

实例：考虑一个简单的银行数据库系统，设每个帐号在库中有一个数据库记录，记录内容包含该帐号的存款数额和其他信息。
设事务T1:从帐号Ａ转50元钱到帐号Ｂ。
　事务T2:将帐号Ａ存款的10%转到帐号Ｂ。
(１)T1与T2的第一种串行调度方法：
　　　T1                                   T2
    READ(A);
    A:=A-50;
    WRITE(A);
    READ(B);
    B=B+50;
    WRITEA(B);                      
                              READ(A);
                              tmp:=A*0.1;
                              A=A-tmp;
                              WRITE(A);
                               READ(B);
                               B=B+tmp;
                               WRITEA(B);
时间
10.2 并发控制
10.2.2 事务的调度


### 幻灯片 17

（２）T1与T2的第二种串行调度方法：
　　T1　                      T2
   　　　　　　　　READ(A);
                tmp:=A*0.1;
                A=A-tmp;
                WRITE(A);
                READ(B);
                B=B+tmp;
                WRITEA(B);
    READ(A);
    A:=A-50;
    WRITE(A);
    READ(B);
    B=B+50;
    WRITEA(B);
时间
10.2 并发控制
10.2.2 事务的调度


### 幻灯片 18

（３）T1与T2的一种并行调度方法：
　　　T1                                   T2
    READ(A);
    A:=A-50;
    WRITE(A);
　　　　　　　　READ(A);
                              tmp:=A*0.1;
                              A=A-tmp;
                              WRITE(A);
 　READ(B);
 　B=B+50;
　 WRITEA(B);                     
　　　　　　　　　　　　　READ(B);
                               B=B+tmp;
                               WRITEA(B);
时间
10.2 并发控制
10.2.2 事务的调度


### 幻灯片 19

（４）T1与T2的一种有更新丢失问题的并行调度方法：
　　　T1                                   T2
    READ(A);
    A:=A-50;
　　　　　　　　READ(A);
                              tmp:=A*0.1;
                              A=A-tmp;
                              WRITE(A);
                               READ(B);
    WRITE(A);
    READ(B);
    B=B+50;
    WRITEA(B);                      
　　　　　　　　B=B+tmp;
                             WRITEA(B);
时间
注:由 (4)可得：给定Ｎ个事务，并不是所有的并行调度都具有与串行调度相同的效果。
10.2 并发控制
10.2.2 事务的调度


### 幻灯片 20

二、调度的可串行性
　　Ｎ个事务的调度Ｓ是可串行的，即Ｓ可等价于一个串行调度。
10.2 并发控制
10.2.2 事务的调度


### 幻灯片 21

21
锁（Locking）
并发调度的主要技术——封锁。
事务对需操作的数据进行加锁，以实现数据的互斥访问。
当一个事务访问某个数据项时，其他事务都不能修改该数据项。
对数据的访问均必须加锁。
10.2 并发控制
10.2.3 基于锁的并发控制协议


### 幻灯片 22

共享锁（Share lock，简记为S锁）：
读锁。
多个事务可对同一数据重复申请加读锁。
      事务T对数据Q加了S锁，其它事务可再对数据Q加S锁，而不能对数据Q加X锁（互斥锁），直到T释放数据Q上的S锁。
10.2 并发控制
10.2.3 基于锁的并发控制协议
锁的类型


### 幻灯片 23

互斥锁（又称为排它锁）（eXclusive lock，简记为X锁）：
写锁。
一旦事务T对数据Q加上了X锁，只允许T对其进行读写。
其他事务需等T释放X锁之后，才能获锁。
注：其它事务不能对数据Q再加S锁和X锁。
10.2 并发控制
10.2.3 基于锁的并发控制协议
锁的类型


### 幻灯片 24

LOCK-S(Q):申请数据项Q上的共享锁。
LOCK-X(Q):申请数据项Q上的互斥锁。
UNLOCK(Q):释放数据项Q上的锁。
锁的操作
10.2 并发控制
10.2.3 基于锁的并发控制协议


### 幻灯片 25

25
运用X锁和S锁对数据对象加锁时，需要约定一些规则：封锁协议（Locking Protocol）。 
何时申请X锁或S锁；
持锁时间、何时释放
不同的封锁协议，在不同的程度上为并发操作的正确调度提供一定的保证。
常用的封锁协议：三级封锁协议。
封锁协议
10.2 并发控制
10.2.3 基于锁的并发控制协议


### 幻灯片 26

（1）一级封锁协议
       事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放。
正常结束（COMMIT）
非正常结束（ROLLBACK）
❧一级封锁协议可防止丢失修改，并保证事务T是可恢复的。
❧在一级封锁协议中，如果是读数据，不需要加锁的，所以它不能保证可重复读和不读“脏”数据。
10.2 并发控制
10.2.3 基于锁的并发控制协议


### 幻灯片 27


**表格内容：**

T1 | T2
①  LOCK-X(A)
       获得
②  读A=16
 
③A←A-1
    写回A=15
    Commit
    UNLOCK(A)
④
 
 
⑤ | LOCK-X(A)
等待
等待
等待
等待…
获得LOCK-X(A)
读A=15
A←A-1
写回A=14
Commit
UNLOCK(A)
例:没有丢失修改
例:读“脏”数据
10.2 并发控制
10.2.3 基于锁的并发控制协议


### 幻灯片 28

（2）二级封锁协议
事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放。
事务T在读取数据R前必须先加S锁，读完后即可释放S锁。

可以防止丢失修改和读“脏”数据。由于读完数据后即可释放S锁，所以它不能保证可重复读。
10.2 并发控制
10.2.3 基于锁的并发控制协议


### 幻灯片 29

例:不可重复读
10.2 并发控制
10.2.3 基于锁的并发控制协议


### 幻灯片 30

（3）三级封锁协议
事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放。
事务T在读取数据R前必须先加S锁，直到事务结束才释放。

可以防止丢失修改和读“脏”数据，还防止了不可重复读。
10.2 并发控制
10.2.3 基于锁的并发控制协议


### 幻灯片 31


**表格内容：**

T1 | T2
①  LOCK-S(A)
         读A=50
         LOCK-S(B)
         读B=100
        求和=150
 ②
 
 
 ③   读A=50
        读B=100
        求和=150
        Commit
        UNLOCK(A)
        UNLOCK(B)
 ④  
 
 
 ⑤ | LOCK-X(B)
等待
等待
等待  
等待
等待
等待
等待
等待
获得 B的X锁
读B=100
B←B*2
写回B=200
Commit
UNLOK(B)
例:可重复读
10.2 并发控制
10.2.3 基于锁的并发控制协议


### 幻灯片 32


**表格内容：**

T1 | T2
① lock-X(C)
     读C= 100
     C←C*2
     写回C=200
②
  

③ ROLLBACK
    (C恢复为100)
    Unlock(C)
④
    
⑤ | Lock-S(C)
等待
等待
等待
等待
获得lock-S(C)
读C=100
Commit C
Unlock(C)
例:不读“脏”数据
10.2 并发控制
10.2.3 基于锁的并发控制协议


### 幻灯片 33

三级协议的主要区别：
10.2 并发控制
10.2.3 基于锁的并发控制协议


### 幻灯片 34

封锁技术可以有效地解决并行操作的一致性问题，但也带来一些新的问题：
（1）活锁：多个事务申请对数据R加锁，而系统随机地加锁，导致某些事务长等，如：
活锁和死锁
10.2 并发控制
10.2.3 基于锁的并发控制协议


### 幻灯片 35

避免活锁的方法：采用先来先服务的策略。
当多个事务请求封锁同一数据对象时，按请求封锁的先后次序对这些事务排队。
该数据对象上的锁一旦释放，首先批准申请队列中第一个事务获得锁。
10.2 并发控制
10.2.3 基于锁的并发控制协议


### 幻灯片 36

T1         T2
LOCK-X( R1)
.
.
.
LOCK-X(R2)
等待
等待
等待
.
.
.
LOCK-X( R2)
.
.
LOCK-X(R1)
等待
等待
.
死锁实例
（2）死锁：两个（或多个）事务互相申请对方加锁对象的排它锁，造成循环等待。
10.2 并发控制
10.2.3 基于锁的并发控制协议


### 幻灯片 37

解决死锁问题二类方法：
1）预防死锁
一次加锁法：事务一次性对需要的数据进行加锁。但降低了系统的并发性，数据的不可预见性。
顺序加锁法：估算需要的锁，对系统中的锁设定一个加锁顺序。所有事务均按照该顺序进行加锁很难估算。
2）死锁的诊断与解除：允许死锁的发生，对其进行诊断和解除。
10.2 并发控制
10.2.3 基于锁的并发控制协议


### 幻灯片 38

诊断死锁的方法：
1）超时法——设定时限，超过即为死锁。
优点：实现简单。
缺点：有可能误判死锁；时限若设置得太长，死锁发生后不能及时发现。
2）等待图法——回路即为死锁。
解除死锁的方法：
选择一个处理死锁代价最小的事务，将其撤消，释放此事务持有的所有的锁，使其它事务能继续运行下去。
10.2 并发控制
10.2.3 基于锁的并发控制协议


### 幻灯片 39

为保证并发操作的正确性，DBMS的并发控制机制必须提供一定的手段来保证调度是可串行化的。
两段锁（Two-Phase Locking,简称2PL）协议就是保证并发调度可串行性的封锁协议。
两段锁协议要求每个事务分两个阶段进行数据项的加锁和解锁：
加锁阶段：每个事务开始运行后即进入加锁阶段，申请获得所需要的所有锁。（不能释放锁,又称为扩展阶段）
解锁阶段：当一个事务第一次释放锁时，该事务进入解锁阶段。（不能再申请任何锁，又称为收缩阶段）
五、两段锁协议
10.2 并发控制
10.2.3 基于锁的并发控制协议


### 幻灯片 40

实例：
事务1的封锁序列：遵守两段锁协议。
LOCK-S(A) →LOCK-S(B) → LOCK-X(C) → UNLOCK(B) → UNLOCK(A) → UNLOCK(C)；

事务2的封锁序列：不遵守两段协议。
LOCK-S(A) → UNLOCK(A) → LOCK-S(B) → LOCK-X(C) → UNLOCK(C) → UNLOCK(B)；
10.2 并发控制
10.2.3 基于锁的并发控制协议


### 幻灯片 41

改进的两段锁协议：增加了共享锁与互斥锁的转换机制。
UPGRADE：共享锁   转 互斥锁。（只能在加锁阶段）
DOWNGRADE：表示互斥锁  转 共享锁。（只能在解锁阶段）
10.2 并发控制
10.2.3 基于锁的并发控制协议


### 幻灯片 42

例如：一改进的满足两段锁协议的并行调度，仅给出了与锁有关的操作。
          T1                                      T2
      LOCK-S(A);
      read(A)                            LOCK-S(A);
      LOCK-S(B);
                                              LOCK-S(B);
      LOCK-S(C);
      LOCK-S(D);
                                              UNLOCK(A);
                                              UNLOCK(B);
      LOCK-S(E);
      UPGRADE(A);
      write(A)
时间
10.2 并发控制
10.2.3 基于锁的并发控制协议


### 幻灯片 43

两段锁协议与防止死锁的一次封锁法
一次封锁法遵守两段锁协议。
遵守两段锁协议的事务可能发生死锁。
实例：遵守两段锁协议的事务发生死锁
T1
LOCK-S(B)
读B=2
 
 
LOCK-X(A)
等待
等待
T2
 
 
LOCK-S(A)
读A=2
 
LOCK-X(B)
等待
10.2 并发控制
10.2.3 基于锁的并发控制协议


### 幻灯片 44

两段锁协议与三级封锁协议
两类不同目的的协议
两段锁协议:保证并发调度的正确性;
三级封锁协议:在不同程度上保证数据一致性。
遵守第三级封锁协议必然遵守两段协议。
10.2 并发控制
10.2.3 基于锁的并发控制协议


### 幻灯片 45

45
锁的粒度
封锁对象的大小，即为锁的粒度：
   库级、表级、页面、行级、属性级。
锁粒度与并发度
锁粒度越大（可封锁的数据越大），并发度越小。
锁粒度越小，并发度越大。
多粒度封锁
在一个系统中，同时支持多种粒度，供事务选择。
10.2 并发控制
10.2.3 基于锁的并发控制协议


### 幻灯片 46

意向锁
引进意向锁（intention lock）目的
提高对某个数据对象加锁时系统的检查效率
如果对一个结点加意向锁，则说明该结点的下层结点正在被加锁
对任一结点加基本锁，必须先对它的上层结点加意向锁
例如，对任一元组加锁时，必须先对它所在的数据库和关系加意向锁
10.2 并发控制
10.2.3 基于锁的并发控制协议


### 幻灯片 47

常用意向锁
意向共享锁(Intent Share Lock，简称IS锁)
意向排它锁(Intent Exclusive Lock，简称IX锁)
共享意向排它锁(Share Intent Exclusive Lock，简称SIX锁)
10.2 并发控制
10.2.3 基于锁的并发控制协议


### 幻灯片 48

IS锁
如果对一个数据对象加IS锁，表示它的后裔结点拟（意向）加S锁。
 例如：事务T1要对R1中某个元组加S锁，则要首先对关系R1和数据库加IS锁。
IX锁
如果对一个数据对象加IX锁，表示它的后裔结点拟（意向）加X锁。
例如：事务T1要对R1中某个元组加X锁，则要首先对关 系R1和数据库加IX锁。
SIX锁
如果对一个数据对象加SIX锁，表示对它加S锁，再加IX锁，即SIX = S + IX。
例：对某个表加SIX锁，则表示该事务要读整个表（所以要对该表加S锁），同时会更新个别元组（所以要对该表加IX锁）。
10.2 并发控制
10.2.3 基于锁的并发控制协议
常用意向锁


### 幻灯片 49

10.2 并发控制
10.2.3 基于锁的并发控制协议
锁的相容


### 幻灯片 50

锁的强度
锁的强度是指它对其他锁的排斥程度
一个事务在申请封锁时以强锁代替弱锁是安全的，反之则不然
10.2 并发控制
10.2.3 基于锁的并发控制协议
锁的强度


### 幻灯片 51

具有意向锁的多粒度封锁方法
申请封锁时应该按自上而下的次序进行
释放封锁时则应该按自下而上的次序进行
   例如：事务T1要对关系R1加S锁
要首先对数据库加IS锁
检查数据库和R1是否已加了不相容的锁(X或IX)
不再需要搜索和检查R1中的元组是否加了不相容的锁(X锁)
具有意向锁的多粒度封锁方法
提高了系统的并发度
减少了加锁和解锁的开销
在实际的数据库管理系统产品中得到广泛应用
10.2 并发控制
10.2.3 基于锁的并发控制协议


### 幻灯片 52

具有意向锁的多粒度封锁方法
提高了系统的并发度
减少了加锁和解锁的开销
在实际的数据库管理系统产品中得到广泛应用
10.2 并发控制
10.2.3 基于锁的并发控制协议


### 幻灯片 53

53
10.3数据库恢复技术
数据库系统的数据库恢复机制的目的：
（１）保证事务的原子性
（２）发生故障后，数据库能恢复到正确状态。
故障类型  
计算机系统故障
事务故障
介质故障
其他原因（意外情况）
衡量系统优劣的重要指标！
10.3.1 数据库恢复概述


### 幻灯片 54

故障的影响
运行事务非正常中断
破坏数据库
故障可恢复性
（１）非永久存储器：如主存、缓存等。
特点：存取速度快
故障：不可恢复
（２）永久存储器：如磁盘、散存等。
特点：存取速度较慢
故障：可恢复
（３）永恒存储器
（理论上永远不会丢失信息。）
10.3数据库恢复技术
10.3.1 数据库恢复概述


### 幻灯片 55

55
一、恢复技术中的重要文件：日志文件（重点）
日志文件：用来记录事务对数据库的操作信息的文件。
日志文件的格式：
（1）以记录为单位的日志文件。
（2）以数据块为单位的日志文件。
日志使用机制：
    为保证事务的原子性，在执行一个数据库更新操作规程时，可以首先把描述更新操作的信息写入日志文件，而不修改数据库本身。当事务提交时，再使用日志中更新操作信息实现数据库的更新。
10.3数据库恢复技术
10.3.2 数据库恢复实现技术


### 幻灯片 56

1、常用的一些日志记录格式
T ：事务名，执行WRITE（Q）操作的事务。
X：数据项名，Q的唯一名字。
V1：原始值，Q在执行WRITE（Q）之前的值。
V2：新值，Q在执行WRITE（Q）之后的值。
（1）<T，start>：事务T已经开始。
（2）<T,X,V1,V2>:事务T在数据项X上执行的写操作。X在执行写操作之前的值为V1，执行写操作之后的值为V2。
（3）<T,commit>:事务T已经提交。
注：为保证日志在系统和磁盘发生故障时仍可使用，必须将它存储在永恒存储器上。
10.3数据库恢复技术
10.3.2 数据库恢复实现技术


### 幻灯片 57

1、推迟更新技术 
    该事务对数据库的所有更新操作记录在日志中，把所有数据库更新操作推迟到该事务提交时执行。
推迟更新协议：
（1）每个事务在到达提交点之前不能更新数据库。
（2）在一个事务的所有更新操作对应的日志记录写入永恒存储器之前，该事务不能到达提交点。
注：一事务到达提交时，称该事务进入部分提交状态。
二、恢复技术
10.3数据库恢复技术
10.3.2 数据库恢复实现技术


### 幻灯片 58

❁推迟技术执行事务T的过程：
(1)T开始执行，记录<T,start>;
(2)T发出WRITE（X）操作，记录<T,X,V1,V2>;
(3)T达部分提交状态时，记录<T,commit>，并将日志中形如<T,X,V1,V2> 的记录，把数据库中数据项X更新为新值V2。
(4)数据库真正的被事务T更新，T进入提交状态。
10.3数据库恢复技术
10.3.2 数据库恢复实现技术


### 幻灯片 59

✾由于推迟更新技术仅需新值，所以可以简化日志结构为<T,X,V2>。
实例：银行数据库系统中：
事务T1：从账号A向账号B转储50元；
事务T2：从账号C支出100元。两事务分别定义如下：
T1：READ(A);           T2:READ(C);
        A:=A-50;             C:=C-100;
        WRITE(A);          WRITE(C);
        READ(B);
        B:=B+50;
        WRITE(B);
10.3数据库恢复技术
10.3.2 数据库恢复实现技术


### 幻灯片 60

设A，B和C的初值分别是1000元、2000元和700元。且T1与T2按串行调度<T1,T2>
日志中所包含的有关T1、T2的信息如下：
<T1,START>         <T2,START>
<T1,A,950>           <T2,C,600>
<T1,B,2050>         <T2,COMMIT>
<T1,commit>
说明：
数据库中A、B值仅有在<T1,COMMIT>写入日志后才能被更改。
数据库中C值仅有在<T2,COMMIT>写入日志后才能被更改。
10.3数据库恢复技术
10.3.2 数据库恢复实现技术


### 幻灯片 61

✾日志与数据库变化过程实例：
 日志记录              数据库
<T1,START>         
<T1,A,950>
<T1,B,2050>
<T1,COMMIT>          
                      A=950
                      B=2050
<T2,START>
<T2,C,600>
<T2,COMMIT> 
                      C=60
10.3数据库恢复技术
10.3.2 数据库恢复实现技术


### 幻灯片 62

❦针对推迟更新技术DBMS所采用的恢复机制：（故障发生后，确定需要重做的事务T）
REDO（T）：
FOR日志中每个形如（T，X，V）的记录DO
          把数据库中数据项X的值改为V；
END FOR
注：REDO操作必须是幂等的，即执行多次和执行一次的效果相同。
10.3数据库恢复技术
10.3.2 数据库恢复实现技术


### 幻灯片 63

故障实例1：设故障恰好发生在T1的WRITE(B)操作信息被写入日志之后。 
日志内容如下：
             T1                                 T2           
       <T1,start>
       <T1,A,950>
       <T1,B,2050>
数据库中A、B值未改变。
数据库恢复机制：不采取任何恢复行动。
结果：A=1000，B=2000，C=700。
10.3数据库恢复技术
10.3.2 数据库恢复实现技术


### 幻灯片 64

故障实例2：设故障恰好发生在T2的WRITE(C)操作之后。 
日志内容如下：           
                T1                           T2
        <T1,start>
       <T1,A,950>
       <T1,B,2050>
       <T1,commit>
                                     <T2,start>
                                     <T2,C,600>
数据库中A、B值已改变，C值未改变。
数据库恢复机制：需要执行REDO（T1）。
结果：A=950，B=2050，C=700。
10.3数据库恢复技术
10.3.2 数据库恢复实现技术


### 幻灯片 65

故障实例3：设故障恰好发生在<T2,commit>之后。 
日志内容如下：
              T1                                  T2           
       <T1,start>
       <T1,A,950>
       <T1,B,2050>
       <T1,commit>
                                           <T2,start>
                                           <T2,C,600>
                                           <T2,commit>
数据库中A、B、C值已改变。
数据库恢复机制:需要执行REDO(T1),REDO(T2)。
结果：A=950，B=2050，C=600。
10.3数据库恢复技术
10.3.2 数据库恢复实现技术


### 幻灯片 66

2、即时更新技术 
❀非提交更新：处于活动状态的事务直接在数据库上实施的更新。
❀即时更新协议：
（1）在所有<T,X,V1,V2>型日志记录安全地存储到永恒存储器之前，事务T不能更新数据库。
（2）在所有<T,X,V1,V2>型日志记录安全地存储到永恒存储器之前，不允许事务T提交。
10.3数据库恢复技术
10.3.2 数据库恢复实现技术
二、恢复技术


### 幻灯片 67

即时更新技术运行事务T的过程：
（1）T开始执行时，记录<T,start>。
（2）T发出WRITE（X）操作，在日志中记录<T,X,V1,V2>，再直接在数据库上执行WRITE(X)。
（3）T达部分提交状态时，记录<T,commit>。
（4）数据库真正的被事务T更新，T进入提交状态。
10.3数据库恢复技术
10.3.2 数据库恢复实现技术


### 幻灯片 68

T1和T2同前实例。
日志中所包含的有关T1、T2的信息如下：
<T1,START>                 <T2,START>
<T1,A,1000,950>           <T2,C,700,600>
<T1,B,2000,2050>         <T2,COMMIT>
<T1,commit>
10.3数据库恢复技术
10.3.2 数据库恢复实现技术


### 幻灯片 69

✾日志与数据库变化过程实例：
 日志记录              数据库
<T1,START>         
<T1,A,1000，950>
                       A=950
<T1,B,2000，2050>
                       B=2050 
<T1,COMMIT>          
<T2,START>
<T2,C,700，600>
                       C=600
<T2,COMMIT>
10.3数据库恢复技术
10.3.2 数据库恢复实现技术


### 幻灯片 70

针对即时更新技术DBMS所采用的恢复机制：
UNDO（T）：
FOR日志中每个形如（T，X，V1，V2）的记录DO
          把数据库中数据项X的值改为V1；
END FOR
10.3数据库恢复技术
10.3.2 数据库恢复实现技术


### 幻灯片 71

REDO（T）：
FOR日志中每个形如（T，X，V1，V2）的记录DO
          把数据库中数据项X的值改为V2；
END FOR
注：UNDO、REDO操作必须是幂等的，即执行多次和执行一次的效果相同。
10.3数据库恢复技术
10.3.2 数据库恢复实现技术


### 幻灯片 72

数据库恢复过程：
（1）从后向前扫描日志记录，建立两个事务表：
提交事务表：含日志中有<Ti,commit>的所有事务Ti。
未提交事务表：含日志中具有<Ti,start>，但不具有<Ti,commit>的所有事务Ti。
（2）对提交事务表中的每个事务执行READO(T)。
（3）对未提交事务表中的每个事务执行UNDO（T），从日志删除T信息。
10.3数据库恢复技术
10.3.2 数据库恢复实现技术


### 幻灯片 73

故障实例1：设故障恰好发生在T1的WRITE(B)操作信息被写入日志之后。
日志内容如下：
              T1           
       <T1,start>
       <T1,A,1000,950>
       <T1,B,2000,2050>
数据库中A、B值已改变。
数据库恢复机制：因为T1未真正提交，所以
UNDO（T1），A、B被恢复A=1000，B=2000。
10.3数据库恢复技术
10.3.2 数据库恢复实现技术


### 幻灯片 74

故障实例2：设故障恰好发生在T2的WRITE(C)操作写入日志之后。
日志内容如下：
              T1                                  T2           
       <T1,start>
       <T1,A,1000,950>
       <T1,B,2000,2050>
       <T1,commit>
                                              <T2,start>
                                              <T2,C,700,600>

数据库中A、B 、C值已改变。
数据库恢复机制：因为T1已提交、T2未提交，要执行UNDO（T2）、REDO(T1)。结果：A=950，B=2050，C=700。注：UNDO(T2)须先执行。
10.3数据库恢复技术
10.3.2 数据库恢复实现技术


### 幻灯片 75

故障实例3：设故障恰好发生在<T2,commit>之后。
日志内容如下：

              T1                             T2           
       <T1,start>
       <T1,A,1000,950>
       <T1,B,2000,2050>
       <T1,commit>
                                         <T2,start>
                                         <T2,C,700,600>
                                         <T2,commit>
数据库中A、B、C值已改变。
数据库恢复机制:因为T1、T2都已提交，需要执行REDO(T1),REDO(T2)。
结果：A=950，B=2050，C=600。
10.3数据库恢复技术
10.3.2 数据库恢复实现技术


### 幻灯片 76

3、其它恢复技术及辅助技术：
1>缓冲技术（辅助作用）
（1）日志缓冲技术
目的：成批地向永恒存储器输出日志记录，减少I/O操作，提高效率。
（2）数据库缓冲技术
2>检测点技术（辅助作用）（重点）
原数据库恢复技术存在问题：
（1）搜索日志耗时长。
（2）重复执行了已成功的REDO操作。
10.3数据库恢复技术
10.3.2 数据库恢复实现技术
二、恢复技术


### 幻灯片 77

解决办法：增加检测点法
在日志中增加一类新记录： <checkpoint>，数据库恢复机制定期执行如下操作，建立检测点：
1）将当前缓存中所有日志记录输出到永恒存储器
2）将所有缓冲区中被修改的数据块写入磁盘
3）将日志记录<checkpoint>写入永恒存储器
✾使用检测点法对数据库恢复技术的改进： 
   在<checkpoint>之前的事务都已经提交，仅需对最近建立的检测点之后开始执行或处于活动状态的事务进REDO或UNDO操作。
利用数据库备份恢复
利用日志备份恢复
备份即时点
某事务即时点       故障即时点
备份恢复示意图：
10.3数据库恢复技术
10.3.2 数据库恢复实现技术


### 幻灯片 78

78
根据备份的方法：
热备
逻辑备份
裸文件备份
冷备
10.4 MySQL数据库备份与恢复
按照备份数据库的内容：
完全备份 
部分备份 
增量备份
差异备份
需要备份的数据：
表数据
二进制日志、InnoDB 事务日志
代码（存储过程、存储函数、触发器、事件调度器）
服务器配置文件


### 幻灯片 79

79
一、备份全部数据库
备份数据库中所有数据 
mysqldump -A -B --single-transaction ｜gzip>/server/backup/All_data_$(date +%F).sql.gz

备份某个库的数据
mysqldump -A -B --single-transaction testDB1｜gzip>/server/backup/testDB1_$(date +%F).sq
10.4 MySQL数据库备份与恢复


### 幻灯片 80

80
二、增量备份数据库
增量数据库备份指的是上一次全量备份之后到下一次全量备份这前这段时间内数据库所更新或者是增加的数据，将其备份下来。只记录自上次数据库备份后发生更改的数据。
增量数据库备份比数据库备份小而且备份速度快，因此可以更经常地备份，经常备份将减少丢失数据的危险。
使用增量数据库备份将数据库还原到增量数据库备份完成时的那一点。若要恢复到精确的故障点，必须使用事务日志备份。 
在下列情况下，可考虑使用增量数据库备份： 
自上次数据库备份后数据库中只有相对较少的数据发生了更改。如果多次修改相同的数据，则增量数据库备份尤其有效。
使用的是简单恢复模型，希望进行更频繁的备份，但不希望进行频繁的完整数据库备份。
使用的是完全恢复模型或大容量日志记录恢复模型，希望需要最少的时间在还原数据库时前滚事务日志备份。
10.4 MySQL数据库备份与恢复


### 幻灯片 81

81
建议在执行增量数据库备份时使用如下过程： 
创建定期的数据库备份。
在每个数据库备份之间定期创建增量数据库备份（例如，对于高度活动的系统，每隔四小时或四小时以上备份一次）。
如果使用完全恢复模型或大容量日志记录恢复模型，则创建事务日志备份的频率比增量数据库备份大，如每隔 30 分钟。
10.4 MySQL数据库备份与恢复


### 幻灯片 82

82
还原增量数据库备份的顺序为： 
还原最新的数据库备份。
还原最后一次的增量数据库备份。
如果使用完全恢复或大容量日志记录恢复，则应用自上次创建增量数据库备份后创建的所有事务日志备份。
10.4 MySQL数据库备份与恢复


### 幻灯片 83

83
三、事务日志备份
事务日志是自上次备份事务日志后对数据库执行的所有事务的一系列记录。可以使用事务日志备份将数据库恢复到特定的即时点（如输入多余数据前的那一点）或恢复到故障点。
还原事务日志备份时，前滚事务日志中记录的所有更改。当数据库到达事务日志的最后时，已重新创建了与开始执行备份操作的那一刻完全相同的数据库状态。如果数据库已经恢复，则将回滚备份操作开始时尚未完成的所有事务。
一般情况下，事务日志备份比数据库备份使用的资源少。因此可以比数据库备份更经常地创建事务日志备份。经常备份将减少丢失数据的危险。
10.4 MySQL数据库备份与恢复


### 幻灯片 84

84
为创建备份集，通常应定期生成数据库备份（如每天），并以更短的间隔生成事务日志备份（如每隔 10 分钟）。必须至少有一个数据库备份或覆盖的文件备份集，才能有效地进行日志备份。

事务日志备份序列独立于数据库备份。可以生成一个事务日志备份序列，然后定期生成用于开始还原操作的数据库备份。
10.4 MySQL数据库备份与恢复


### 幻灯片 85

85
四、用Navicat备份数据库
10.4 MySQL数据库备份与恢复


### 幻灯片 86

86
例子:假设有下列事件序列 :
时间                       事件
上午 8:00               备份数据库
中午                       备份事务日志
晚上 04:00:00        备份事务日志
下午 6:00               备份数据库
晚上 08:00:00        备份事务日志
晚上 10:00             出现故障
分析:晚上 8:00 创建的事务日志备份包含从下午 4:00 到晚上 8:00 的事务日志记录，中间跨越下午 6:00 创建数据库备份的时间。事务日志备份序列从上午 8:00 创建的初始数据库备份到晚上 8:00 创建的最后一次事务日志备份是连续的。
10.4 MySQL数据库备份与恢复


### 幻灯片 87

87
方案一:使用最后一次创建的数据库备份还原数据库
创建当前活动事务日志的备份。
还原下午 6:00 的数据库备份，然后应用晚上 8:00 的数据库备份和活动事务日志备份。
分析: 还原进程检测到晚上 8:00 的事务日志备份包含自上次还原备份后所发生的事务。因此，还原操作向下扫描事务日志直至下午 6:00 完成数据库备份时对应的即时点，并且只前滚事务日志备份内自该点后所完成的事务。对晚上 10:00 的事务日志备份再执行一次上述操作。
10.4 MySQL数据库备份与恢复


### 幻灯片 88

88
方案二:使用以前的数据库备份（早于最后一次创建的数据库备份）还原数据库
创建当前活动事务日志的备份。
还原上午 8:00 的数据库备份，然后按顺序还原全部四个事务日志备份。不要还原下午 6:00 的数据库备份。所有完成的事务都将前滚到晚上 10:00。
分析: 这个进程所用的时间比还原下午 6:00 的数据库备份要长。
方案二注重由事务日志备份链所提供的冗余安全性，使用这个事务日志备份链，即使数据库备丢失份，也可以还原数据库。可以还原以前的数据库备份，然后还原创建该数据库备份后所创建的所有事务日志备份。
10.4 MySQL数据库备份与恢复


### 幻灯片 89

完整备份 
       包含数据库中全部数据和日志文件信息，也称为是全库备份或者海量备份。 
优点：恢复操作简便，只需要将最近一次的备份恢复。
缺点：完全备份所占的存储空间很大且备份的时间较长。
总：SQL Server将备份过程中发生的任何活动，以及把任何未提交的事务备份到事务日志。恢复备份时，利用备份文件中捕捉到的部分事务日志来确保数据一致性。
BACKUP DATABASE  database_name 
  TO { DISK | TAPE } = 'physical_backup_device_name'
例1:在某一个时间点，对数据库Sample做一个完全备份，备份到文件D:\backup\Sample_full.bak：
    BACKUP DATABASE Sample 
   TO DISK=’D:\backup\Sample_full.bak’
10.5  SQL Server数据库备份与恢复
10.5.1 数据库备份
备份种类


### 幻灯片 90

差异备份 
      只记录自上次数据库备份后发生更改的数据。 
优点：比完整备份小且备份速度快,主要用于使用频繁的系统,可以经常地备份，将减少丢失数据的危险。
总：使用差异数据库备份将数据库还原到差异数据库备份完成时的那一点。若要恢复到精确的故障点，必须使用事务日志备份。
BACKUP DATABASE  database_name 
TO { DISK | TAPE } = 'physical_backup_device_name'
WITH  DIFFERENTIAL
例2: 若干时间过去了，Sample数据库的内容发生一些变化，需要做一个差异备份： 
BACKUP DATABASE Sample 
TO  DISK=’D:\backup\Sample_1.bak’ 
WITH  DIFFERENTIAL
10.5  SQL Server数据库备份与恢复
10.5.1 数据库备份


### 幻灯片 91

差异备份 
建议在执行差异数据库备份时使用如下过程： 
创建定期的完整数据库备份。
在每个完整数据库备份之间定期创建差异数据库备份。
如果使用完全恢复模型或大容量日志记录恢复模型，则创建事务日志备份的频率比差异数据库备份大。
还原差异数据库备份的顺序为： 
还原最新的数据库备份。
还原最后一次的差异数据库备份。
如果使用完全恢复或大容量日志记录恢复，则应用自上次创建差异数据库备份后创建的所有事务日志备份。
10.5  SQL Server数据库备份与恢复
10.5.1 数据库备份


### 幻灯片 92

日志文件备份 
 当数据库信息更改时,其更新操作将记入日志文件,将这部分操作信息进行备份。 
总：日志备份比完整备份使用的资源少,可以使用事务日志备份将数据库恢复到特定的即时点或恢复到故障点。
BACKUP LOG { database_name | @database_name_var }
TO { DISK | TAPE } = 'physical_backup_device_name‘
例3:再过了若干时间，下列命令将数据库Sample的日志备份到D:\backup\Sample_log.bak： 
BACKUP LOG Sample  TO  DISK=’D:\backup\Sample_log.bak’
事务日志备份序列独立于数据库备份。可以生成一个事务日志备份序列，然后定期生成用于开始还原操作的数据库备份。
10.5  SQL Server数据库备份与恢复
10.5.1 数据库备份


### 幻灯片 93

例子:假设有下列事件序列 :
时间                       事件
上午 8:00               备份数据库
中午                    备份事务日志
下午 04:00:00           备份事务日志
下午 6:00               备份数据库
晚上 08:00:00           备份事务日志
晚上 10:00               出现故障
分析:晚上 8:00 创建的事务日志备份包含从下午 4:00 到晚上 8:00 的事务日志记录，中间跨越下午 6:00 创建数据库备份的时间。事务日志备份序列从上午 8:00 创建的初始数据库备份到晚上 8:00 创建的最后一次事务日志备份是连续的。
10.5  SQL Server数据库备份与恢复
10.5.1 数据库备份


### 幻灯片 94

方案一:使用最后一次创建的数据库备份还原数据库
创建当前活动事务日志的备份。
还原下午 6:00 的数据库备份，然后应用晚上 8:00 的数据库备份和活动事务日志备份。
分析:还原进程检测到晚上 8:00 的事务日志备份包含自上次还原备份后所发生的事务。因此，还原操作向下扫描事务日志直至下午 6:00 完成数据库备份时对应的即时点，并且只前滚事务日志备份内自该点后所完成的事务。对晚上 10:00 的事务日志备份再执行一次上述操作。
10.5  SQL Server数据库备份与恢复
10.5.1 数据库备份


### 幻灯片 95

方案二:使用以前的数据库备份（早于最后一次创建的数据库备份）还原数据库
创建当前活动事务日志的备份。
还原上午 8:00 的数据库备份，然后按顺序还原全部四个事务日志备份。不要还原下午 6:00 的数据库备份。所有完成的事务都将前滚到晚上 10:00。
分析:这个进程所用的时间比还原下午 6:00 的数据库备份要长。
方案二注重由事务日志备份链所提供的冗余安全性，使用这个事务日志备份链，即使数据库备丢失份，也可以还原数据库。可以还原以前的数据库备份，然后还原创建该数据库备份后所创建的所有事务日志备份。
10.5  SQL Server数据库备份与恢复
10.5.1 数据库备份


### 幻灯片 96

该备份哪些数据库
下面的数据库应该定期备份：
master
model、msdb 
所有产品数据库
下列情况下，用户必须备份一个产品数据库：
创建该数据库后
创建索引后
清除事务日志后
执行了一个nonlogged操作之后
10.5  SQL Server数据库备份与恢复
10.5.1 数据库备份


### 幻灯片 97

备份前的计划工作
(1)确定备份的频率
(2)确定备份的内容
(3)确定使用的介质
(4)确定备份工作的负责人
(5)确定使用在线备份还是脱机备份
(6)确定是否使用备份服务器
(7)确定备份存储的地方
(8)确定备份存储的期限
10.5  SQL Server数据库备份与恢复
10.5.1 数据库备份


### 幻灯片 98

数据库恢复（还原）就是指加载数据库备份到系统中的进程。
1.根据数据库完全备份进行恢复
     任何磁盘故障或磁盘错误引起的数据库混乱或崩溃，都需要利用备份进行恢复，并且首先需要利用数据库完全备份进行恢复，然后再进行增量恢复或日志恢复。
RESTORE DATABASE  database_name FROM {DISK | TAPE } =   'physical_backup_device_name'  
 [WITH  [{NORECOVERY| RECOVERY}] ]
10.5  SQL Server数据库备份与恢复
10.5.2 数据库恢复


### 幻灯片 99

2.根据差异备份进行恢复
      如果存在差异备份，则一般需要进行相应的恢复操作。 恢复差异备份的数据库的命令也是RESTORE DATABASE，但是在根据增量备份之前需注意：
（1）已经使用RESTORE DATABASE命令完成了完全备份的恢复，同时指定了NORECOVERY子句；
（2）在进行差异备份恢复时需要指定NORECOVERY或RECOVERY；
（3）如果有多个差异备份，则一定要按照备份的先后顺序进行恢复。
10.5  SQL Server数据库备份与恢复
10.5.2 数据库恢复


### 幻灯片 100

3.根据日志文件进行恢复
    利用日志可以将数据库恢复到最新的一直状态或任意的事务点。利用事务日志进行恢复之前必须注意：
(1)在恢复事务日志备份前需首先恢复数据库完全备份或差异备份；
（2）如果有多个日志备份，则按先后顺序进行恢复。
RESTORE LOG  database_name  
 FROM  {DISK | TAPE } =   'physical_backup_device_name'  
[WITH  [{ NORECOVERY | RECOVERY}] [ [ , ] STOPAT =   date_time           | [ , ] STOPATMARK = 'mark_name' [ AFTER datetime ]          | [ , ] STOPBEFOREMARK = 'mark_name' [ AFTER datetime ]         ] ]
10.5  SQL Server数据库备份与恢复
10.5.2 数据库恢复


### 幻灯片 101

例4: 针对前例中的备份，下面的命令将数据库还原到其在 2011 年 4 月 15 日中午 12 点时的状态。
第一步：还原完全备份的数据库
RESTORE DATABASE Sample
FROM DISK=’D:\backup\Sample_full.bak’
 WITH NORECOVERY
第二步：还原差异备份的数据库
RESTORE DATABASE Sample
FROM DISK=’D:\backup\Sample_1.bak’
 WITH NORECOVERY
第三步：还原日志备份，并且只还原到2011年4月 15日中午 12 点时的状态
RESTORE LOG Sample
FROM DISK=’D:\backup\Sample_log.bak’
WITH RECOVERY, STOPAT = 'Apr 15, 2011 12:00 AM'
10.5  SQL Server数据库备份与恢复
10.5.2 数据库恢复


### 幻灯片 102

小结
Thanks!

---

