# 【考场精简】第6章 索引及查询优化

## 一、索引的基本概念

建立索引的目的是加快查询速度，提高数据文件访问效率。但索引是有代价的，为了维护索引，对数据进行插入、更新、删除操作所花费的时间会更长。在设计和创建索引时，应确保对性能的提高程度大于在存储空间和处理资源方面的代价。

DBMS支持在表中任何列上定义索引。如果一个表没有创建索引，则数据行不按任何特定的顺序存储，这种结构称为堆集。

索引主要有两种类型：聚集索引和非聚集索引。

## 二、聚集索引

聚集索引的特点是数据文件中的记录按照索引键指定的顺序排序，使得具有相同索引键值的记录在物理上聚集在一起。一个表只能建立一个聚集索引。

MySQL将索引组织为B+树。索引内的每一页包含一个页首，页首后面跟着索引行。每个索引行都包含一个键值以及一个指向较低级页或数据行的指针。索引的每个页称为索引节点。B+树的顶端节点称为根节点，索引的底层节点称为叶节点，根和叶之间的任何索引级统称为中间级。同级索引中的页链接在双向链接列表中。

聚集索引的结构特征：非叶子节点只存储键值信息，数据记录都存放在叶子节点中，所有叶子节点之间形成链式结构。

聚集索引适用于：大量非重复值的列，经常被连续访问的列，经常使用联接或GROUP BY子句的查询访问的列。

聚集索引不适用于：频繁更改的列。

## 三、非聚集索引

非聚集索引的特点：索引与数据行的存放顺序无关，索引作为表的附加信息，有利于单行查询但不利于范围查询。一个表可以建立多个非聚集索引。

非聚集索引与聚集索引两个重大区别：第一，数据行不按非聚集索引键的顺序排序和存储；第二，非聚集索引的叶层不包含数据页，叶层是索引行。

非聚集索引包括以下几种类型：

唯一索引：唯一索引列的值必须唯一，允许有空值但至多只能有一个空值。如果是组合索引，则列值的组合必须唯一。

单值索引：这是最基本的非聚集索引，没有任何限制，但尽量选择区分度高的列作为索引。例如选择姓名做索引，而不会选择性别来做索引。

组合索引：即一个索引包含多个列。

## 四、MySQL索引的存储引擎

InnoDB存储引擎：使用B+树索引。聚集索引即主键索引，将表数据和主键索引存储在一起，表数据按照主键顺序存储，主键索引的叶子节点直接存储了表的行数据。辅助索引即除主键索引之外的其他索引，其叶子节点存储的是主键值。通过辅助索引查找数据时，首先找到主键值，然后通过主键值再查找聚集索引获取完整的行数据。InnoDB的B+树索引适合范围查询、排序操作和主键等值查询。

MyISAM存储引擎：使用B-树索引。数据可以存储在内部节点和叶子节点中。表数据和索引是分开存储的，索引文件中的叶子节点存储的是指向数据文件中数据行的指针。MyISAM的B-树索引适合等值查询，但在范围查询和排序操作方面不如B+树高效。由于不支持事务和行级锁，通常用于读多写少的场景。

MEMORY存储引擎：默认使用哈希索引，但也可以显式创建B-树索引。

## 五、创建索引的方法

在创建表时创建索引：
CREATE TABLE table_name (column1 datatype, column2 datatype, UNIQUE INDEX index_name (column1 ASC));

为已存在的表添加索引：
ALTER TABLE table_name ADD UNIQUE INDEX index_name (column1 DESC);

使用CREATE INDEX语句：
CREATE UNIQUE INDEX index_name ON table_name (column1 ASC);

全文索引：全文索引主要用于对文本数据进行全文搜索，可以快速定位到包含特定单词或短语的文本数据，适用于新闻文章、博客内容等场景。
CREATE TABLE table_name (column1 datatype, column2 datatype, FULLTEXT INDEX index_name (column_name));
ALTER TABLE table_name ADD FULLTEXT INDEX index_name (column_name);
CREATE FULLTEXT INDEX index_name ON table_name (column_name);

例题1：在Stock的mat_name列上建立一个非聚集索引：
CREATE INDEX Index_mat_name ON Stock(mat_name DESC);

例题2：创建一个组合索引：
CREATE INDEX Index_name_spec ON Salvaging(prj_name, spec);

## 六、何时创建索引

下列情况推荐在该列上创建索引：

需要在该列搜索符合特定搜索关键字值的行，即精确匹配查询，如在WHERE子句中指定mat_no='m01'。

需要在该列搜索关键字值属于某一特定范围值的行，即查询范围，例如在WHERE子句中指定amount between 200 and 300。

在表Table1中搜索根据连接谓词与表Table2中的某个行匹配的行。

在不进行显式排序操作的情况下产生经排序的查询输出。

使用Like进行比较查询，且模式以特定字符串如"abc%"开头。

搜索已定义了Foreign Key约束的两个表之间匹配的行。

查看索引是否起作用的例题：
explain select * from stock where mat_num>='m001' and mat_num<='m003';
explain select * from stock where mat_name like '绝缘%';
explain select * from stock where mat_name like '%绝缘%';

注意：第一个和第二个查询会使用索引，第三个查询因为模式以通配符开头不会使用索引。

## 七、查询优化技巧：数据库设计方面

对查询进行优化应尽量避免全表扫描，首先应考虑在where及order by涉及的列上建立索引。

应尽量避免在where子句中对字段进行null值判断，否则将导致引擎放弃使用索引而进行全表扫描。例如select id from t where num is null可以在num上设置默认值0，确保表中num列没有null值，改为select id from t where num=0。

并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时查询可能不会去利用索引。

索引并不是越多越好，索引固然可以提高相应的select的效率，但同时也降低了insert及update的效率。

应尽可能的避免更新聚集索引数据列。

尽量使用数字型字段，这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。

尽可能的使用varchar/nvarchar代替char/nchar，因为变长字段存储空间小可以节省存储空间。

## 八、查询优化技巧：SQL语句方面

应尽量避免在where子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描。

应尽量避免在where子句中使用or来连接条件，否则将导致引擎放弃使用索引而进行全表扫描。

例题：select prj_num from out_stock where mat_num='m001' or mat_num='m002';
可以改为：
select prj_num from out_stock where mat_num='m001' union all select prj_num from out_stock where mat_num='m002';

in和not in也要慎用，否则会导致全表扫描。

例题：select id from t where num in(1,2,3)
对于连续的数值能用between就不要用in：
select id from t where num between 1 and 3

应尽量避免在where子句中对索引字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。

例题：select id from t where num/2=100
例题：select id from t where name like '%abc%'
这两种写法都会导致全表扫描。

应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。

例题：select id from t where substring(name,1,3)='abc'
应改为：select id from t where name like 'abc%'

例题：select id from t where datediff(day,createdate,'2005-11-30')=0
应改为：select id from t where createdate>='2005-11-30' and createdate<'2005-12-1'

很多时候用exists代替in是一个好的选择。

例题：select num from a where num in(select num from b)
用下面的语句替换：select num from a where exists(select 1 from b where num=a.num)

任何地方都不要使用select * from t，用具体的字段列表代替*，不要返回用不到的任何字段。

能用DISTINCT的就不用GROUP BY。

例题：SELECT prj_num FROM out_stock GROUP BY prj_num
可改为：SELECT DISTINCT prj_num FROM out_stock

如果应用程序有很多JOIN查询，应该确认两个表中Join的字段是被建过索引的。

任何在order by语句的非索引项或者有计算表达式都将降低查询速度。

尽量避免使用游标，因为游标的效率较差。

尽量避免向客户端返回大数据量，若数据量过大应该考虑相应需求是否合理。

尽量避免大事务操作，提高系统并发能力。

## 九、查询优化技巧：优化数据库

硬件调整性能。

调整数据库配置。

使用存储过程。

优化应用程序结构和算法。

## 核心记忆要点

1. 一个表只能有一个聚集索引，但可以有多个非聚集索引
2. 聚集索引的数据行按索引键顺序物理存储，非聚集索引的索引和数据分开存储
3. InnoDB用B+树且主键索引是聚集索引，MyISAM用B-树且索引和数据分离
4. 避免全表扫描：不用null判断、不用!=或<>、慎用or和in、不对索引列做表达式或函数操作
5. Like查询只有前缀匹配才能用索引，如"abc%"可以，"%abc%"不行
6. 用exists代替in，用DISTINCT代替GROUP BY，用具体字段代替*
7. 索引不是越多越好，会降低insert和update效率
8. 连续数值用between不用in，能用数字型不用字符型，能用varchar不用char

