# 【考场精简】第5章 触发器和数据库完整性

## 一、触发器核心概念

触发器是用户定义在关系表上的一类由事件驱动的特殊过程，是一种保证数据完整性的方法，也可看作是一类特殊的存储过程。一旦定义，无须用户调用，任何对表的修改操作均由服务器自动激活相应的触发器。

主要作用：实现主键和外键所不能保证的复杂的参照完整性和数据一致性。具体功能包括：强化约束、跟踪变化、级联运行、存储过程的调用。

## 二、MySQL触发器

### 基本语法格式

CREATE TRIGGER 触发器名 BEFORE或AFTER INSERT或UPDATE或DELETE ON 表名 FOR EACH ROW SQL语句

关键点：BEFORE表示在激活语句之前触发，AFTER表示在激活语句之后触发。FOR EACH ROW表示任何一条记录上的操作满足触发事件都会触发该触发器。注意不能同时在一个表上建立2个相同类型的触发器。

### NEW表和OLD表的使用

NEW表：对于INSERT操作，NEW表里存放的是将要或已经插入的新数据。对于UPDATE操作，NEW表里存放的是将要或已经更新的新数据。使用方法是NEW.列名。

OLD表：对于DELETE操作，OLD表里存放的是将要或已经被删除的数据。对于UPDATE操作，OLD表里存放的是更新前的原数据。使用方法是OLD.列名。

重要提示：OLD表是只读的，而NEW表可以在触发器中使用SET赋值。

### 例题1：INSERT事件触发器求和

在对表stock插入物资记录前，对新插入的amount字段值进行求和计算。代码如下：

DELIMITER && CREATE TRIGGER tr1_stock BEFORE INSERT ON stock FOR EACH ROW SET @sum=@sum+NEW.amount;

测试语句：set @sum=0; insert into stock值('m030','护套绝缘电线','BVV-120','供电局1#仓库',10,100),('m031','护套绝缘电线','BVV-150','供电局1#仓库',20,100); select @sum; 结果会显示30。

### 例题2：INSERT事件自动修改日期

在对表salvaging插入抢修项目前，如果项目开始日期和项目结束日期相同，则将项目结束日期设为开始日期三天后。代码如下：

DELIMITER && CREATE TRIGGER tr1_salvaging BEFORE INSERT ON salvaging FOR EACH ROW BEGIN if(NEW.end_date=NEW.start_date) then set NEW.end_date=ADDDATE(NEW.start_date,3); end if; END;

测试语句：insert into salvaging values('20190001','抢修项目1','2019-6-1','2019-6-1',0),('20190002','抢修项目2','2019-6-1','2019-6-2',0); 第一条记录的结束日期会自动变成2019-6-4。

### 例题3：INSERT事件级联更新

在对表Out_stock插入一条记录后，更改对应物资在Stock表中的库存数量，完成级联更改操作。代码如下：

DELIMITER && CREATE TRIGGER tr1_outstock AFTER INSERT ON out_stock FOR EACH ROW BEGIN declare m_amout int(11); select amount INTO m_amout from out_stock where prj_num=NEW.prj_num and mat_num=NEW.mat_num; update stock set amount=amount-m_amout where mat_num=NEW.mat_num; END

测试语句：insert into Out_stock values('20110006','m003',10,'2011-3-8','工程1部'); 执行后Stock表中m003物资的库存量会减少10。

### 例题4：DELETE事件级联删除

当用户从stock表中删除数据时，同时将out_stock表中相关物资的出库情况一并删除。代码如下：

DELIMITER && CREATE TRIGGER tr2_stock AFTER DELETE ON stock FOR EACH ROW BEGIN delete from out_stock where mat_num=OLD.mat_num; END

注意：使用触发器作级联删除,前提是Out_stock表没有定义和Stock表相关的外键。

### 例题5：UPDATE事件记录变更

定义一个数据表modify_amount，用于存储领料出库表out_stock中领取数量发生变化的情况。表结构包含：prj_num项目号、mat_num物资号、username修改人、updatetime修改时间、amount_old修改前数量、amount_new修改后数量。触发器代码如下：

DELIMITER && CREATE TRIGGER tr2_outstock AFTER UPDATE ON out_stock FOR EACH ROW BEGIN insert into modify_amount values(OLD.prj_num,OLD.mat_num,USER(),NOW(),OLD.amount,NEW.amount); END

测试语句：UPDATE Out_stock SET amount=8 WHERE prj_num='20110005' and mat_num='m006'; 执行后modify_amount表中会插入一条变更记录。

## 三、SQL Server触发器

### 基本语法格式

CREATE TRIGGER 触发器名 ON 表名或视图名 WITH ENCRYPTION可选 AFTER或INSTEAD OF INSERT或UPDATE或DELETE NOT FOR REPLICATION可选 AS SQL语句

关键点：一个触发器只能应用在一个表上，但一个触发器可以包含很多动作。触发器可以建立在基本表上，也可以建立在视图上。

### AFTER触发器和INSTEAD OF触发器

AFTER触发器：表示触发器在SQL语句中指定操作成功执行后才激活。

INSTEAD OF触发器：表示在表或视图上执行增删改操作时，用该触发器中的SQL语句代替原语句。注意视图只能使用INSTEAD OF触发器，而不能使用AFTER触发器。

### INSERTED表和DELETED表

INSERTED表：对于INSERT操作，INSERTED表里存放的是要插入的数据。对于UPDATE操作，INSERTED表里存放的是要更新的记录即更新后的值。

DELETED表：对于DELETE操作，DELETED表里存放的是被删除的记录。对于UPDATE操作，DELETED表里存放的是更新前的记录。

### 例题6：AFTER INSERT验证数据

在对表Stock进行插入后验证库存量的大小，若库存量小于1，则撤销该插入操作。代码如下：

CREATE TRIGGER tr1_stock ON Stock AFTER INSERT AS declare @amount int select @amount=amount from INSERTED if @amount<1 BEGIN ROLLBACK TRAN RAISERROR('Amount must be greater than 1!',16,10) END

测试语句1：INSERT INTO stock值('m030','护套绝缘电线','BVV-120','供电局1#仓库',2,100); 由于库存量大于等于1符合规则，可以正常插入执行。

测试语句2：INSERT INTO stock值('m031','护套绝缘电线','BVV-120','供电局1#仓库',0,100); 由于库存量小于1不符合规则，将撤销表的插入操作。

### 例题7：AFTER INSERT级联更新

在对表Out_stock插入一条记录后，更改对应物资在Stock表中的库存数量。代码如下：

CREATE TRIGGER tr1_outstock ON Out_stock AFTER INSERT AS BEGIN declare @m_num char(8), @m_amount int select @m_num=mat_num,@m_amount=amount from INSERTED update Stock set amount=amount-@m_amount where mat_num=@m_num END

测试语句：insert into Out_stock values('20110006','m001',10,'2011-3-8','工程1部'); 执行后Stock表中m001物资的库存量会减少10。

### 例题8：AFTER DELETE级联删除

当用户从Stock表中删除数据时，同时将Out_stock表中相关物资的出库情况一并删除。代码如下：

CREATE TRIGGER tr2_stock ON Stock AFTER DELETE AS BEGIN TRANSACTION DECLARE @mat_num char(8) SELECT @mat_num=mat_num FROM DELETED DELETE FROM Out_stock WHERE mat_num=@mat_num COMMIT TRANSACTION

注意：使用触发器作级联删除,前提是Out_stock表没有定义和Stock表相关的外键。

### 例题9：AFTER UPDATE数据验证

当用户更新stock表中的数据时，从INSERTED表中读取修改的新的amount值，如果该值小于1，将撤销更新操作，即触发器从DELETED表中查询修改前的值，将其重新更新到stock表中。代码如下：

CREATE TRIGGER tr3_stock ON Stock AFTER UPDATE AS DECLARE @amount_new int,@amount_old int, @mat_num char(10) SELECT @amount_new=amount, @mat_num=mat_num FROM INSERTED IF @amount_new<1 BEGIN SELECT @amount_old=amount FROM DELETED UPDATE Stock SET amount=@amount_old WHERE mat_num=@mat_num PRINT 'the row can not be UPDATED!' END ROLLBACK TRAN

### 例题10：AFTER UPDATE检测特定列

先检测更新的列，当更新warehouse列时禁止更新；当更新库存量amount列时设置更新规则，若更新后的值小于1则撤销该更新操作。代码如下：

CREATE TRIGGER tr4_stock ON Stock AFTER UPDATE AS DECLARE @amount int IF UPDATE(warehouse) BEGIN ROLLBACK TRAN PRINT '不允许修改物资存放仓库！' END else IF UPDATE(amount) BEGIN SELECT @amount=amount FROM INSERTED IF @amount<1 BEGIN ROLLBACK TRAN PRINT '库存量小于1，不允许更新！' END END

注意：UPDATE函数可以检测到一个列的更新。

### 例题11：AFTER UPDATE记录变更历史

用于存储领料出库表Out_stock中领取数量发生变化的情况。表Modify_amount包含：prj_num项目号、mat_num物资号、username修改人、updatetime修改时间、amount_old修改前数量、amount_new修改后数量。触发器代码如下：

CREATE TRIGGER tr2_outstock on Out_stock AFTER UPDATE As If update(amount) Begin declare @amount_old int,@amount_new int declare @prj_no char(8),@mat_no char(8) select @prj_no=(select prj_num from DELETED) select @mat_no=(select mat_num from DELETED) select @amount_old=(select amount from DELETED) select @amount_new=(select amount from INSERTED) insert into Modify_amount values(@prj_no,@mat_no,USER_NAME(),GETDATE(),@amount_old, @amount_new) End

测试语句：UPDATE Out_stock SET amount=8 WHERE prj_num='20110005' and mat_num='m006'; 执行后Modify_amount表中会插入一条变更记录。

### 例题12：INSTEAD OF确保外键有效

对Out_stock表创建一个INSTEAD OF触发器，确保插入的抢修工程项目号在Salvaging表中存在。代码如下：

CREATE TRIGGER tr3_outstock on Out_stock INSTEAD OF INSERT AS if exists(select * from INSERTED where prj_num not in (select prj_num from salvaging)) print '对不起，有抢修工程项目号不在工程项目表中，不能正确插入！' else insert into Out_stock select * from INSERTED

测试语句：INSERT INTO out_stock VALUES ('20110006','m001',2,'2011-3-9','工程4部'),('20110007','m002',3,'2011-3-9','工程4部'); 如果20110006或20110007不在salvaging表中，会提示错误并不插入数据。

### 例题13：INSTEAD OF补充缺失列

创建一个INSTEAD OF触发器，在视图往基本表中插入数据行时补充speci的列值。首先创建视图view_stock，代码如下：

CREATE VIEW view_stock AS SELECT mat_num,mat_name,warehouse,amount,unit FROM stock

由于视图中不包括speci列，而基本表中speci列不能为空，若通过视图插入数据会出错。解决办法是创建触发器：

CREATE TRIGGER tr_viewstock ON view_stock INSTEAD OF INSERT AS DECLARE @mat_num char(10),@mat_name char(50),@speci char(50), @warehouse char(50), @amount int, @unit decimal(18,2) SELECT @mat_num=mat_num,@mat_name=mat_name, @warehouse=warehouse,@amount=amount,@unit=unit FROM INSERTED SET @speci='未知' INSERT INTO stock(mat_num,mat_name,speci,warehouse,amount,unit) VALUES(@mat_num,@mat_name,@speci,@warehouse,@amount,@unit)

测试语句：INSERT INTO view_stock VALUES('m100','护套绝缘电线','供电局1#仓库',10,110); 执行后会在stock表中插入一条记录，speci列的值自动设为"未知"。

### 例题14：复合触发器

创建一个复合触发器，不允许修改或删除存储在供电局1#仓库的物资信息。代码如下：

CREATE TRIGGER tr6_stock ON stock AFTERT DELETE,UPDATE AS DECLARE @warehouse char(50) SELECT @warehouse=warehouse FROM DELETED IF @warehouse= '供电局1#仓库' BEGIN ROLLBACK TRAN PRINT '不允许修改或删除供电局1#仓库的物资信息！' END

### 触发器的修改和删除

修改触发器：只有数据库所有者才能修改触发器。语法是ALTER TRIGGER 触发器名 ON 表名或视图名 WITH ENCRYPTION可选 AFTER或INSTEAD OF INSERT或UPDATE或DELETE NOT FOR REPLICATION可选 AS SQL语句

删除触发器：语法是DROP TRIGGER 触发器名

注意：在删除表时，依存于该表的触发器也将同时被删除。

## 四、数据库完整性

数据库的完整性是数据的正确性和相容性。为了维护数据库的完整性，DBMS必须提供一种机制来检查数据库的完整性。现代数据库技术采用对数据完整性予以约束和检查的方式来保护数据库的完整性。

除了实体完整性约束和参照完整性约束，其他与数据完整性有关的内容都是用户定义的数据完整性范畴。实现用户定义的完整性规则，除了CreateTable命令中的Check约束，更多的是使用触发器来实现灵活复杂的数据完整性要求。

### 例题15：使用触发器实现复杂完整性约束

在电力抢修工程数据库中，Out_stock表中的prj_num属性是外键，参照Salvaging表中prj_num属性，并且要求对于某一项抢修工程，其Out_stock表中的领料日期get_date的值必须介于Salvaging表中该工程的start_date和end_date值之间。例如prj_num为20110006的抢修工程的开始日期为2011-03-08结束日期为2011-03-10，则out_stock表中prj_num为20110006的记录的get_date值必须介于2011-03-08和2011-03-10之间。实现代码如下：

CREATE TRIGGER tr3_outstock BEFORE INSERT ON out_stock FOR EACH ROW BEGIN declare s_date datetime; declare e_date datetime; DECLARE msg varchar(50); select start_date,end_date into s_date,e_date from salvaging where prj_num=NEW.prj_num; if(NEW.get_date<s_date)or(NEW.get_date>e_date) then set msg=CONCAT(NEW.prj_num,'项目领取的',NEW.mat_num,'物资领料日期有误！'); signal sqlstate 'HY000' set message_text=msg; end if; END

测试语句：insert into out_stock values('20110006','m005',10,'2019-6-8','工程1部'); 如果日期不在工程的开始和结束日期之间，会抛出错误提示。

## 五、重要考点总结

1. 触发器的定义：由事件驱动的特殊过程，无须用户调用，任何对表的修改操作均由服务器自动激活。

2. MySQL触发器使用NEW表和OLD表，NEW表可以被修改，OLD表只读。

3. SQL Server触发器使用INSERTED表和DELETED表。

4. 触发时机：BEFORE在操作之前触发，AFTER在操作之后触发，INSTEAD OF代替原操作。

5. 触发事件：INSERT插入、DELETE删除、UPDATE更新。

6. FOR EACH ROW表示行级触发器，每条记录都会触发。

7. 不能在一个表上建立两个相同类型的触发器。

8. 触发器主要用于：强化约束、跟踪变化、级联运行、调用存储过程。

9. UPDATE触发器合并了DELETE和INSERT的作用，可以访问更新前后的数据。

10. 视图只能使用INSTEAD OF触发器，不能使用AFTER触发器。

11. UPDATE函数可以检测特定列是否被更新。

12. 使用ROLLBACK TRAN可以撤销操作。

13. 删除表时依存于该表的触发器也会被删除。

14. 触发器是实现复杂完整性约束的重要手段，可以实现主键和外键无法保证的复杂参照完整性。

