# 数据库第4章 - 存储过程与编程 【复习精编】

> 整理自数据库期末复习PPT，精炼知识点

---

## 📚 章节概览

- **4.1 MySQL编程语法**
- **4.2 存储过程**

---

## 4.1 MySQL编程语法

### 🔢 4.1.1 变量

MySQL变量分为**四种类型**：

| 变量类型 | 作用域 | 定义/使用方式 | 说明 |
|---------|--------|--------------|------|
| **局部变量** | BEGIN/END块 | DECLARE 变量名 类型 [DEFAULT 值] | 仅限于存储过程内部 |
| **用户变量** | 当前连接 | @变量名 | 不需提前声明 |
| **会话变量** | 当前连接 | @@session.变量名 | 每个连接独立 |
| **全局变量** | 整个服务器 | @@global.变量名 | 影响所有连接 |

#### 1. 局部变量（Local Variables）

**作用域：** 仅限于BEGIN...END语句块（如存储过程）

```sql
-- 定义局部变量
DECLARE m_amount INT DEFAULT 0;

-- 赋值方式1：使用SET
SET m_amount = 5;

-- 赋值方式2：使用SELECT INTO
SELECT amount INTO m_amount 
FROM stock 
WHERE mat_num = 'm001';
```

#### 2. 用户变量（User Variables）

**作用域：** 当前连接

```sql
-- 方式1：使用SET（可用 = 或 :=）
SET @m_amount = 5;
SET @m_amount := 5;

-- 方式2：使用SELECT（必须用 :=）
SELECT @m_amount := 5;
SELECT @m_amount := amount 
FROM stock 
WHERE mat_num = 'm001';
```

#### 3. 会话变量（Session Variables）

**作用域：** 当前连接，每个连接独立

```sql
-- 查看所有会话变量
SHOW SESSION VARIABLES;

-- 设置会话变量（三种方式）
SET SESSION auto_increment_increment = 1;
SET @@session.auto_increment_increment = 2;
SET auto_increment_increment = 3;  -- 默认session

-- 查询会话变量（三种方式）
SELECT @@auto_increment_increment;
SELECT @@session.auto_increment_increment;
SHOW SESSION VARIABLES LIKE '%auto_increment_increment%';

-- 使用LOCAL关键字（等同于SESSION）
SET @@local.auto_increment_increment = 1;
SELECT @@local.auto_increment_increment;
```

#### 4. 全局变量（Global Variables）

**作用域：** 整个服务器生命周期  
**权限要求：** 必须具有SUPER权限

```sql
-- 查看所有全局变量
SHOW GLOBAL VARIABLES;

-- 设置全局变量（两种方式）
SET GLOBAL sql_warnings = ON;  -- GLOBAL不能省略
SET @@global.sql_warnings = OFF;

-- 查询全局变量（两种方式）
SELECT @@global.sql_warnings;
SHOW GLOBAL VARIABLES LIKE '%sql_warnings%';
```

---

### 💬 4.1.2 注释语句

| 注释类型 | 语法 | 说明 |
|---------|------|------|
| 单行注释 | `-- 注释内容` | `--`后必须有空格 |
| 单行注释 | `# 注释内容` | `#`后无需空格 |
| 多行注释 | `/* 注释内容 */` | 可跨越多行 |
| 内联注释 | `/*! 代码 */` | 指定MySQL版本执行的代码 |

```sql
-- 示例
SELECT * FROM table;  -- 这是单行注释

SELECT * FROM table;  # 这也是单行注释

/* 这是
   多行注释 */

SELECT * FROM table /*!50110 WHERE condition */;  -- 内联注释
```

---

### 🔀 4.1.3 流程控制语句

#### 1. BEGIN...END语句

```sql
BEGIN
  语句1;
  语句2;
  ...
END
```

**作用：** 将多条SQL语句封装为一个语句块

#### 2. IF...ELSE语句

```sql
IF 条件表达式 THEN
  语句
[ELSE
  语句]
END IF;
```

**示例：**
```sql
DECLARE stock_amount INT;
SELECT amount INTO stock_amount FROM Stock WHERE mat_num = 'm001';

IF stock_amount < 10 THEN
  SELECT '库存不足，需要补货';
ELSE
  SELECT '库存充足';
END IF;
```

#### 3. WHILE循环语句

```sql
WHILE <条件> DO
  [语句]
END WHILE;
```

**示例：**
```sql
DECLARE counter INT DEFAULT 1;

WHILE counter <= 10 DO
  INSERT INTO numbers(value) VALUES(counter);
  SET counter = counter + 1;
END WHILE;
```

#### 4. CASE语句

**格式一：简单CASE**
```sql
CASE <表达式>
  WHEN <值1> THEN <结果1>
  WHEN <值2> THEN <结果2>
  ...
  [ELSE <结果n>]
END
```

**示例：**
```sql
SELECT mat_num, mat_name, speci, amount, unit,
  CASE warehouse
    WHEN '供电局1#仓库' THEN '北京'
    WHEN '供电局2#仓库' THEN '上海'
    WHEN '供电局3#仓库' THEN '广州'
    ELSE '未知'
  END AS warehouse
FROM Stock;
```

**格式二：搜索CASE**
```sql
CASE
  WHEN <条件1> THEN <结果1>
  WHEN <条件2> THEN <结果2>
  ...
  [ELSE <结果n>]
END
```

**示例：**
```sql
SELECT mat_num, mat_name, speci, amount, unit,
  CASE
    WHEN warehouse = '供电局1#仓库' THEN '北京'
    WHEN warehouse = '供电局2#仓库' THEN '上海'
    WHEN warehouse = '供电局3#仓库' THEN '广州'
    ELSE '未知'
  END AS warehouse
FROM Stock;
```

**高级应用 - 行转列：**
```sql
-- 查询各系各课程平均成绩
SELECT sdept,
  AVG(CASE WHEN cname='数据结构' THEN grade END) AS 数据结构,
  AVG(CASE WHEN cname='数据库原理' THEN grade END) AS 数据库原理,
  AVG(CASE WHEN cname='操作系统' THEN grade END) AS 操作系统
FROM student s
INNER JOIN sc ON s.Sno = sc.Sno
INNER JOIN course c ON sc.Cno = c.cno
GROUP BY sdept;
```

---

## 4.2 存储过程

### 📖 4.2.1 存储过程的基本概念

**定义：** 存储在数据库服务器中的一组编译成单个执行计划的SQL语句

**分类：**
- **系统存储过程**：SQL Server内置，以`sp_`为前缀
- **用户自定义存储过程**：用户创建的存储过程

**优点：**
1. **运行效率高**：编译和优化后存储，提供快速执行
2. **降低网络流量**：减少客户端和服务器之间的通信量
3. **方便实施企业规则**：集中管理业务逻辑

---

### 🛠️ 4.2.2 MySQL存储过程的创建和管理

#### 基本语法

```sql
CREATE PROCEDURE 存储过程名([参数列表])
BEGIN
  SQL语句
END
```

**参数类型：**
- `IN`：输入参数（默认）
- `OUT`：输出参数
- `INOUT`：输入输出参数

**调用语法：**
```sql
CALL 存储过程名([参数列表]);
```

---

#### 1. 基本存储过程（无参数）

```sql
DELIMITER &&
CREATE PROCEDURE pro1()
BEGIN
  SELECT * FROM stock;
END &&
DELIMITER ;

-- 调用
CALL pro1();
```

**⚠️ 说明：** `DELIMITER`用于更改语句结束符，避免冲突

---

#### 2. 带输入参数的存储过程（IN）

```sql
DELIMITER &&
CREATE PROCEDURE pro2(
  IN mno CHAR(8),
  IN mname VARCHAR(50),
  IN mspeci VARCHAR(20)
)
BEGIN
  INSERT INTO Stock(mat_num, mat_name, speci)
  VALUES(mno, mname, mspeci);
END &&
DELIMITER ;

-- 调用
CALL pro2('m030', '护套绝缘电线', 'BVV-35');
```

---

#### 3. 带输出参数的存储过程（OUT）

```sql
DELIMITER &&
CREATE PROCEDURE pro3(
  IN pn CHAR(8),
  OUT total INT
)
BEGIN
  SELECT SUM(amount) INTO total
  FROM out_stock
  WHERE prj_num = pn;
END &&
DELIMITER ;

-- 调用
CALL pro3('20100015', @total);
SELECT @total;  -- 查看输出结果
```

---

#### 4. 带输入输出参数的存储过程（INOUT）

```sql
DELIMITER &&
CREATE PROCEDURE pro4(
  INOUT depart VARCHAR(50),
  IN start_date DATETIME,
  IN end_date DATETIME,
  OUT count_prj INT,
  OUT sum_cost DECIMAL(18,2)
)
BEGIN
  SELECT COUNT(DISTINCT salvaging.prj_num),
         SUM(out_stock.amount * unit)
  INTO count_prj, sum_cost
  FROM salvaging
  INNER JOIN out_stock ON out_stock.prj_num = salvaging.prj_num
  INNER JOIN stock ON out_stock.mat_num = stock.mat_num
  WHERE department = depart
    AND get_date BETWEEN start_date AND end_date;
END &&
DELIMITER ;

-- 调用
SET @depart = '工程2部';
CALL pro4(@depart, '2011-1-1', '2011-1-31', @prjcounts, @sumcosts);
SELECT @depart, @prjcounts, @sumcosts;
```

---

#### 5. 嵌套调用存储过程

```sql
-- 子存储过程：查找使用物资总数最多的项目号
DELIMITER &&
CREATE PROCEDURE pro5(OUT prj_no CHAR(8))
BEGIN
  SELECT prj_num INTO prj_no
  FROM out_stock
  GROUP BY prj_num
  ORDER BY SUM(amount) DESC
  LIMIT 1;
END &&
DELIMITER ;

-- 父存储过程：查询项目详细信息
DELIMITER &&
CREATE PROCEDURE pro6()
BEGIN
  DECLARE prj_id CHAR(8);
  CALL pro5(@prj_id);
  SELECT *
  FROM Salvaging
  WHERE prj_num = @prj_id;
END &&
DELIMITER ;

-- 调用
CALL pro6();
```

---

#### 6. 在存储过程中使用游标

**游标操作步骤：**
1. **声明游标**：`DECLARE 游标名 CURSOR FOR SELECT语句;`
2. **打开游标**：`OPEN 游标名;`
3. **使用游标**：`FETCH 游标名 INTO 变量列表;`
4. **关闭游标**：`CLOSE 游标名;`

**示例：连接所有仓库名称**
```sql
DELIMITER &&
CREATE PROCEDURE pro7()
BEGIN
  DECLARE done INT DEFAULT 0;
  DECLARE whname VARCHAR(10) DEFAULT '';
  DECLARE allname VARCHAR(1000) DEFAULT '';
  
  -- 声明游标
  DECLARE cur1 CURSOR FOR 
    SELECT DISTINCT warehouse FROM stock;
  
  -- 声明处理程序（当游标到末尾时设置done=1）
  DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;
  
  -- 打开游标
  OPEN cur1;
  
  -- 循环读取
  REPEAT
    FETCH cur1 INTO whname;
    IF NOT done THEN
      SET allname = CONCAT(allname, whname);
    END IF;
  UNTIL done END REPEAT;
  
  -- 关闭游标
  CLOSE cur1;
  
  SELECT allname;
END &&
DELIMITER ;

-- 调用
CALL pro7();
```

**⚠️ 注意：**
- 游标必须在变量和条件之后声明
- 使用完游标必须关闭

---

#### 7. 查看存储过程

```sql
-- 方式1：查看存储过程状态
SHOW PROCEDURE STATUS LIKE 'pro_%';

-- 方式2：查看存储过程定义
SHOW CREATE PROCEDURE pro1;
```

---

#### 8. 修改和删除存储过程

```sql
-- 修改存储过程
ALTER PROCEDURE 存储过程名([参数列表])
BEGIN
  SQL语句
END;

-- 删除存储过程
DROP PROCEDURE 存储过程名;
```

---

### 🖥️ 4.2.3 SQL Server存储过程（了解）

#### 基本语法

```sql
CREATE PROCEDURE 存储过程名 [;版本号]
  [@参数 数据类型 [= 默认值] [OUTPUT], ...]
  [WITH {RECOMPILE | ENCRYPTION | RECOMPILE, ENCRYPTION}]
  [FOR REPLICATION]
AS
  SQL语句
```

**调用语法：**
```sql
EXECUTE [@返回值 =] 存储过程名
  [@参数 = {值 | @变量}, ...]
```

#### 示例对照（SQL Server vs MySQL）

**无参数存储过程：**
```sql
-- SQL Server
CREATE PROCEDURE exp1
AS
  SELECT * FROM Stock;

EXEC exp1;
```

**带输入参数：**
```sql
-- SQL Server
CREATE PROCEDURE exp2
  @mno CHAR(8),
  @mname VARCHAR(50),
  @mspeci VARCHAR(20)
AS
  INSERT INTO Stock(mat_num, mat_name, speci)
  VALUES(@mno, @mname, @mspeci);

EXEC exp2 'm030', '护套绝缘电线', 'BVV-35';
```

**带输出参数：**
```sql
-- SQL Server
CREATE PROCEDURE exp4
  @pn CHAR(8),
  @sum INT OUTPUT
AS
  SELECT @sum = SUM(amount)
  FROM Out_stock
  WHERE prj_num = @pn;

-- 调用
DECLARE @total INT;
EXEC exp4 '20110001', @total OUTPUT;
PRINT '该项目领取物资总量为：' + CAST(@total AS VARCHAR(20));
```

**带默认参数：**
```sql
-- SQL Server
CREATE PROCEDURE exp4
  @mname VARCHAR(50) = '%绝缘%',
  @pno CHAR(8) = '20110001'
AS
  SELECT mat_name, speci, prj_name, prj_status
  FROM stock, salvaging, out_stock
  WHERE stock.mat_num = out_stock.mat_num
    AND salvaging.prj_num = out_stock.prj_num
    AND mat_name LIKE @mname
    AND salvaging.prj_num = @pno;

-- 调用方式
EXEC exp4;  -- 使用默认值
EXEC exp4 '%绝缘电线';  -- 只改变第一个参数
EXEC exp4 @pno = '20110002';  -- 指定参数名
```

---

## 🎓 重点总结

### 必须掌握的内容

✅ **变量类型**：局部变量、用户变量、会话变量、全局变量的区别和使用  
✅ **流程控制**：IF、WHILE、CASE语句的语法和应用  
✅ **存储过程定义**：CREATE PROCEDURE的语法结构  
✅ **参数类型**：IN、OUT、INOUT的区别和使用  
✅ **存储过程调用**：CALL语句的使用  
✅ **游标操作**：声明、打开、使用、关闭的完整流程  

### 常见考点

⭐ 编写带有不同参数类型的存储过程  
⭐ 在存储过程中使用流程控制语句  
⭐ 使用游标遍历查询结果  
⭐ 存储过程的嵌套调用  
⭐ CASE语句实现行转列  
⭐ 局部变量vs用户变量的使用场景  

### 易错点

⚠️ 局部变量用DECLARE声明，用户变量用@前缀，无需声明  
⚠️ SELECT INTO用于局部变量赋值，SELECT @var := value用于用户变量  
⚠️ 游标必须在使用后关闭  
⚠️ OUTPUT参数在SQL Server中必须在调用时也声明OUTPUT  
⚠️ DELIMITER在MySQL中用于更改语句结束符  
⚠️ 游标处理程序要在游标声明之后  

### 编程技巧

1. **变量选择：**
   - 存储过程内部：使用局部变量（DECLARE）
   - 跨语句传递：使用用户变量（@var）
   
2. **参数设计：**
   - 只读取数据：使用IN参数
   - 只返回结果：使用OUT参数
   - 既输入又输出：使用INOUT参数

3. **游标使用：**
   - 大数据量逐行处理时使用
   - 注意声明顺序：变量 → 游标 → 处理程序
   - 使用REPEAT...UNTIL或WHILE循环遍历

4. **错误处理：**
   - 使用DECLARE CONTINUE HANDLER处理异常
   - 合理设置done标志位

---

## 📌 复习建议

1. **理解变量作用域**：区分四种变量类型的使用场景
2. **熟练流程控制**：掌握IF、WHILE、CASE的语法和应用
3. **掌握存储过程**：能够编写带各种参数的存储过程
4. **练习游标操作**：理解游标的工作原理和使用步骤
5. **动手实践**：实际编写和调试存储过程

---

**祝复习顺利！🎉**

