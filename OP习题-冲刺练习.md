# 操作系统原理 - 考前冲刺练习题

---

## 📝 题型一：进程同步经典问题

### 练习1：理发师问题
理发店有一个理发师、一把理发椅和n把供等待的椅子。如果没有顾客，理发师就睡觉；顾客来了，如果理发师在睡觉就叫醒他；如果理发师正在理发，顾客就坐在等待椅上，如果没有空椅子就离开。请用信号量实现。

**解题提示**：
- 关键信号量：
  - `customers = 0`（等待的顾客数）
  - `barbers = 0`（空闲的理发师）
  - `mutex = 1`（保护等待顾客数）
  - `waitingSeats = n`（等待座位数）

---

### 练习2：吸烟者问题  
假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但要卷起并抽掉一支烟，抽烟者需要有三种材料：烟草、纸和胶水。三个抽烟者中，一个有烟草、一个有纸、一个有胶水。供应者无限地提供三种材料，但每次只随机提供其中两种。请用信号量实现。

**解题提示**：
- 关键信号量：
  - `offer1 = 0`（提供纸和胶水）
  - `offer2 = 0`（提供烟草和胶水）
  - `offer3 = 0`（提供烟草和纸）
  - `finish = 0`（抽烟完成信号）

---

### 练习3：桥梁通行问题
一座桥只能单向通行，桥的两端分别有若干辆向东和向西的车辆等待过桥。为避免拥塞，规定：
- 同方向的车可以连续过桥
- 当一个方向有车过桥时，反方向的车必须等待
- 如果桥上没有车，任一方向的车都可以上桥
请用信号量实现。

**解题提示**：
- 关键信号量：
  - `bridge = 1`（桥的互斥访问）
  - `eastCount = 0`（向东的车数）
  - `westCount = 0`（向西的车数）
  - `eastMutex = 1`（保护eastCount）
  - `westMutex = 1`（保护westCount）
- 类似读者-写者问题的变体

---

## 📊 题型二：综合计算题

### 练习4：快表命中率计算
某计算机系统采用分页存储管理，页面大小4KB，逻辑地址32位。系统配置快表（TLB），访问快表时间20ns，访问内存时间100ns。

**问题**：
1. 若快表命中率为90%，计算有效访问时间
2. 若要求有效访问时间不超过110ns，快表命中率至少应为多少？

**解答提示**：

**问题1**：
```
有效访问时间 = 命中率 × (TLB + 内存) + (1-命中率) × (TLB + 2×内存)
            = 0.9 × (20 + 100) + 0.1 × (20 + 200)
            = 0.9 × 120 + 0.1 × 220
            = 108 + 22
            = 130ns
```

**问题2**：
```
设命中率为 h
h × 120 + (1-h) × 220 ≤ 110
120h + 220 - 220h ≤ 110
-100h ≤ -110
h ≥ 1.1 （不可能）

重新计算：
h × (20 + 100) + (1-h) × (20 + 100 + 100) ≤ 110
120h + 220(1-h) ≤ 110
120h + 220 - 220h ≤ 110
-100h ≤ -110
h ≥ 0.91

答案：快表命中率至少为91%
```

---

### 练习5：文件系统综合题
某文件系统采用三级索引结构（10个直接、1个一级、1个二级、1个三级），磁盘块1KB，地址4B。

**问题**：
1. 计算最大文件长度
2. 若文件270KB，第270KB处的数据在第几个数据块？需要几次磁盘访问？
3. 若磁盘转速7200转/分，平均寻道时间8ms，计算访问一个数据块的平均时间

**解答提示**：

**问题1**：
```
每块地址项数 = 1024 / 4 = 256

直接寻址：10 × 1KB = 10KB
一级间接：256 × 1KB = 256KB
二级间接：256 × 256 × 1KB = 64MB
三级间接：256 × 256 × 256 × 1KB = 16GB

最大文件长度 ≈ 16GB
```

**问题2**：
```
270KB位置分析：
- 0~10KB：直接寻址
- 10~266KB：一级间接
- 266~64MB：二级间接

270KB 在二级间接区域
相对二级间接的偏移 = 270 - 266 = 4KB
数据块号 = 4（第5个块，从0开始）

访问次数：
1. 读索引节点，获得二级间接地址
2. 读二级索引表，获得一级索引表地址
3. 读一级索引表，获得数据块地址
4. 读数据块
共4次
```

**问题3**：
```
旋转延迟 = 60s / 7200转 / 2 = 4.17ms（平均半圈）
平均访问时间 = 寻道时间 + 旋转延迟 + 传输时间
            = 8ms + 4.17ms + 传输时间
            ≈ 12.17ms + 传输时间
（传输时间通常很小，可忽略）
答案：约12~13ms
```

---

## 📚 题型三：简答对比题

### 练习6：对比题集锦

#### 1. 比较进程调度的长期调度、中期调度和短期调度

| 调度类型 | 也称为 | 调度对象 | 调度频率 | 主要功能 |
|---------|--------|---------|---------|---------|
| **长期调度** | 作业调度 | 后备队列中的作业 | 最低（分钟级）| 决定哪些作业进入内存 |
| **中期调度** | 交换调度 | 就绪队列和阻塞队列中的进程 | 中等（秒级）| 决定哪些进程换出/换入内存 |
| **短期调度** | 进程调度 | 就绪队列中的进程 | 最高（毫秒级）| 决定哪个进程获得CPU |

---

#### 2. 比较内部碎片和外部碎片的产生原因和解决方法

| 特性 | 内部碎片 | 外部碎片 |
|------|---------|---------|
| **定义** | 分配给进程但未被使用的内存 | 未分配但太小而无法使用的内存 |
| **产生原因** | 固定大小分配，实际需求小于分配 | 动态分配回收后产生的小空闲块 |
| **存在于** | 分页系统、固定分区 | 分段系统、动态分区 |
| **解决方法** | 选择合适的页面大小 | 紧凑（内存整理）、分页 |
| **举例** | 进程需要2.5页，分配3页，0.5页浪费 | 多次分配回收后，产生许多小空闲区 |

---

#### 3. 比较抢占式调度和非抢占式调度的优缺点

| 特性 | 抢占式调度 | 非抢占式调度 |
|------|-----------|-------------|
| **定义** | 可以强制剥夺CPU | 进程主动放弃CPU |
| **响应时间** | 快 | 慢 |
| **实时性** | 好 | 差 |
| **系统开销** | 大（频繁切换）| 小 |
| **公平性** | 好 | 可能不公平 |
| **适用场景** | 分时系统、实时系统 | 批处理系统 |
| **算法举例** | 时间片轮转、优先级抢占 | FCFS、SJF（非抢占）|

---

#### 4. 比较集中式目录和分散式目录（索引节点）的优缺点

| 特性 | 集中式目录（FCB）| 分散式目录（Inode）|
|------|-----------------|-------------------|
| **存储方式** | 目录项包含所有文件信息 | 目录项只含文件名和Inode号 |
| **查找效率** | 较低（目录项大）| 较高（目录项小）|
| **磁盘I/O** | 多 | 少 |
| **硬链接支持** | 困难（需复制FCB）| 容易（共享Inode）|
| **优点** | 实现简单 | 节省空间、支持硬链接 |
| **缺点** | 占用空间大、查找慢 | 实现复杂 |
| **代表系统** | 早期DOS | UNIX/Linux |

---

#### 5. 比较绝对路径和相对路径的使用场景

| 特性 | 绝对路径 | 相对路径 |
|------|---------|---------|
| **起点** | 根目录 | 当前目录 |
| **表示** | /home/user/file.txt | ../file.txt |
| **可移植性** | 差（路径固定）| 好（相对位置）|
| **长度** | 通常较长 | 通常较短 |
| **适用场景** | 系统配置、脚本 | 项目内部引用 |
| **举例** | /usr/bin/python | ./scripts/run.sh |

---

## 🔧 题型四：算法设计与分析

### 练习7：页面置换算法改进
请设计一个改进的Clock算法，考虑页面的访问位（A）和修改位（M），优先级从高到低为：
- (A=0, M=0)：最近未访问且未修改
- (A=0, M=1)：最近未访问但已修改
- (A=1, M=0)：最近访问但未修改
- (A=1, M=1)：最近访问且已修改

请说明算法流程，并分析其优点。

**算法流程**：

```
改进Clock算法（NRU - Not Recently Used）：

1. 初始化：时钟指针指向某个页框

2. 第一遍扫描：查找(A=0, M=0)的页面
   - 如果找到，替换该页面
   - 如果没找到，进入第二遍扫描

3. 第二遍扫描：查找(A=0, M=1)的页面
   同时将所有扫描过的页面的A位置0
   - 如果找到，替换该页面
   - 如果没找到，进入第三遍扫描

4. 第三遍扫描：查找(A=0, M=0)的页面
   （此时所有页面A位都已置0）
   - 必定能找到

5. 特殊优化：
   - 修改过的页面(M=1)需要写回磁盘，代价高
   - 优先替换未修改的页面(M=0)，减少磁盘写操作
```

**优点分析**：
1. ✅ 考虑了修改位，减少磁盘写操作
2. ✅ 近似LRU，性能好
3. ✅ 实现简单，开销小
4. ✅ 避免了Belady异常

---

### 练习8：动态分区分配算法对比
给定内存块序列：100KB, 500KB, 200KB, 300KB, 600KB
进程请求序列：
- P1请求200KB
- P2请求400KB
- P3请求100KB
- P1释放
- P4请求300KB

分别用首次适应、最佳适应、最坏适应算法进行分配，比较结果。

**首次适应（First Fit）**：
```
初始：[100] [500] [200] [300] [600]

P1(200KB): 
  - 扫描：100（不够）→ 500（够，分配）
  - 结果：[100] [P1:200|300] [200] [300] [600]

P2(400KB):
  - 扫描：100（不够）→ 300（不够）→ 200（不够）→ 300（不够）→ 600（够，分配）
  - 结果：[100] [P1:200|300] [200] [300] [P2:400|200]

P3(100KB):
  - 扫描：100（够，分配）
  - 结果：[P3:100] [P1:200|300] [200] [300] [P2:400|200]

P1释放:
  - 结果：[P3:100] [200|300] [200] [300] [P2:400|200]

P4(300KB):
  - 扫描：200（不够）→ 300（够，分配）
  - 结果：[P3:100] [200|P4:300] [200] [300] [P2:400|200]

成功分配：4个进程全部分配成功
```

**最佳适应（Best Fit）**：
```
初始：[100] [500] [200] [300] [600]

P1(200KB):
  - 找最小满足块：200（最佳）
  - 结果：[100] [500] [P1:200] [300] [600]

P2(400KB):
  - 找最小满足块：500（最佳）
  - 结果：[100] [P2:400|100] [P1:200] [300] [600]

P3(100KB):
  - 找最小满足块：100（最佳，两个都是100，选第一个）
  - 结果：[P3:100] [P2:400|100] [P1:200] [300] [600]

P1释放:
  - 结果：[P3:100] [P2:400|100] [200] [300] [600]

P4(300KB):
  - 找最小满足块：300（最佳）
  - 结果：[P3:100] [P2:400|100] [200] [P4:300] [600]

成功分配：4个进程全部分配成功
```

**最坏适应（Worst Fit）**：
```
初始：[100] [500] [200] [300] [600]

P1(200KB):
  - 找最大空闲块：600
  - 结果：[100] [500] [200] [300] [P1:200|400]

P2(400KB):
  - 找最大空闲块：500
  - 结果：[100] [P2:400|100] [200] [300] [P1:200|400]

P3(100KB):
  - 找最大空闲块：400
  - 结果：[100] [P2:400|100] [200] [300] [P1:200|P3:100|300]

P1释放（注意：P1后面还有P3占用，所以只释放P1的200KB）:
  - 结果：[100] [P2:400|100] [200] [300] [200|P3:100|300]

P4(300KB):
  - 找最大空闲块：300（有多个，选第一个）
  - 结果：[100] [P2:400|100] [200] [P4:300] [200|P3:100|300]

成功分配：4个进程全部分配成功
```

**算法对比**：

| 算法 | 优点 | 缺点 | 适用场景 |
|------|------|------|---------|
| **首次适应** | 速度快，简单 | 低地址产生碎片 | 一般情况 |
| **最佳适应** | 空间利用率高 | 产生大量小碎片 | 内存紧张 |
| **最坏适应** | 避免小碎片 | 大空闲块被快速分割 | 大小均匀的请求 |

**本例总结**：
- 三种算法都成功分配了所有进程
- 首次适应和最佳适应产生的碎片分布不同
- 最坏适应保留了较大的连续空闲块

---

## 🎯 高频易错知识点集锦

### 1. 进程同步易错点
- ❌ 先P(mutex)再P(资源)会死锁 → ✅ 先P(资源)再P(mutex)
- ❌ 忘记readcount需要互斥保护
- ❌ 把资源计数器当成信号量定义
- ❌ V操作顺序错误

### 2. 地址计算易错点
- ❌ 页内偏移位数 = log₂(页面大小) 不要算错
- ❌ 物理地址 = 页框号×页面大小 + 页内偏移（不要忘记乘）
- ❌ 十六进制和十进制转换要小心
- ❌ 快表有效访问时间计算：未命中要访问2次内存

### 3. 银行家算法易错点
- ❌ Need = Max - Allocation（减法方向别搞反）
- ❌ Available = 总资源 - 已分配（不是Max）
- ❌ Work = Work + Allocation[i]（是加Allocation，不是加Need）
- ❌ 安全性检查要完整执行所有进程

### 4. 页面置换算法易错点
- ❌ FIFO是按进入时间，不是按页号大小
- ❌ LRU是最久未使用，不是最早进入
- ❌ 缺页率 = 缺页次数 / 总访问次数
- ❌ Clock算法第二次扫描才置换

### 5. 文件系统易错点
- ❌ 地址项数 = 块大小/地址长度（别忘了除法）
- ❌ 文件数量受限于索引节点数和数据块数的最小值
- ❌ 访问次数要算上索引表的访问
- ❌ 位示图大小计算：总块数/8（bit→byte）

### 6. 调度算法易错点
- ❌ 周转时间 = 完成时间 - 到达时间（不要忘记减）
- ❌ 带权周转时间 = 周转时间 / 服务时间
- ❌ SJF要从已到达的进程中选最短的
- ❌ 优先级调度：数字小优先级高（通常）

### 7. 磁盘调度易错点
- ❌ SCAN到达边界后反方向移动
- ❌ C-SCAN到达边界后直接跳到另一端
- ❌ 寻道长度是移动的柱面数，不是访问次数
- ❌ 要考虑当前移动方向

---

## ✅ 最后检查清单

### 考前1天必做：
- [ ] 快速过一遍进程同步的5个经典问题
- [ ] 默写银行家算法的4个步骤
- [ ] 练习3道页面置换算法题（包括地址转换）
- [ ] 复习混合索引的计算方法
- [ ] 看一遍所有对比表格（进程vs线程、分页vs分段等）
- [ ] 检查模拟试卷的错题

### 考试时注意：
- ✅ **进程同步题**：信号量初始值、cobegin/coend、PV顺序
- ✅ **问答题**：画图要清晰，计算过程要完整
- ✅ **选择题**：仔细读题，注意"错误的是"还是"正确的是"
- ✅ **简答题**：结合操作系统原理，不要只写定义
- ✅ **时间管理**：
  - 填空题：10分钟
  - 选择题：15分钟
  - 设计题：20分钟
  - 问答题：60分钟
  - 简答题：25分钟
  - 检查：10分钟

### 常用公式速查：
```
1. 有效访问时间（快表）
   EAT = h × (TLB + M) + (1-h) × (TLB + 2M)

2. 周转时间
   T周转 = T完成 - T到达

3. 带权周转时间
   W = T周转 / T服务

4. 页号和页内偏移
   页号 = 逻辑地址 / 页面大小（取整）
   偏移 = 逻辑地址 % 页面大小

5. 物理地址
   物理地址 = 页框号 × 页面大小 + 页内偏移

6. 最大文件长度（混合索引）
   L = n₁B + n₂(B/A)B + n₃(B/A)²B + n₄(B/A)³B

7. 缺页率
   缺页率 = 缺页次数 / 总访问次数

8. 磁盘平均访问时间
   T = T寻道 + T旋转 + T传输
```

---

## 🎓 考试必备术语中英对照

| 中文 | 英文 | 缩写 |
|------|------|------|
| 进程 | Process | - |
| 线程 | Thread | - |
| 互斥 | Mutual Exclusion | - |
| 同步 | Synchronization | - |
| 信号量 | Semaphore | - |
| 临界区 | Critical Section | CS |
| 死锁 | Deadlock | - |
| 饥饿 | Starvation | - |
| 先来先服务 | First Come First Served | FCFS |
| 短作业优先 | Shortest Job First | SJF |
| 时间片轮转 | Round Robin | RR |
| 先进先出 | First In First Out | FIFO |
| 最近最久未使用 | Least Recently Used | LRU |
| 最佳置换 | Optimal | OPT |
| 文件控制块 | File Control Block | FCB |
| 索引节点 | Index Node | Inode |
| 直接存储器访问 | Direct Memory Access | DMA |
| 假脱机技术 | Simultaneous Peripheral Operation On-Line | SPOOL |

---

**祝您考试顺利，取得好成绩！🎉**


