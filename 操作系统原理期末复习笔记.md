# 操作系统原理期末复习笔记

---

## 📋 考试题型与分值分布

### 题型总览
| 题型 | 题量 | 分值 | 考察内容 | 对应课程目标 |
|------|------|------|---------|------------|
| **并发设计题** | 2道 | 15分 | 信号量进程同步 | 课程目标二 |
| **问答题** | 4道 | 40分 | 四大核心算法 | 课程目标一 |
| **选择题** | 若干 | 若干 | 概念、性能比较 | 课程目标三 |
| **简答题** | 1道 | 10分 | 新技术与原理关联 | 课程目标四 |

### 重点题型分析

#### 🎯 问答题（40分）- 必须掌握的基本分
> **这是及格的关键！必须非常熟练！**

1. **进程调度算法**（约10分）
   - 要求：绘制甘特图 + 性能分析
   - 内容：
     - 画甘特图（展示调度过程）
     - 计算周转时间、带权周转时间
     - 计算平均周转时间、平均带权周转时间
     - 分析算法特点、适用场景

2. **银行家算法**（约10分）
   - 位置：进程管理 → 死锁 → 死锁避免
   - 流程：
     1. 合法性检查（请求是否在范围内）
     2. 试分配（假设分配，进入新状态）
     3. **安全性检查**（核心：找安全序列）
     4. 真正分配或回退

3. **页面置换算法**（约10分）
   - ⚠️ **综合性题型**：可能给逻辑地址串
   - 需要：先把逻辑地址转换为页号
   - 算法：FIFO、OPT（最佳置换）、LRU、Clock（近似LRU）

4. **文件物理结构**（约10分）
   - 重点：**混合索引**（最实用）
   - 内容：连续文件、链接文件、索引文件
   - 层次：一级索引、二级索引、三级索引
   - 要求：不仅会算，还要会分析

#### 🔧 并发设计题（15分）
- 2道题，写伪代码
- 分析互斥问题 → 互斥信号量
- 分析合作问题 → 同步信号量
- 综合问题 → 两种信号量都要用
- 添加PV操作

#### 📝 简答题（10分）
- 考察新技术与基本原理的关联
- 考察计算机行业最新发展
- 不会直接考书本知识
- 需要拓展知识面

---

## 一、进程同步问题

### 1.1 解决进程同步问题的标准流程

1. **分析问题**：识别两类问题
   - **互斥问题**：访问临界资源（临界区）
   - **合作问题**：进程之间直接的相互合作（前后次序关系）

2. **定义信号量**：
   - 互斥问题 → 定义**互斥信号量**（初始值通常为1）
   - 合作问题 → 定义**资源信号量**（初始值通常为0）

3. **添加PV操作**：
   - **P操作（wait）**：资源申请，放在进入区
   - **V操作（signal）**：资源释放，放在退出区

### 1.2 答题要点（三个必备部分）⭐

> **老师阅卷会找的评分点：**

1. **信号量的定义和初始化** — 初始值一定要写对！
2. **并发进程的表示** — 使用 `cobegin/coend` 表示并发
3. **PV操作的位置** — 注意顺序，避免死锁

---

### 1.3 经典例题

#### 例题1：水果盘问题（生产者消费者简化版）

**题目描述**：
- 父亲往盘子里放苹果
- 母亲往盘子里放桔子
- 女儿从盘子里取苹果吃
- 儿子从盘子里取桔子吃
- 盘子一次只能放一个水果

**分析**：
- **临界资源**：水果盘（只能放一个水果）→ 互斥信号量
- **合作关系**：
  - 父亲 → 女儿（苹果）
  - 母亲 → 儿子（桔子）

**信号量定义**：
```
Semaphore Sempty = 1;    // 空盘子，初始有1个空位
Semaphore Sapple = 0;    // 苹果数量，初始为0
Semaphore Sorange = 0;   // 桔子数量，初始为0
```

**程序代码**：
```c
main() {
    Semaphore Sempty = 1;
    Semaphore Sapple = 0;
    Semaphore Sorange = 0;
    
    cobegin
        father();
        mother();
        son();
        daughter();
    coend
}

father() {                    mother() {
    while(..) {                   while(..) {
        P(Sempty);                    P(Sempty);
        放苹果;                        放桔子;
        V(Sapple);                    V(Sorange);
    }                             }
}                             }

son() {                       daughter() {
    while(..) {                   while(..) {
        P(Sorange);                   P(Sapple);
        吃桔子;                        吃苹果;
        V(Sempty);                    V(Sempty);
    }                             }
}                             }
```

---

#### 例题2：司机与售票员问题

**题目描述**：
- 司机：启动车辆 → 正常行车 → 到站停车
- 售票员：关车门 → 售票 → 开车门
- **同步关系**：
  - 司机只有在售票员关车门后，才能启动汽车
  - 售票员只有在司机到站停车后，才能开车门

**前趋图**：
```
        启动车辆 → 行车 → 到站停车
           ↑                  ↓
         close              stop
           ↑                  ↓
        关门 → 卖票 → 开门
```

**信号量定义**：
```
semaphore close = 0;   // 关门信号
semaphore stop = 0;    // 停车信号
```

**程序代码**：
```c
void main() {
    semaphore close = 0, stop = 0;
    cobegin
        driver();
        conductor();
    coend;
}

void driver() {              // 司机
    while(TRUE) {
        wait(close);         // 等待关门
        启动车辆;
        正常行车;
        到站停车;
        signal(stop);        // 通知可以开门
    }
}

void conductor() {           // 售票员
    while(TRUE) {
        关车门;
        signal(close);       // 通知可以开车
        售票;
        wait(stop);          // 等待停车
        开车门;
        上下乘客;
    }
}
```

**关键总结**：
- 司机：`wait(close); signal(stop);`
- 售票员：`signal(close); wait(stop);`

---

#### 例题3：哲学家就餐问题（带碗变体）⭐

**题目描述**：
- n（n≥3）位哲学家围坐在一张圆桌边
- 圆桌中心有 m（m≥1）个碗
- 每两位哲学家之间有1根筷子
- 每位哲学家必须取到一个碗和两侧的筷子之后，才能就餐
- 要求：使尽可能多的哲学家同时就餐，且防止死锁

**分析**：
- **临界资源1**：筷子 → n个信号量，每个初始值为1
- **临界资源2**：碗 → 1个信号量，初始值为m

**信号量定义**：
```c
semaphore bowl;              // 用于协调哲学家对碗的使用
semaphore chopsticks[n];     // 用于协调哲学家对筷子的使用

for(int i=0; i<n; i++)
    chopsticks[i].value = 1; // 每两个哲学家之间筷子数量为1
bowl.value = m;              // 碗的数量，初始值为m
```

**程序代码**：
```c
void main() {
    // 1. 信号量定义及初始化
    semaphore bowl;
    semaphore chopsticks[n];
    for(int i=0; i<n; i++)
        chopsticks[i].value = 1;
    bowl.value = m;
    
    // 2. 并发进程
    cobegin
        p1(); p2(); ...... pn();
    coend;
}

pi() {                       // 3. 对信号量的PV操作
    while(True) {            // 哲学家的程序
        思考;
        P(bowl);             // 取碗
        P(chopsticks[i]);    // 取左边筷子
        P(chopsticks[(i+1) MOD n]);  // 取右边筷子
        就餐;
        V(chopsticks[i]);    // 放左边筷子
        V(chopsticks[(i+1) MOD n]);  // 放右边筷子
        V(bowl);             // 放碗
    }
}
```

---

#### 例题4：阅览室同步问题 ⭐

**题目描述**：
- 有一阅览室，共有100个座位
- 读者进入时必须先在登记表上登记（每一座位一表目，包括座号和读者姓名）
- 读者离开时要消掉登记内容

**分析**：
- **临界资源1**：座位 → 信号量，初始值为100
- **临界资源2**：登记表 → 互斥信号量，初始值为1
- **无合作关系**，只有多个临界资源的互斥访问

**关键问题：PV操作顺序** ⚠️

> **问题**：应该先 P(seats) 还是先 P(mutex)？

- ✅ **正确做法**：先 P(seats)，再 P(mutex)
  - 原因：先申请座位，确保有位置后再登记
  - 避免了"填了表但没位子"的情况

- ❌ **错误做法**：先 P(mutex)，再 P(seats)
  - 可能导致**死锁**：
    - 新来的读者拿到表但没座位（100个座位已满）
    - 准备离开的读者没拿到表，无法消除登记
  - 结果：表被占用，离开的人消不掉登记

**信号量定义**：
```c
semaphore seats = 100;    // 座位数量
semaphore mutex = 1;      // 登记表互斥访问
```

**程序代码**：
```c
void main() {
    semaphore seats = 100;
    semaphore mutex = 1;
    
    cobegin
        reader1();
        reader2();
        ...
        reader_n();
    coend
}

void reader() {
    P(seats);             // ①先申请座位（避免死锁）
    P(mutex);             // ②再申请登记表
    登记;
    V(mutex);             // ③释放登记表
    
    阅读;                  // 阅读过程中不占用表
    
    P(mutex);             // ④再次申请登记表
    消除登记;
    V(mutex);             // ⑤释放登记表
    V(seats);             // ⑥释放座位
}
```

**注意事项**：
1. 每个 reader 都是一个独立的进程（类似哲学家问题）
2. 座位和登记表是两个不同的临界资源
3. 登记表每次只能一个人使用（互斥访问）
4. 100个座位可以同时被100个人占用

---

## 二、进程调度

### 2.1 基本调度算法

需要掌握的内容：
1. **画三个图**：甘特图、进程状态转换图、调度过程图
2. **计算指标**：
   - 周转时间 = 完成时间 - 到达时间
   - 带权周转时间 = 周转时间 / 服务时间
   - 平均周转时间
   - 平均带权周转时间

### 2.2 动态优先数调度 ⭐

**题目背景**：
- 采用基于优先数（priority）的调度策略，选择**优先数最小**的进程运行
- 进程创建时由用户指定一个 **nice** 作为静态优先数
- 引入运行时间 **cpuTime** 和等待时间 **waitTime**，初值均为0
- 进程处于执行态时：cpuTime 定时加1，waitTime 置0
- 进程处于就绪态时：cpuTime 置0，waitTime 定时加1

**问题1**：若只用 `priority = nice`，可能会出现饥饿现象，为什么？

**答**：因为nice值大的进程可能永远得不到执行机会，一直被nice值小的进程抢占，导致饥饿。

**问题2**：设计动态优先数计算方法，避免饥饿现象

**答**：动态优先数计算公式：

$$priority = nice + n_1 \times cpuTime - n_2 \times waitTime$$

其中 $n_1$ 和 $n_2$ 均**大于0**，分别用于调整 cpuTime 和 waitTime 在进程优先数中所占的比例。

**公式解析**：
- **+cpuTime**：CPU时间越长 → priority 越大 → 优先级越低（降低已运行进程的优先级）
- **-waitTime**：等待时间越长 → priority 越小 → 优先级越高（提高等待进程的优先级）
- **waitTime的作用**：使长时间等待的进程优先数减小，优先级提高，避免产生饥饿现象

**理解思路**：
1. 优先数越小 → 优先级越高
2. CPU占用时间长的进程 → 应该降低优先级 → 增加优先数（+cpuTime）
3. 等待时间长的进程 → 应该提高优先级 → 减小优先数（-waitTime）

---

## 三、银行家算法

> 这是标准的算法题型，按照课本和课上练习的方法解答即可。

### 3.1 基本概念
- **Available**：可用资源向量
- **Max**：最大需求矩阵
- **Allocation**：分配矩阵
- **Need**：需求矩阵（Need = Max - Allocation）

### 3.2 安全性算法
1. 初始化 Work = Available，Finish[i] = false
2. 找到满足条件的进程：Finish[i] = false 且 Need[i] ≤ Work
3. Work = Work + Allocation[i]，Finish[i] = true
4. 重复步骤2-3，直到所有进程都完成或找不到满足条件的进程
5. 如果所有 Finish[i] = true，则系统处于安全状态

---

## 四、文件系统（混合索引结构）⭐⭐⭐

### 4.1 混合索引结构基础

**索引节点结构**：
```
+-------------------+
| 文件属性信息       |  ← 文件名、权限等
+-------------------+
| 直接地址项 [0]    |  ← 直接指向数据簇
| 直接地址项 [1]    |
| ...               |
| 直接地址项 [7]    |  ← 共8个直接地址项
+-------------------+
| 一级间接地址项     |  ← 指向一级索引表
+-------------------+
| 二级间接地址项     |  ← 指向二级索引表
+-------------------+
| 三级间接地址项     |  ← 指向三级索引表
+-------------------+
```

**基本参数**（常见题型）：
- 簇大小：4KB
- 索引节点大小：64B
- 地址项总数：11个（8个直接 + 1个一级 + 1个二级 + 1个三级）
- 每个地址项长度：4B

---

### 4.2 重点题型1：计算文件系统支持的最大文件长度

**计算思路**：

1. **直接寻址部分**：8 个簇
   - 直接寻址可存储：8 × 4KB = 32KB

2. **一级间接寻址**：
   - 一个簇能存放多少个地址项？4KB / 4B = **1K 个地址项**
   - 一级间接可存储：1K × 4KB = 4MB

3. **二级间接寻址**：
   - 二级索引表有 1K 个表项，每个指向一个一级索引表
   - 二级间接可存储：1K × 1K × 4KB = 4GB

4. **三级间接寻址**：
   - 三级索引表有 1K 个表项，每个指向一个二级索引表
   - 三级间接可存储：1K × 1K × 1K × 4KB = 4TB

**最大文件长度**：
```
8×4KB + 1K×4KB + 1K×1K×4KB + 1K×1K×1K×4KB
= 32KB + 4MB + 4GB + 4TB
≈ 4TB（主要由三级间接寻址决定）
```

---

### 4.3 重点题型2：文件系统存储容量计算 ⭐⭐⭐

**例题**：文件系统用 **1M 个簇**存放文件索引节点，用 **512M 个簇**存放文件数据。若一个图像文件的大小为 5600B，则该文件系统最多能存放多少个这样的图像文件？

**分析步骤**：

**第一步：计算能存储多少个索引节点**
```
1M 个簇用于存放索引节点
每个索引节点占 64B
一个簇可以存放：4KB / 64B = 64 个索引节点
总共可以存放：1M × 64 = 64M 个索引节点
```

**第二步：计算一个图像文件需要多少个簇**
```
图像文件大小：5600B
一个簇：4KB = 4096B
5600B / 4096B ≈ 1.37
需要 2 个簇来存储
```

**第三步：从数据空间角度计算**
```
512M 个簇用于存放数据
每个文件占用 2 个簇
可以存放：512M / 2 = 256M 个文件
```

**第四步：找瓶颈**
```
从索引节点角度：最多 64M 个文件
从数据空间角度：最多 256M 个文件
取最小值：min(64M, 256M) = 64M 个文件
```

**答案**：最多能存放 **64M 个**这样的图像文件

> 💡 **关键点**：文件数量受限于索引节点数量，而不仅仅是数据空间！

---

### 4.4 重点题型3：寻址时间比较 ⭐⭐

**例题**：若文件 F₁ 的大小为 6KB，文件 F₂ 的大小为 40KB，则该文件系统获取 F₁ 和 F₂ 最后一个簇的簇号需要的时间是否相同？为什么？

**分析步骤**：

**第一步：判断 F₁ 使用的寻址方式**
```
F₁ 大小：6KB
需要簇数：6KB / 4KB = 1.5 ≈ 2 个簇
直接寻址可以处理：8 个簇
结论：F₁ 使用直接寻址
```

**第二步：判断 F₂ 使用的寻址方式**
```
F₂ 大小：40KB
需要簇数：40KB / 4KB = 10 个簇
直接寻址只能处理 8 个簇
超出部分：10 - 8 = 2 个簇
结论：F₂ 需要使用一级间接寻址
```

**寻址过程对比**：

| 文件 | 寻址方式 | 访问次数 | 寻址过程 |
|------|---------|---------|---------|
| F₁ (6KB) | 直接寻址 | **1次** | 直接从索引节点读取簇号 |
| F₂ (40KB) | 一级间接寻址 | **2次** | ①读取索引节点的间接地址项<br>②访问一级索引表获取簇号 |

**答案**：
- 获取 F₁ 和 F₂ 最后一个簇的簇号需要的时间**不相同**
- **F₁** 只有 6KB，获取它最后一个簇的簇号可**直接从索引节点的直接地址项**中得到（1次访问）
- **F₂** 大小为 40KB，要获得它最后一个簇的簇号需要**访问一级间接地址索引表**才可（2次访问）

---

### 4.5 寻址方式判断规则

给定文件大小，如何判断使用哪种寻址方式：

| 文件大小范围 | 寻址方式 | 说明 |
|-------------|---------|------|
| 0 ~ 32KB | 直接寻址 | 8 × 4KB = 32KB |
| 32KB ~ 4MB | 一级间接寻址 | 需要访问一级索引表 |
| 4MB ~ 4GB | 二级间接寻址 | 需要访问二级、一级索引表 |
| 4GB ~ 4TB | 三级间接寻址 | 需要访问三级、二级、一级索引表 |

**快速判断公式**：
```
需要的簇数 = ⌈文件大小 / 4KB⌉
- 簇数 ≤ 8：直接寻址
- 8 < 簇数 ≤ 8 + 1K：一级间接寻址
- 更大：依次类推
```

---

## 五、解题技巧总结

### 5.1 进程同步问题答题模板

```c
// 1. 信号量定义及初始化
semaphore 信号量名 = 初始值;

// 2. 并发进程
void main() {
    cobegin
        进程1();
        进程2();
        ...
    coend;
}

// 3. 各进程的PV操作
void 进程1() {
    while(TRUE) {
        P(需要的资源);
        // 临界区代码
        V(释放的资源);
    }
}
```

### 5.2 常见错误
1. ❌ 忘记写信号量的初始值
2. ❌ 忘记使用 cobegin/coend 表示并发
3. ❌ PV操作顺序错误导致死锁（如阅览室问题）
4. ❌ 互斥信号量和资源信号量混淆

### 5.3 文件系统计算技巧

**技巧1：快速计算一个簇能存放多少地址项**
```
一个簇大小 / 每个地址项大小 = 4KB / 4B = 1K 个地址项
```

**技巧2：判断文件使用的寻址方式**
```
1. 计算文件需要多少个簇：⌈文件大小 / 簇大小⌉
2. 对照寻址范围：
   - ≤ 8 簇：直接寻址
   - 8 ~ 1K+8 簇：一级间接寻址
   - 更大：依次类推
```

**技巧3：计算文件系统容量瓶颈**
```
文件数量限制 = min(索引节点数量, 数据空间/每个文件占用簇数)
永远取最小值！
```

### 5.4 进程同步问题中的特殊场景

**场景1：多个临界资源的PV顺序**
- 阅览室问题：先申请资源数量多的（seats），再申请互斥的（mutex）
- 哲学家问题：先申请数量有限的（bowl），再申请两边的（chopsticks）
- **原则**：避免"拿到表但没位子"的死锁情况

**场景2：三个并发线程互斥访问不同全局变量**
- 分析每个线程访问哪些全局变量
- 为每对共享变量定义独立的互斥信号量
- 如 Y₁₃（线程1和3共享）、Y₂₃（线程2和3共享）

---

## 六、重要公式汇总

### 6.1 进程调度

**周转时间** = 完成时间 - 到达时间

**带权周转时间** = 周转时间 / 服务时间

**平均周转时间** = Σ周转时间 / 进程数

**平均带权周转时间** = Σ带权周转时间 / 进程数

**动态优先数** = nice + n₁ × cpuTime - n₂ × waitTime（n₁, n₂ > 0）

### 6.2 文件系统

**一个簇能存放的地址项数** = 簇大小 / 地址项长度 = 4KB / 4B = 1K

**最大文件长度** = 直接寻址 + 一级间接 + 二级间接 + 三级间接
- 直接寻址：8 × 4KB = 32KB
- 一级间接：1K × 4KB = 4MB
- 二级间接：1K × 1K × 4KB = 4GB
- 三级间接：1K × 1K × 1K × 4KB = 4TB

**文件需要的簇数** = ⌈文件大小 / 簇大小⌉

**索引节点总数** = 用于索引的簇数 × (簇大小 / 索引节点大小)

---

## 七、考试注意事项

### 7.1 进程同步问题
1. ✅ **一定要写**：信号量定义、初始值、cobegin/coend
2. ✅ **注意并发**：每个进程都是独立的（如reader1, reader2...）
3. ✅ **PV顺序**：先申请数量多的资源，避免死锁
4. ✅ **成对出现**：P 和 V 必须成对，缺一不可

### 7.2 进程调度
1. ✅ **画图完整**：甘特图、进程状态转换图
2. ✅ **计算准确**：周转时间、带权周转时间都要算
3. ✅ **动态优先数**：理解公式中加减的含义

### 7.3 文件系统
1. ✅ **区分概念**：簇（存储单位）vs 索引节点（文件元数据）
2. ✅ **找瓶颈**：文件数量既受索引节点限制，也受数据空间限制
3. ✅ **判断寻址方式**：根据文件大小判断使用直接还是间接寻址
4. ✅ **访问次数**：直接寻址1次，一级间接2次，以此类推

### 7.4 答题建议
1. **先列步骤**：不要直接写答案，展示思考过程
2. **单位一致**：注意 B、KB、MB 的转换
3. **向上取整**：计算簇数时使用 ⌈⌉
4. **检查完整性**：信号量初始值、cobegin/coend、所有PV操作

---

## 八、易错知识点提醒

### ⚠️ 错误1：阅览室问题的PV顺序
```c
// ❌ 错误：先申请表
P(mutex);   // 可能导致死锁
P(seats);

// ✅ 正确：先申请座位
P(seats);   // 先确保有位置
P(mutex);   // 再登记
```

### ⚠️ 错误2：忘记优先数是"越小越优先"
```
priority = nice + n1×cpuTime - n2×waitTime
         ↑                    ↑
       增大优先数           减小优先数
       降低优先级           提高优先级
```

### ⚠️ 错误3：文件容量只看数据空间
```
// ❌ 错误思路
文件数量 = 数据空间 / 每个文件大小

// ✅ 正确思路
文件数量 = min(索引节点数, 数据空间/每个文件大小)
```

### ⚠️ 错误4：混淆簇和字节
```
文件大小：5600B
一个簇：4KB = 4096B
需要簇数：⌈5600/4096⌉ = 2 个簇  ← 向上取整！
```

---

> 📝 **备注**：本笔记根据课堂PPT和老师讲解整理，涵盖进程同步、进程调度、文件系统等核心考点。祝考试顺利！🎉

---

## 九、复习大纲（按章节）

### 9.1 操作系统引论
- 操作系统的概念、特征、功能
- 操作系统的发展历程
- 操作系统的结构
- 用户接口（命令接口、系统调用）

#### 用户接口详解 ⭐
**1. 命令接口**
- **联机命令接口（交互式命令接口）**：
  - 用户通过终端逐条输入命令
  - 系统立即执行并返回结果
  - 如：Windows的CMD、Linux的Shell
  - 特点：一次一命令，适合交互操作

- **脱机命令接口（批处理命令接口）**：
  - 用户将一批命令写成作业控制文件
  - 系统成批处理这些命令
  - 如：批处理文件（.bat）
  - 特点：成批执行，提高系统效率

**2. 系统调用（System Call）** ⭐⭐
- **定义**：操作系统提供给用户程序的接口，是应用程序请求操作系统服务的唯一途径
- **调用过程**：
  1. 用户程序调用库函数
  2. 库函数将参数传递到特定寄存器
  3. 执行陷入指令（trap/int），从用户态切换到核心态
  4. 操作系统执行相应的系统调用处理程序
  5. 返回结果，从核心态切换回用户态

- **系统调用分类**：
  - **进程控制**：fork()、exit()、wait()、exec()
  - **文件管理**：open()、close()、read()、write()、lseek()
  - **设备管理**：ioctl()、read()、write()
  - **信息维护**：getpid()、alarm()、sleep()
  - **通信**：pipe()、shmget()、mmap()

**命令接口 vs 系统调用**：
| 特性 | 命令接口 | 系统调用 |
|------|---------|---------|
| 使用者 | 用户 | 程序员 |
| 形式 | 命令 | 函数调用 |
| 执行方式 | 交互/批处理 | 程序中嵌入 |

### 9.2 进程管理 ⭐⭐⭐

#### 基本概念
- **PCB（进程控制块）** — 核心数据结构
- **进程的状态**：就绪、运行、阻塞
- **进程控制**：创建、撤销、阻塞、唤醒
- **线程**：概念、与进程的区别

#### 程序、进程、线程的异同 ⭐⭐⭐

**1. 程序 vs 进程**
| 特性 | 程序 | 进程 |
|------|------|------|
| 本质 | 静态的指令集合 | 动态的执行过程 |
| 生命周期 | 永久保存 | 创建→运行→结束 |
| 组成 | 代码+数据 | 程序+数据+PCB |
| 关系 | 一个程序可对应多个进程 | 一个进程对应一个程序 |

**2. 进程 vs 线程** ⭐⭐⭐
| 特性 | 进程 | 线程 |
|------|------|------|
| **调度单位** | 传统OS中是调度单位 | 现代OS中是调度单位 |
| **资源分配** | 独立的资源分配单位 | 不拥有资源，共享进程资源 |
| **地址空间** | 独立地址空间 | 共享进程地址空间 |
| **通信** | 进程间通信（IPC）复杂 | 线程间通信简单（共享内存）|
| **开销** | 创建、切换开销大 | 创建、切换开销小 |
| **并发性** | 进程间可并发 | 同一进程的线程可并发 |
| **崩溃影响** | 不影响其他进程 | 可能导致整个进程崩溃 |

#### 线程的实现方式 ⭐⭐

**1. 用户级线程（User-Level Thread, ULT）**
- **实现位置**：线程管理在用户空间完成
- **优点**：
  - 线程切换快（无需陷入内核）
  - 可在不支持线程的OS上实现
  - 调度算法可自定义
- **缺点**：
  - 一个线程阻塞，整个进程阻塞
  - 无法利用多处理器（内核只看到进程）
- **例子**：POSIX Pthread、Java早期线程

**2. 内核级线程（Kernel-Level Thread, KLT）**
- **实现位置**：线程管理在内核空间完成
- **优点**：
  - 一个线程阻塞不影响其他线程
  - 可充分利用多处理器
  - 内核可以调度不同进程的线程
- **缺点**：
  - 线程切换需要陷入内核，开销大
  - 管理开销大
- **例子**：Windows线程、Linux线程（NPTL）

**3. 混合模型（多对多模型）**
- **实现**：n个用户级线程映射到m个内核级线程（n≥m）
- **优点**：结合了两者的优点
- **例子**：Solaris线程

#### 进程间通信（IPC）方式 ⭐⭐⭐

**1. 管道（Pipe）**
- **特点**：
  - 半双工通信（数据单向流动）
  - 只能用于父子进程或兄弟进程
  - 缓冲区大小有限
- **类型**：
  - 匿名管道（pipe）：只能用于有亲缘关系的进程
  - 命名管道（FIFO）：可用于任意进程

**2. 消息队列（Message Queue）**
- **特点**：
  - 消息链表，存放在内核中
  - 克服了信号传递信息少、管道只能承载无格式字节流的缺点
  - 异步通信
- **操作**：msgget()、msgsnd()、msgrcv()

**3. 共享内存（Shared Memory）** ⭐
- **特点**：
  - **最快的IPC方式**（无需数据拷贝）
  - 多个进程可访问同一块内存
  - 需要配合信号量进行同步
- **操作**：shmget()、shmat()、shmdt()

**4. 信号量（Semaphore）**
- **用途**：主要用于进程同步和互斥
- **操作**：P操作（wait）、V操作（signal）
- 详见"进程同步"部分

**5. 信号（Signal）**
- **特点**：
  - 用于通知进程某个事件已发生
  - 异步通信
- **例子**：SIGKILL（杀死进程）、SIGINT（Ctrl+C）、SIGSEGV（段错误）

**6. 套接字（Socket）**
- **特点**：
  - 可用于不同机器间的进程通信
  - 支持TCP/UDP协议
- **应用**：网络通信

#### 进程调度 ⭐⭐⭐（问答题必考）
- **调度方式**：抢占式、非抢占式
- **调度算法**：
  - FCFS（先来先服务）
  - SJF（短作业优先）
  - 优先级调度
  - 时间片轮转
  - 多级反馈队列
- **性能评价指标**：
  - 周转时间 = 完成时间 - 到达时间
  - 带权周转时间 = 周转时间 / 服务时间
  - 平均周转时间、平均带权周转时间

#### 死锁 ⭐⭐⭐

**死锁的四个必要条件**（四个条件同时满足才会发生死锁）：
1. **互斥条件**：资源不能被共享，一次只能被一个进程使用
2. **占有和等待**：进程持有至少一个资源，并等待获取其他进程持有的资源
3. **不可剥夺条件**：资源不能被强制剥夺，只能由持有者主动释放
4. **循环等待条件**：存在进程资源等待环路（P1→P2→...→Pn→P1）

**死锁处理的四种方法** ⭐⭐⭐

**方法1：死锁预防（Prevention）**
- **策略**：破坏死锁产生的四个必要条件之一
- **具体方法**：
  1. **破坏互斥条件**：
     - 让资源可共享（如SPOOLing技术，将独占设备改造为共享设备）
     - 缺点：很多资源本质上无法共享
  
  2. **破坏占有和等待**：
     - 方法①：进程运行前一次性申请所有资源
     - 方法②：进程申请新资源前必须释放已占有的资源
     - 缺点：资源利用率低，可能导致饥饿
  
  3. **破坏不可剥夺条件**：
     - 当进程申请资源失败时，释放已占有的所有资源
     - 缺点：实现复杂，可能造成前功尽弃
  
  4. **破坏循环等待**：
     - 对所有资源类型进行线性排序，按序申请资源
     - 例如：规定必须先申请打印机，再申请磁带机
     - 缺点：限制了用户申请资源的顺序

- **优点**：事先预防，无需检测
- **缺点**：资源利用率低，系统吞吐量小

**方法2：死锁避免（Avoidance）** ⭐⭐⭐
- **策略**：在资源分配前判断是否会导致不安全状态
- **核心算法**：**银行家算法**（详见"三、银行家算法"章节）
- **安全状态**：系统能按某种顺序为每个进程分配资源，使所有进程都能完成
- **不安全状态**：可能（但不一定）导致死锁

- **优点**：不需要破坏死锁必要条件，资源利用率较高
- **缺点**：
  - 需要事先知道进程的最大资源需求
  - 进程数量和资源数量固定
  - 算法开销大

**方法3：死锁检测（Detection）**
- **策略**：允许死锁发生，但定期检测是否发生死锁
- **检测方法**：
  - 建立资源分配图
  - 化简资源分配图（找出可完成的进程）
  - 如果图不能完全化简，则存在死锁

- **检测时机**：
  - 每次资源请求时检测（开销大但及时）
  - 定时检测（如每小时一次）
  - CPU利用率下降到某阈值时检测

**方法4：死锁解除（Recovery）**
- **前提**：已通过死锁检测发现死锁
- **解除方法**：
  1. **终止进程**：
     - 方法①：终止所有死锁进程（代价大）
     - 方法②：逐个终止进程，直到死锁解除
     - 终止顺序考虑因素：优先级、已运行时间、剩余时间、资源占用等
  
  2. **资源剥夺**：
     - 从某些进程中剥夺资源分配给其他进程
     - 被剥夺进程回退到安全状态
     - 需防止同一进程总被剥夺（饥饿）

**四种方法的比较** ⭐

| 方法 | 资源利用率 | 系统开销 | 适用场景 |
|------|-----------|---------|---------|
| **预防** | 低 | 小 | 死锁很少发生的系统 |
| **避免** | 中 | 中 | 资源需求可预知的系统 |
| **检测+解除** | 高 | 大 | 死锁频繁的系统 |
| **鸵鸟算法** | 高 | 无 | 死锁极少发生（如UNIX、Windows）|

> 💡 **鸵鸟算法**：假装死锁不存在，不做任何处理（代价小于处理开销时采用）

#### 进程同步 ⭐⭐⭐（并发设计题必考）
- **临界区、临界资源**
- **进入临界区的四个原则**：
  1. 空闲让进
  2. 忙则等待
  3. 有限等待
  4. 让权等待
- **记录型信号量**（P、V操作）
- **经典问题**：生产者-消费者问题

### 9.3 存储管理 ⭐⭐⭐

#### 基本概念

**存储管理的功能**：
1. 内存分配与回收
2. 地址转换（逻辑地址→物理地址）
3. 内存保护
4. 内存扩充（虚拟存储）

**逻辑地址 vs 物理地址** ⭐
| 概念 | 定义 | 特点 | 别名 |
|------|------|------|------|
| 逻辑地址 | 程序中使用的地址 | 相对地址，从0开始编址 | 虚拟地址、相对地址 |
| 物理地址 | 内存中的实际地址 | 绝对地址，硬件直接访问 | 实地址、绝对地址 |

**地址重定位** ⭐⭐
- **定义**：将逻辑地址转换为物理地址的过程

- **静态重定位**：
  - **时机**：程序装入内存时一次性完成
  - **特点**：程序运行期间不能移动
  - **优点**：无需硬件支持，实现简单
  - **缺点**：不灵活，不支持动态内存管理

- **动态重定位**：
  - **时机**：程序运行时每次访问内存时进行
  - **硬件支持**：需要重定位寄存器（基址寄存器）
  - **地址转换**：物理地址 = 逻辑地址 + 基址寄存器值
  - **优点**：程序可在内存中移动，支持虚拟存储
  - **缺点**：需要硬件支持，每次访存都要转换

**局部性原理** ⭐⭐
- **定义**：程序在执行时呈现出局部性规律
- **时间局部性**：最近被访问的数据很可能在不久的将来再次被访问
  - 例如：循环中的指令和变量
- **空间局部性**：如果一个存储单元被访问，其附近的单元也很可能被访问
  - 例如：数组的顺序访问、指令的顺序执行
- **意义**：
  - 虚拟存储技术的理论基础
  - 高速缓存（Cache）设计的依据
  - 页面置换算法的依据

#### 连续存储管理

**动态分区分配算法** ⭐⭐

系统维护一个**空闲分区表**或**空闲分区链**，记录每个空闲分区的起始地址和大小。

**1. 首次适应算法（First Fit, FF）**
- **策略**：从头开始查找，分配**第一个**足够大的空闲分区
- **空闲区组织**：按地址递增顺序排列
- **优点**：
  - 算法简单，查找效率高
  - 在高地址保留大的空闲分区
- **缺点**：
  - 低地址部分产生很多小碎片
  - 每次都从头查找，时间开销大

**2. 最佳适应算法（Best Fit, BF）**
- **策略**：查找**大小最接近**所需的空闲分区
- **空闲区组织**：按容量递增顺序排列
- **优点**：
  - 避免大材小用
  - 保留大的空闲分区
- **缺点**：
  - 产生很多太小而难以利用的碎片
  - 每次分配后需要重新排序（开销大）

**3. 最坏适应算法（Worst Fit, WF）**
- **策略**：分配**最大的**空闲分区
- **空闲区组织**：按容量递减顺序排列
- **优点**：
  - 剩余的分区较大，可继续使用
- **缺点**：
  - 大的空闲分区很快被用完
  - 缺乏大的空闲分区

**4. 邻近适应算法（Next Fit, NF）**
- **策略**：从**上次查找结束的位置**开始查找
- **空闲区组织**：按地址递增排列成循环链表
- **优点**：
  - 避免每次都从头查找
  - 分配和释放的开销小
- **缺点**：
  - 缺乏大的空闲分区（高低地址都可能产生碎片）

**算法性能比较** ⭐

| 算法 | 查找速度 | 内存利用率 | 碎片情况 | 适用场景 |
|------|---------|-----------|---------|---------|
| **首次适应** | 快 | 中 | 低地址碎片多 | 一般场景 |
| **最佳适应** | 慢 | 高 | 很多极小碎片 | 内存紧张 |
| **最坏适应** | 中 | 低 | 缺乏大分区 | 请求大小差异小 |
| **邻近适应** | 快 | 低 | 全局碎片 | 频繁分配释放 |

> 💡 **实际应用**：Linux内核采用首次适应算法的变种

**连续存储 vs 离散存储** ⭐⭐

| 特性 | 连续存储 | 离散存储（分页/分段）|
|------|---------|-------------------|
| **内存分配** | 连续的物理空间 | 分散的物理空间 |
| **地址转换** | 简单（基址+偏移）| 复杂（需要页表/段表）|
| **碎片问题** | 外部碎片严重 | 分页：内部碎片；分段：外部碎片 |
| **内存利用率** | 低（碎片多） | 高 |
| **支持虚拟存储** | 不支持 | 支持 |
| **程序大小限制** | 受最大连续空间限制 | 可以大于物理内存 |
| **硬件支持** | 简单 | 需要页表/段表硬件 |
| **例子** | 早期DOS系统 | 现代操作系统 |

#### 离散存储管理 ⭐⭐⭐

**分页存储管理**

**1. 基本概念**
- **页面（Page）**：将逻辑地址空间分成固定大小的块（如4KB）
- **页框（Page Frame）/物理块**：将物理内存分成相同大小的块
- **页表（Page Table）**：记录页号到页框号的映射关系

**2. 地址变换机制** ⭐⭐⭐

**逻辑地址结构**：
```
|   页号 P   |   页内偏移 W   |
```

**地址转换过程**（无快表）：
1. 从逻辑地址中分离出页号P和页内偏移W
2. 查页表，得到页框号F
3. 物理地址 = F × 页面大小 + W

**访问内存次数**：2次（1次访问页表 + 1次访问数据）

**3. 快表（TLB, Translation Lookaside Buffer）** ⭐⭐

- **定义**：高速缓存中的页表副本，存放最近使用的页表项
- **作用**：减少访问页表的次数，提高地址变换速度

**地址转换过程**（有快表）：
1. 从逻辑地址中分离出页号P和页内偏移W
2. 查快表（TLB）：
   - **命中**：直接得到页框号F（1次访存）
   - **未命中**：查页表，得到页框号F，并将该页表项加入快表（2次访存）
3. 物理地址 = F × 页面大小 + W

**有效访问时间计算** ⭐
```
EAT = h × (t + m) + (1-h) × (t + 2m)
    = t + (2-h) × m
```
其中：
- h：快表命中率（如0.9）
- t：查找快表的时间（如10ns）
- m：访问内存的时间（如100ns）

**例子**：
- 快表命中率h=90%，t=10ns，m=100ns
- EAT = 10 + (2-0.9)×100 = 10 + 110 = 120ns
- 加速比 = 200ns / 120ns = 1.67

**4. 多级页表** ⭐⭐
- **目的**：减少页表占用的连续内存空间
- **原理**：将页表再分页
- **二级页表地址结构**：
```
|  一级页号  |  二级页号  |  页内偏移  |
```
- **访问次数**：3次（一级页表 + 二级页表 + 数据）

**5. 反置页表**
- **原理**：按物理块号建立页表（不是按页号）
- **优点**：页表大小与物理内存成正比，与逻辑地址空间无关
- **缺点**：查找速度慢（需要检索整个表）

**分页存储管理方案比较** ⭐

| 方案 | 页表大小 | 访存次数 | 适用场景 |
|------|---------|---------|---------|
| **基本分页** | 大（与逻辑地址空间成正比）| 2次 | 小地址空间 |
| **基本分页+快表** | 大 | 1~2次 | 一般场景 |
| **多级页表** | 小（离散存储）| 3次+ | 大地址空间 |
| **反置页表** | 小（与物理内存成正比）| 慢（需检索）| 超大地址空间 |

**分段存储管理**

**1. 基本概念**
- **段**：按程序的逻辑结构划分（代码段、数据段、栈段等）
- **段表**：记录段号到段起始地址和段长的映射

**2. 地址变换**
**逻辑地址结构**：
```
|   段号 S   |   段内偏移 W   |
```

**地址转换过程**：
1. 从逻辑地址中分离出段号S和段内偏移W
2. 查段表，得到段起始地址A和段长L
3. 检查：W < L？（越界保护）
4. 物理地址 = A + W

**分页 vs 分段** ⭐⭐

| 特性 | 分页 | 分段 |
|------|------|------|
| **划分依据** | 物理划分（固定大小）| 逻辑划分（可变大小）|
| **大小** | 固定（如4KB）| 可变 |
| **地址空间** | 一维（页号+偏移）| 二维（段号+段内偏移）|
| **用户感知** | 透明（用户不感知）| 可见（如代码段、数据段）|
| **碎片** | 内部碎片 | 外部碎片 |
| **共享** | 不方便 | 方便（共享代码段）|
| **保护** | 不方便 | 方便（不同段不同权限）|

**段页式存储管理**
- **思想**：结合分段和分页的优点
- **结构**：先分段，段内再分页
- **地址**：段号 + 段内页号 + 页内偏移
- **优点**：既有分段的逻辑性，又有分页的高内存利用率

**内存保护** ⭐⭐

**1. 上下界寄存器保护**
- **原理**：设置上界和下界寄存器，检查访问地址是否越界
- **适用**：连续存储分配

**2. 页表保护**
- **存在位（P位）**：指示页面是否在内存中
- **读写位（R/W位）**：控制读写权限
- **用户/内核位（U/S位）**：区分用户态和内核态访问
- **脏位（D位）**：指示页面是否被修改过

**3. 段表保护**
- **段长**：检查是否越界
- **访问权限**：读、写、执行权限

**内存扩充** ⭐⭐

**1. 覆盖技术（Overlay）**
- **原理**：将程序划分为若干模块，不同时运行的模块共享内存
- **特点**：
  - 需要程序员手工划分
  - 增加编程负担
- **应用**：早期内存不足的系统

**2. 交换技术（Swapping）**
- **原理**：将暂时不运行的进程换出到磁盘，需要时再换入内存
- **特点**：
  - 以进程为单位
  - 换入换出开销大
- **应用**：多道程序系统

**3. 虚拟存储技术** ⭐⭐⭐
- **原理**：只将进程的部分页面装入内存，其余放在磁盘上
- **基础**：局部性原理
- **特点**：
  - 逻辑地址空间可以大于物理内存
  - 对用户透明
  - 需要页面置换算法
- **实现**：请求分页、请求分段、请求段页式
- **应用**：现代操作系统的标准技术

**内存扩充技术比较**

| 技术 | 单位 | 透明性 | 开销 | 适用场景 |
|------|------|--------|------|---------|
| **覆盖** | 模块 | 不透明（需程序员划分）| 小 | 早期单道系统 |
| **交换** | 进程 | 透明 | 大 | 多道程序系统 |
| **虚拟存储** | 页/段 | 透明 | 中 | 现代操作系统 |

#### 虚拟存储管理 ⭐⭐⭐

**基本原理**：
- **理论基础**：局部性原理（时间局部性 + 空间局部性）
- **核心思想**：
  - 只将进程当前需要的部分装入内存
  - 逻辑地址空间可以大于物理内存
  - 不需要的页面放在磁盘（外存）上

**请求分页系统**
- **页表扩充**：
  - **存在位（P）**：1表示在内存，0表示在外存
  - **访问位（A）**：最近是否被访问（用于LRU算法）
  - **修改位（M）**：页面是否被修改过（若修改需写回磁盘）
  - **外存地址**：页面在外存中的位置

**缺页中断（Page Fault）**
- **发生时机**：访问的页面不在内存中（存在位P=0）
- **处理过程**：
  1. 检查内存是否有空闲页框
  2. 若无空闲页框，选择一页进行置换（页面置换算法）
  3. 若被换出页面被修改过（M=1），写回外存
  4. 将所需页面从外存调入内存
  5. 修改页表（P=1，更新页框号）
  6. 重新执行产生缺页的指令

**页面置换算法** ⭐⭐⭐（问答题必考）：
详见前文"三、银行家算法"之后的问答题章节，包括：
- FIFO（先进先出）
- OPT（最佳置换）
- LRU（最近最久未使用）
- Clock（时钟算法，LRU的近似）

**综合题型**：逻辑地址 → 页号转换 + 页面置换

**重要概念详解**

**1. 抖动（Thrashing）** ⭐⭐⭐

- **定义**：进程频繁地发生缺页中断，系统把大部分时间用于页面换入换出，而不是执行进程

- **产生原因**：
  - 分配给进程的页框数太少
  - 同时运行的进程数过多
  - 进程的工作集大于分配的页框数

- **表现特征**：
  - CPU利用率急剧下降
  - 缺页率急剧上升
  - 磁盘I/O频繁
  - 系统吞吐量下降

- **解决方法**：
  1. **增加物理内存**
  2. **减少并发进程数**（暂停部分进程）
  3. **采用局部页面置换策略**（不影响其他进程）
  4. **调整工作集大小**
  5. **使用工作集算法或缺页率算法**

**2. 工作集（Working Set）** ⭐⭐

- **定义**：某段时间间隔内，进程实际访问的页面集合

- **工作集窗口Δ**：观察的时间窗口大小
  - Δ太小：无法包含整个局部性
  - Δ太大：包含多个局部性，增加内存负担

- **工作集页面置换算法**：
  - 原理：移除不在工作集内的页面
  - 优点：减少缺页率，防止抖动
  - 缺点：需要维护访问时间，开销大

**3. 缺页率（Page Fault Rate）**

- **计算**：缺页率 = 缺页次数 / 总访问次数

- **缺页率置换算法**：
  - 设置缺页率上限和下限
  - 缺页率高于上限：增加页框数
  - 缺页率低于下限：减少页框数

**访问分析示例** ⭐

**例题**：假设有4个页框，初始为空，访问页面序列为：1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5

**FIFO算法分析**：
```
访问页面：  1   2   3   4   1   2   5   1   2   3   4   5
页框1：    1   1   1   1   5   5   5   5   5   3   3   3
页框2：        2   2   2   2   2   2   2   2   2   4   4
页框3：            3   3   3   3   3   3   3   3   3   5
页框4：                4   4   4   4   4   4   4   4   4
缺页？     ✓   ✓   ✓   ✓   ×   ×   ✓   ×   ×   ✓   ✓   ✓

缺页次数：9次
缺页率：9/12 = 75%
```

**虚拟存储性能分析** ⭐

**有效访问时间计算**：
```
EAT = (1-p) × m + p × 缺页处理时间
```
其中：
- p：缺页率
- m：内存访问时间（如100ns）
- 缺页处理时间 = 页面调入时间 + 可能的页面换出时间 + 重启开销

**例子**：
- 内存访问时间 m = 100ns
- 缺页率 p = 0.01（1%）
- 缺页处理时间 = 8ms = 8,000,000ns

```
EAT = 0.99 × 100 + 0.01 × 8,000,000
    = 99 + 80,000
    = 80,099ns ≈ 80μs
```

> 💡 **结论**：即使很低的缺页率（1%），也会显著降低系统性能（800倍！）

### 9.4 文件管理 ⭐⭐⭐

#### 逻辑文件

**文件的概念**
- **定义**：文件是具有文件名的一组相关信息的集合
- **文件属性**：
  - 名称：唯一标识符
  - 类型：文本文件、二进制文件、可执行文件等
  - 位置：在存储设备上的位置
  - 大小：当前大小、最大大小
  - 保护：访问控制（读、写、执行）
  - 时间：创建时间、修改时间、最后访问时间
  - 用户标识：所有者

**文件操作**
- **基本操作**：创建、删除、读、写、定位、截断
- **打开文件**：将文件信息读入内存，建立打开文件表
- **关闭文件**：释放打开文件表项，将修改写回磁盘

**文件的逻辑结构** ⭐⭐

**1. 无结构文件（流式文件）**
- **特点**：由字节流组成，无明显的逻辑结构
- **例子**：文本文件、二进制文件
- **访问**：顺序访问或随机访问

**2. 有结构文件（记录式文件）**

**① 顺序文件**
- **定义**：记录按顺序排列（如按关键字排序或按存入顺序）
- **优点**：
  - 顺序访问速度快
  - 存储效率高
- **缺点**：
  - 查找、修改、插入、删除效率低
  - 随机访问困难
- **适用**：批处理应用，如工资文件

**② 索引文件**
- **定义**：为文件建立索引表，索引表包含关键字和记录地址
- **结构**：
  - 索引表：关键字 → 记录地址
  - 数据区：实际记录
- **优点**：
  - 快速查找（通过索引）
  - 支持随机访问
- **缺点**：
  - 索引表占用额外空间
  - 维护开销大
- **适用**：需要快速查找的应用

**③ 索引顺序文件**
- **定义**：结合顺序文件和索引文件的优点
- **结构**：
  - 将记录分组
  - 为每组建立索引项（组的最大关键字 + 起始地址）
  - 组内记录顺序存储
- **查找过程**：
  1. 查索引表，确定所在组
  2. 在组内顺序查找
- **优点**：
  - 查找效率高于顺序文件
  - 索引表比纯索引文件小
- **适用**：需要折中的应用

**文件逻辑结构比较** ⭐

| 结构类型 | 查找效率 | 插入删除效率 | 存储开销 | 适用场景 |
|---------|---------|-------------|---------|---------|
| **顺序文件** | 低（O(n)）| 低 | 低 | 顺序访问为主 |
| **索引文件** | 高（O(1)）| 中 | 高（索引表）| 随机访问频繁 |
| **索引顺序文件** | 中（O(√n)）| 中 | 中 | 折中方案 |

**记录的存取分析** ⭐

**定长记录 vs 变长记录**
| 特性 | 定长记录 | 变长记录 |
|------|---------|---------|
| **记录大小** | 固定 | 可变 |
| **地址计算** | 简单（基址+记录号×记录长度）| 复杂（需查找）|
| **空间利用** | 可能浪费空间 | 节省空间 |
| **访问速度** | 快 | 慢 |
| **适用** | 数据库记录 | 文本文件 |

#### 物理文件 ⭐⭐⭐
- **文件的物理结构**（问答题必考）：
  1. **连续文件**
  2. **链接文件**
  3. **索引文件**：
     - 一级索引
     - 二级索引
     - 三级索引
     - **混合索引** ⭐⭐⭐（重点）

- **磁盘空间管理**：
  - 空闲块链
  - 位示图
  - 成组链接法

- **磁盘调度算法** ⭐⭐

**磁盘访问时间 = 寻道时间 + 旋转延迟时间 + 传输时间**
- **寻道时间**：磁头移动到指定磁道的时间（最主要）
- **旋转延迟时间**：磁盘旋转到指定扇区的时间
- **传输时间**：数据传输的时间

**1. 先来先服务（FCFS）**
- **策略**：按请求到达的顺序服务
- **优点**：
  - 公平，不会产生饥饿
  - 实现简单
- **缺点**：
  - 平均寻道时间长
  - 磁头移动距离大
- **适用**：请求较少的系统

**2. 最短寻道时间优先（SSTF, Shortest Seek Time First）** ⭐
- **策略**：选择距离当前磁头位置最近的请求
- **优点**：
  - 平均寻道时间短
  - 性能较好
- **缺点**：
  - 可能产生饥饿（远离磁头的请求长期得不到服务）
  - 不够公平
- **适用**：负载较重的系统

**3. 扫描算法（SCAN，电梯算法）** ⭐⭐
- **策略**：
  - 磁头沿一个方向移动，服务路径上的所有请求
  - 到达边界后，反向移动，继续服务
  - 像电梯一样往返
- **优点**：
  - 避免饥饿
  - 平均寻道时间较短
- **缺点**：
  - 两端的请求等待时间短，中间的等待时间长（不公平）
- **适用**：磁盘负载较重的系统

**4. 循环扫描（C-SCAN）** ⭐
- **策略**：
  - 磁头沿一个方向移动，服务路径上的所有请求
  - 到达边界后，快速返回起始端（不服务）
  - 重新开始扫描
- **优点**：
  - 比SCAN更公平（消除了对中间磁道的偏向）
  - 等待时间方差小
- **缺点**：
  - 返回时间是额外开销
- **适用**：负载均匀的系统

**5. LOOK 和 C-LOOK**
- **改进**：磁头移动只到最后一个请求，而不是到磁道边界
- **优点**：减少不必要的移动

**磁盘调度算法比较** ⭐⭐

**例题**：假设磁盘有200个柱面（0-199），当前磁头在53号柱面，刚刚服务过柱面50的请求。请求队列为：98, 183, 37, 122, 14, 124, 65, 67

**各算法的访问顺序**：

| 算法 | 访问顺序 | 总移动距离 |
|------|---------|-----------|
| **FCFS** | 53→98→183→37→122→14→124→65→67 | 640 |
| **SSTF** | 53→65→67→37→14→98→122→124→183 | 236 |
| **SCAN**（向右）| 53→65→67→98→122→124→183→37→14 | 208 |
| **C-SCAN**（向右）| 53→65→67→98→122→124→183→0→14→37 | 382 |

**性能分析** ⭐：

| 算法 | 平均寻道时间 | 公平性 | 饥饿问题 | 适用场景 |
|------|------------|--------|---------|---------|
| **FCFS** | 长 | 好 | 无 | 请求少 |
| **SSTF** | 短 | 差 | 有 | 请求多但分布不均 |
| **SCAN** | 较短 | 较好 | 无 | 请求多且负载重 |
| **C-SCAN** | 较短 | 好 | 无 | 请求多且分布均匀 |

**实际应用**：
- Linux：默认使用改进的SCAN算法（Deadline、CFQ调度器）
- Windows：使用类似SCAN的算法

#### 文件系统

**FCB（文件控制块）** ⭐⭐
- **定义**：存放文件控制信息的数据结构，用于描述和控制文件
- **内容**：
  - **基本信息**：文件名、文件类型、文件大小
  - **存取控制信息**：文件权限、所有者
  - **物理地址信息**：文件在磁盘上的位置
  - **管理信息**：创建时间、修改时间、访问时间

**索引节点（Inode）** ⭐⭐
- **定义**：FCB的扩展，将文件名与文件其他信息分离
- **优点**：
  - 减小目录项大小（目录项只包含文件名和索引节点号）
  - 减少磁盘I/O次数
  - 便于文件共享
- **应用**：UNIX/Linux文件系统

**目录结构** ⭐⭐⭐

**1. 单级目录结构**
```
目录
├─ 文件1
├─ 文件2
└─ 文件3
```
- **特点**：所有文件在同一目录下
- **优点**：简单
- **缺点**：
  - 不允许重名
  - 不便于分类管理
  - 查找效率低
- **适用**：单用户系统

**2. 二级目录结构**
```
主目录（MFD）
├─ 用户1目录（UFD1）
│   ├─ 文件1
│   └─ 文件2
├─ 用户2目录（UFD2）
│   ├─ 文件1
│   └─ 文件3
```
- **特点**：第一级为主文件目录（MFD），第二级为用户文件目录（UFD）
- **优点**：
  - 不同用户可以有同名文件
  - 提高了查找效率
  - 便于实现文件保护
- **缺点**：
  - 用户不能对文件分类
  - 不便于用户间文件共享
- **适用**：多用户系统

**3. 树形目录结构（多级目录）** ⭐
```
根目录 /
├─ home
│   ├─ user1
│   │   ├─ doc
│   │   │   └─ file1.txt
│   │   └─ photo
│   │       └─ pic1.jpg
│   └─ user2
└─ etc
```
- **特点**：目录可以嵌套，形成树形结构
- **路径**：
  - **绝对路径**：从根目录开始（如 /home/user1/doc/file1.txt）
  - **相对路径**：从当前目录开始（如 ../user2）
- **优点**：
  - 层次清晰，便于分类管理
  - 方便文件查找和访问
  - 允许重名（不同目录下）
- **缺点**：
  - 不便于文件共享（同一文件在不同目录需要多份副本）
- **适用**：现代单用户操作系统（如Windows、个人Linux）

**4. 有向无环图（DAG）目录结构** ⭐⭐
```
根目录
├─ user1
│   └─ file1 ──┐
├─ user2       │
│   └─ link ───┘（共享file1）
└─ shared
```
- **特点**：允许不同目录共享同一文件（通过链接）
- **实现方式**：
  - **符号链接（软链接）**：存储被链接文件的路径
  - **硬链接**：多个目录项指向同一索引节点
- **优点**：
  - 实现文件共享
  - 节省存储空间
- **缺点**：
  - 管理复杂
  - 删除文件时需要引用计数
  - 可能产生循环（需要避免）
- **适用**：多用户系统、网络文件系统

**目录结构比较** ⭐⭐

| 目录类型 | 文件重名 | 分类管理 | 文件共享 | 查找效率 | 复杂度 | 适用场景 |
|---------|---------|---------|---------|---------|--------|---------|
| **单级目录** | 不允许 | 不支持 | 困难 | 低 | 简单 | 早期单用户 |
| **二级目录** | 不同用户可重名 | 不支持 | 困难 | 中 | 简单 | 简单多用户 |
| **树形目录** | 不同目录可重名 | 支持 | 困难（需复制）| 高 | 中 | 现代单用户 |
| **DAG目录** | 不同目录可重名 | 支持 | 支持（链接）| 高 | 复杂 | 多用户/网络 |

**文件共享** ⭐⭐

**1. 基于索引节点的共享（硬链接）**
- **原理**：多个目录项指向同一索引节点
- **优点**：
  - 访问速度快（直接访问）
  - 一个目录项删除不影响其他
- **缺点**：
  - 只能在同一文件系统内
  - 不能跨越文件系统
  - 不能链接目录（避免循环）
- **删除处理**：使用引用计数，当计数为0时才真正删除

**2. 基于符号链接的共享（软链接）**
- **原理**：创建一个新文件，内容是被链接文件的路径名
- **优点**：
  - 可以跨越文件系统
  - 可以链接目录
  - 灵活
- **缺点**：
  - 访问速度慢（需要解析路径）
  - 原文件删除后，链接失效（悬空指针）

**3. 直接共享（复制）**
- **原理**：为每个用户维护一份副本
- **优点**：简单
- **缺点**：
  - 浪费存储空间
  - 一致性问题（一个副本修改，其他不变）

**文件共享方式比较** ⭐

| 共享方式 | 实现难度 | 访问速度 | 空间开销 | 一致性 | 跨文件系统 |
|---------|---------|---------|---------|-------|-----------|
| **硬链接** | 中 | 快 | 小 | 好 | 不支持 |
| **软链接** | 简单 | 慢 | 小 | 好 | 支持 |
| **复制** | 简单 | 快 | 大 | 差 | 支持 |

**文件保护** ⭐⭐

**1. 访问控制**

**① 访问控制列表（ACL）**
- **原理**：为每个文件维护一个列表，记录哪些用户可以进行哪些操作
- **优点**：灵活，精确控制
- **缺点**：占用空间大，管理复杂

**② 访问权限位（UNIX模式）** ⭐
```
-rwxr-xr--
 |||│││││└─ 其他用户（other）：读权限
 |||││││└── 其他用户：无写权限
 |||│││└─── 其他用户：无执行权限
 |||││└──── 组用户（group）：读权限
 |||│└───── 组用户：无写权限
 |||└────── 组用户：执行权限
 ||└─────── 所有者（owner）：读权限
 |└──────── 所有者：写权限
 └───────── 所有者：执行权限
```
- **三类用户**：
  - Owner（所有者）：文件创建者
  - Group（组）：与所有者同组的用户
  - Other（其他）：其他所有用户
- **三种权限**：
  - r（read）：读权限（4）
  - w（write）：写权限（2）
  - x（execute）：执行权限（1）
- **优点**：简单，开销小
- **缺点**：不够灵活

**③ 口令保护**
- **原理**：文件设置口令，访问时需要输入口令
- **优点**：简单
- **缺点**：
  - 口令容易遗忘
  - 不便于文件共享

**2. 加密保护**
- **原理**：对文件内容进行加密
- **优点**：安全性高
- **缺点**：加解密开销大

**文件保护方式比较** ⭐

| 保护方式 | 安全性 | 灵活性 | 开销 | 适用场景 |
|---------|-------|--------|------|---------|
| **访问控制列表** | 高 | 高 | 大 | 需要精细控制 |
| **权限位** | 中 | 中 | 小 | 一般应用（UNIX/Linux）|
| **口令保护** | 低 | 低 | 小 | 个人文件 |
| **加密** | 很高 | 低 | 大 | 敏感文件 |

### 9.5 设备管理

#### 基本概念

**I/O系统的基本组成**
1. **I/O硬件**：
   - I/O设备：键盘、鼠标、显示器、磁盘、打印机等
   - 设备控制器：控制设备与主机的接口
   - I/O通道：专用I/O处理器
2. **I/O软件**：
   - 驱动程序
   - 中断处理程序
   - 系统调用接口

**设备分类**
- **按传输速率**：
  - 低速设备：键盘、鼠标（几字节/秒）
  - 中速设备：打印机（几KB/秒）
  - 高速设备：磁盘、网卡（几MB/秒）

- **按信息交换单位** ⭐：
  - **字符设备**：以字符为单位传输（如键盘、打印机）
    - 特点：不可寻址，顺序访问
  - **块设备**：以数据块为单位传输（如磁盘）
    - 特点：可寻址，随机访问

- **按共享属性**：
  - 独占设备：一次只能分配给一个进程（如打印机）
  - 共享设备：可同时分配给多个进程（如磁盘）
  - 虚拟设备：通过SPOOLing技术将独占设备改造为共享设备

#### I/O控制方式 ⭐⭐⭐

**1. 程序直接控制（轮询）**
- **工作原理**：
  1. CPU向设备控制器发出I/O命令
  2. CPU循环检查设备状态（轮询）
  3. 数据准备好后，CPU读取数据
  4. 重复2-3，直到传输完成
- **特点**：
  - CPU完全控制I/O过程
  - CPU与外设串行工作
- **优点**：简单，不需要特殊硬件
- **缺点**：
  - **CPU利用率极低**（一直在轮询等待）
  - 一次只能处理一个I/O请求

**2. 中断驱动方式**
- **工作原理**：
  1. CPU向设备控制器发出I/O命令
  2. CPU继续执行其他任务
  3. 数据准备好后，设备发出中断信号
  4. CPU响应中断，执行中断处理程序
  5. 传输一个字或字节的数据
  6. 重复3-5，直到传输完成
- **特点**：
  - CPU与外设并行工作
  - 每传输一个数据单元就中断一次
- **优点**：
  - CPU利用率提高（可以执行其他任务）
  - 支持多个I/O请求
- **缺点**：
  - 频繁中断，CPU开销大
  - 每次只传输一个数据单元

**3. DMA（Direct Memory Access，直接存储器访问）** ⭐⭐
- **工作原理**：
  1. CPU向DMA控制器发出I/O命令（起始地址、传输字节数、操作类型）
  2. DMA控制器直接控制数据在内存和设备间传输
  3. CPU继续执行其他任务
  4. 传输完成后，DMA控制器发出中断信号
  5. CPU响应中断，进行后续处理
- **特点**：
  - 以数据块为单位传输
  - 一次中断处理整个数据块
  - 需要DMA控制器硬件支持
- **优点**：
  - 减少CPU中断次数
  - 数据传输速度快
  - CPU利用率高
- **缺点**：
  - 需要专门的DMA硬件
  - CPU与DMA可能争用总线（采用周期窃取）

**4. 通道控制方式**
- **工作原理**：
  1. CPU向通道发出I/O指令（指向通道程序）
  2. 通道执行通道程序，控制多个设备的I/O操作
  3. CPU继续执行其他任务
  4. 所有I/O操作完成后，通道发出中断
- **特点**：
  - 通道是专用的I/O处理器
  - 可以处理复杂的I/O操作
  - 可以同时控制多个设备
- **优点**：
  - CPU几乎不参与I/O过程
  - 支持多设备并行I/O
  - 适合高速、大量数据传输
- **缺点**：
  - 硬件成本高
  - 实现复杂

**I/O控制方式比较** ⭐⭐⭐

| 控制方式 | 数据传输单位 | 中断次数 | CPU参与度 | CPU利用率 | 硬件成本 | 适用设备 |
|---------|-----------|---------|----------|----------|---------|---------|
| **程序直接控制** | 字/字节 | 无中断（轮询）| 很高 | 极低 | 低 | 早期低速设备 |
| **中断驱动** | 字/字节 | 每次传输 | 高 | 低 | 低 | 低中速设备 |
| **DMA** | 数据块 | 每块传输 | 低 | 高 | 中 | 高速设备（磁盘）|
| **通道** | 数据块 | 每组操作 | 很低 | 很高 | 高 | 大型机多设备 |

**典型应用场景**：
- 键盘输入：中断驱动
- 磁盘I/O：DMA
- 大型机多设备I/O：通道控制

#### 缓冲区管理 ⭐⭐

**缓冲的作用**：
1. 缓和CPU与I/O设备速度不匹配的矛盾
2. 减少对CPU的中断频率
3. 提高CPU与I/O设备之间的并行性
4. 解决数据粒度不匹配问题

**1. 单缓冲**
```
[设备] → [缓冲区] → [用户区]
```
- **工作过程**：
  - 设备向缓冲区输入数据（时间T）
  - CPU从缓冲区读取数据到用户区（时间M）
  - CPU处理数据（时间C）
- **时间分析**：
  - 若T > C：处理一块数据的时间 = T + M
  - 若T < C：处理一块数据的时间 = C + M
  - 总时间 = max(T, C) + M
- **优点**：简单
- **缺点**：CPU与设备不能完全并行

**2. 双缓冲** ⭐
```
[设备] → [缓冲区1] ⇄ [用户区]
         [缓冲区2]
```
- **工作过程**：
  - 设备向缓冲区1输入数据
  - 同时，CPU从缓冲区2处理数据
  - 角色交换，循环进行
- **时间分析**：
  - 处理一块数据的时间 = max(T, C+M)
  - 若T > C+M：无等待
  - 若T < C+M：有等待
- **优点**：
  - 提高了并行性
  - 减少了等待时间
- **应用**：磁盘I/O、视频播放

**3. 循环缓冲（多缓冲）**
```
[设备] → [缓冲区1] → [缓冲区2] → ... → [缓冲区n] → [用户区]
```
- **工作过程**：多个缓冲区组成循环队列
- **优点**：进一步提高并行性
- **缺点**：占用内存多

**4. 缓冲池**
- **组成**：
  - 空闲缓冲队列（emq）
  - 输入队列（inq）
  - 输出队列（outq）
- **工作过程**：
  1. 输入进程从emq取缓冲区，填充数据后放入inq
  2. 计算进程从inq取数据处理，结果放入outq
  3. 输出进程从outq取数据输出，完成后放回emq
- **优点**：
  - 灵活分配缓冲区
  - 适应多进程环境
- **应用**：操作系统内核

**缓冲技术比较** ⭐

| 缓冲技术 | 缓冲区数量 | 并行度 | 空间开销 | 处理时间 | 适用场景 |
|---------|-----------|--------|---------|---------|---------|
| **单缓冲** | 1 | 低 | 小 | max(T,C)+M | 简单I/O |
| **双缓冲** | 2 | 中 | 中 | max(T,C+M) | 一般I/O |
| **循环缓冲** | n | 高 | 大 | 进一步减少 | 高速I/O |
| **缓冲池** | 多个共享 | 高 | 大 | 灵活 | 多进程系统 |

**SPOOLing技术（假脱机技术）** ⭐
- **定义**：将独占设备改造为共享设备的技术
- **典型应用**：打印机的共享
- **组成**：
  - 输入井：磁盘上的输入缓冲区
  - 输出井：磁盘上的输出缓冲区
  - 输入进程（预输入）
  - 输出进程（缓输出）
- **工作原理**：
  1. 多个进程的打印请求先写入输出井
  2. 输出进程统一管理，依次打印
  3. 对用户来说，好像独占打印机
- **优点**：
  - 提高I/O速度
  - 将独占设备改造为共享设备
  - 实现虚拟设备
- **缺点**：需要大量磁盘空间

#### 核心数据结构

**设备控制表（DCT）**
- 记录设备类型、设备标识、设备状态、等待队列等

**控制器表（COCT）**
- 记录控制器标识、控制器状态、与设备的连接等

**通道表（CHCT）**
- 记录通道标识、通道状态、控制的设备等

**系统设备表（SDT）**
- 记录系统中所有设备的信息

---

## 十、三条复习主线 ⭐⭐⭐

### 主线一：功能角度理解操作系统

**操作系统 = 资源管理器 + 用户接口**

```
┌──────────────────────────────────────┐
│           用户与应用程序              │
└──────────────┬───────────────────────┘
               │ 用户接口
               ├─ 命令接口
               └─ 系统调用
┌──────────────┴───────────────────────┐
│          操作系统（资源管理）          │
├──────────────────────────────────────┤
│  进程管理  │  存储管理  │  文件管理  │
│  设备管理  │  作业管理  │  ......    │
└──────────────┬───────────────────────┘
               │
┌──────────────┴───────────────────────┐
│            硬件资源                   │
│  CPU │ 内存 │ 磁盘 │ I/O设备        │
└──────────────────────────────────────┘
```

**按照教材和PPT的模块顺序复习（第一轮）**

---

### 主线二：实现角度理解操作系统 ⭐⭐⭐

**操作系统 = 数据结构 + 算法**

#### 各模块核心数据结构与算法

| 模块 | 核心数据结构 | 核心算法 |
|------|-------------|---------|
| **进程管理** | **PCB**（进程控制块） | **进程调度算法**（CPU分配与回收） |
| **存储管理** | **页表**（分页存储） | **页面置换算法**（虚拟存储） |
| **文件管理** | **FCB**/索引节点 | **磁盘调度算法** |
| **设备管理** | 设备描述表、控制器表、通道表 | 设备分配算法 |

#### 进程管理
```
数据结构：PCB（进程控制块）
    ├─ 进程标识信息
    ├─ 处理机状态信息
    ├─ 进程调度信息
    └─ 进程控制信息

核心算法：进程调度算法
    ├─ FCFS
    ├─ SJF
    ├─ 优先级调度
    ├─ 时间片轮转
    └─ 多级反馈队列
```

#### 存储管理
```
数据结构：页表
    ├─ 页号 → 块号映射
    ├─ 存在位
    ├─ 访问位
    └─ 修改位

核心算法：页面置换算法
    ├─ FIFO
    ├─ OPT
    ├─ LRU
    └─ Clock
```

#### 文件管理
```
数据结构：FCB / 索引节点（Inode）
    ├─ 文件名
    ├─ 文件属性
    ├─ 物理地址
    └─ 权限信息

相关算法：磁盘调度算法
    ├─ FCFS
    ├─ SSTF
    ├─ SCAN
    └─ C-SCAN
```

**从软件实现角度串联知识点（第二轮）**

---

### 主线三：进程生命周期角度 ⭐⭐⭐

**一个进程的完整生命周期，串联所有资源管理**

```
进程的生命周期：创建 → 运行 → 结束

┌─────────────────────────────────────────────────┐
│  1. 进程创建                                     │
│     ↓                                            │
│  操作系统分配资源：                               │
│     • 内存空间（存储管理）                        │
│     • 创建PCB（进程管理）                         │
│     • 打开文件（文件管理）                        │
│     • 分配I/O设备（设备管理）                     │
└─────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────┐
│  2. 进程运行                                     │
│     ↓                                            │
│  CPU调度（进程管理）：                            │
│     • 进程调度算法                               │
│     • 就绪 ⇄ 运行 ⇄ 阻塞                         │
│                                                  │
│  内存访问（存储管理）：                           │
│     • 地址变换（页表、快表）                      │
│     • 缺页中断 → 页面置换                        │
│                                                  │
│  进程协作（进程管理）：                           │
│     • 进程同步（信号量）                         │
│     • 进程通信（共享内存、消息传递）              │
│                                                  │
│  文件访问（文件管理）：                           │
│     • 打开、读写、关闭文件                       │
│     • 索引节点、物理块访问                       │
│                                                  │
│  设备访问（设备管理）：                           │
│     • I/O请求                                    │
│     • 缓冲区管理                                 │
└─────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────┐
│  3. 进程结束                                     │
│     ↓                                            │
│  操作系统回收资源：                               │
│     • 释放内存（存储管理）                        │
│     • 关闭文件（文件管理）                        │
│     • 释放设备（设备管理）                        │
│     • 撤销PCB（进程管理）                         │
└─────────────────────────────────────────────────┘
```

#### 详细场景分析

**场景1：进程创建时**
- 操作系统为进程分配**内存空间**（存储管理）
- 创建**PCB**（进程管理）
- 如果进程需要访问文件，打开**文件**（文件管理）
- 如果需要I/O操作，分配**设备**（设备管理）

**场景2：进程运行时**
- 需要**CPU** → 进程调度（进程管理）
- 进程间关系：
  - 互斥关系 → 进程互斥（信号量）
  - 合作关系 → 进程同步、通信
- 访问内存 → 地址变换、缺页处理（存储管理）
- 访问文件 → 文件操作（文件管理）
- 访问设备 → I/O操作（设备管理）

**场景3：进程结束时**
- 释放内存（存储管理）
- 关闭文件（文件管理）
- 释放设备（设备管理）
- 撤销PCB（进程管理）

**像讲故事一样，串联整个操作系统（第三轮）**

---

## 十一、两组重要概念对比

### 对比组1：逻辑地址 vs 物理地址
| 概念 | 定义 | 特点 |
|------|------|------|
| 逻辑地址 | 程序中使用的地址 | 相对地址，需要转换 |
| 物理地址 | 内存中的实际地址 | 绝对地址，硬件直接访问 |

### 对比组2：内部碎片 vs 外部碎片
| 概念 | 定义 | 产生原因 | 解决方法 |
|------|------|---------|---------|
| 内部碎片 | 分配单元内未使用的空间 | 分页、分段时分配单元固定 | 减小页面大小 |
| 外部碎片 | 分配单元间未使用的空间 | 动态分区分配 | 紧凑（整理） |

### 对比组3：分页 vs 分段
| 特性 | 分页 | 分段 |
|------|------|------|
| 划分依据 | 物理划分（固定大小） | 逻辑划分（可变大小） |
| 大小 | 固定（如4KB） | 可变 |
| 地址空间 | 一维 | 二维 |
| 碎片 | 内部碎片 | 外部碎片 |
| 共享 | 不方便 | 方便 |

### 对比组4：进程 vs 线程
| 特性 | 进程 | 线程 |
|------|------|------|
| 资源分配单位 | 是 | 否 |
| 调度单位 | 传统OS中是 | 现代OS中是 |
| 拥有资源 | 独立的地址空间 | 共享进程资源 |
| 开销 | 大 | 小 |
| 通信 | 复杂（IPC） | 简单（共享内存） |

---

## 十二、复习建议与策略

### 三轮复习法

#### 第一轮：按章节复习（基础）
- 时间：前期
- 方法：按照PPT和教材的模块顺序
- 重点：理解基本概念、掌握核心算法
- 标准：能独立完成课后习题

#### 第二轮：按主线复习（提高）
- 时间：中期
- 方法：从"数据结构+算法"角度串联
- 重点：理解实现原理，建立知识联系
- 标准：能说清楚每个模块的核心数据结构和算法

#### 第三轮：按场景复习（深化）
- 时间：后期
- 方法：从"进程生命周期"角度串联
- 重点：横向联系各个模块，形成完整体系
- 标准：能像讲故事一样描述进程从创建到结束的全过程

### 重点题型突破

#### 问答题（40分）— 必须拿到基本分
1. **进程调度算法**：
   - 多练习画甘特图
   - 熟练计算各种时间指标
   - 理解各算法的特点和适用场景

2. **银行家算法**：
   - 掌握四个步骤
   - 重点练习安全性检查（找安全序列）
   - 理解为什么是"死锁避免"

3. **页面置换算法**：
   - ⚠️ 注意综合题型：逻辑地址 → 页号转换
   - 熟练掌握四种算法的执行过程
   - 能分析缺页率、命中率

4. **文件物理结构**：
   - 重点掌握混合索引
   - 会计算寻址次数
   - 理解不同寻址方式的适用文件大小

#### 并发设计题（15分）
- 多做经典题型（生产者消费者、读者写者、哲学家就餐等）
- 熟练掌握分析方法（互斥、同步）
- 注意PV操作的顺序（避免死锁）
- 不要忘记cobegin/coend

#### 选择题
- 注重相似概念的区分
- 注重算法性能的比较
- 多做题，培养题感

#### 简答题（10分）
- 关注计算机行业最新技术
- 思考新技术与传统原理的关联
- 平时多看技术资讯

### 时间分配建议
- 第一轮复习：50%时间
- 第二轮复习：30%时间
- 第三轮复习：15%时间
- 模拟测试：5%时间

---

## 十三、考核要点全覆盖检查 ⭐⭐⭐

> 根据期末考核方式PPT整理，确保所有考点都有覆盖

### 📝 填空题（1题）考点覆盖

#### 基本概念、原理及分析 ✅
- ✅ 操作系统的概念、特征、功能
- ✅ 原理及分析方法

#### 进程管理 ✅
- ✅ **进程的描述及特征**：PCB、进程状态、程序vs进程vs线程
- ✅ **PCB（进程控制块）**：结构、作用
- ✅ **进程控制**：创建、撤销、阻塞、唤醒

#### 存储管理 ✅
- ✅ **地址重定位**：静态重定位、动态重定位
- ✅ **局部性原理**：时间局部性、空间局部性
- ✅ **内存的分配与回收**：动态分区分配算法（FF、BF、WF、NF）
- ✅ **地址变换**：分页、分段的地址变换机制
- ✅ **内存保护**：上下界寄存器、页表保护位、段表保护
- ✅ **内存扩充**：覆盖、交换、虚拟存储

#### 文件管理 ✅
- ✅ **文件**：概念、属性、操作
- ✅ **文件系统**：功能、结构
- ✅ **FCB（文件控制块）**：结构、作用
- ✅ **目录**：单级、二级、树形、DAG
- ✅ **逻辑结构**：顺序文件、索引文件、索引顺序文件
- ✅ **磁盘访问**：磁盘调度算法

#### 设备管理 ✅
- ✅ **I/O系统组成**：硬件、软件
- ✅ **缓冲技术**：单缓冲、双缓冲、循环缓冲、缓冲池
- ✅ **磁盘技术**：磁盘结构、磁盘调度

---

### 🎨 设计题（2题）考点覆盖

#### 并发设计及系统调用的使用 ✅
- ✅ **进程同步算法**：
  - 互斥问题、同步问题分析
  - 信号量定义、PV操作
  - 经典问题：生产者-消费者、读者-写者、哲学家就餐、司机-售票员、阅览室等
- ✅ **系统调用**：
  - 定义、分类、调用过程
  - 进程控制、文件管理、设备管理等系统调用
- ✅ **命令接口的使用**：
  - 联机命令接口
  - 脱机命令接口

---

### ❓ 问答题（3题）考点覆盖

#### 典型算法的实现及分析 ✅

**1. 调度算法** ✅
- ✅ **甘特图（目特图）**：进程调度过程可视化
- ✅ **平均周转时间**：计算公式、实例
- ✅ **平均带权周转时间**：计算公式、实例
- ✅ **调度算法**：FCFS、SJF、优先级、时间片轮转、多级反馈队列
- ✅ **动态优先数**：公式推导、避免饥饿

**2. 银行家算法** ✅
- ✅ 算法流程：合法性检查→试分配→安全性检查→真正分配
- ✅ 安全性算法：找安全序列
- ✅ 典型例题分析

**3. 页面置换算法（综合）** ✅
- ✅ **逻辑地址转页号**：地址分解
- ✅ **FIFO**：先进先出
- ✅ **OPT**：最佳置换
- ✅ **LRU**：最近最久未使用
- ✅ **Clock**：时钟算法
- ✅ 综合题型：地址转换+页面置换

**4. 文件物理结构** ✅
- ✅ **连续文件**
- ✅ **链接文件**
- ✅ **索引文件**：一级、二级、三级索引
- ✅ **混合索引**：直接寻址+多级间接寻址
- ✅ 计算题：最大文件长度、寻址时间、文件系统容量

---

### ☑️ 选择题（3题）考点覆盖

#### 1. 进程管理 ✅
- ✅ **程序、进程、线程的异同**：详细对比表
- ✅ **进程控制**：创建、撤销、阻塞、唤醒
- ✅ **线程的多种实现方式**：
  - 用户级线程（ULT）
  - 内核级线程（KLT）
  - 混合模型
- ✅ **进程间多种通信方式**：
  - 管道、消息队列、共享内存
  - 信号量、信号、套接字

#### 2. 进程管理（死锁）✅
- ✅ **信号量**：定义、PV操作、应用
- ✅ **死锁处理四种方法**：
  - 预防（破坏四个必要条件）
  - 避免（银行家算法）
  - 检测（资源分配图）
  - 解除（终止进程、资源剥夺）
- ✅ **四种方法的区别**：详细对比表

#### 3. 存储管理 ✅
- ✅ **连续与离散的区别**：详细对比表
- ✅ **不同存储管理方案的比较**：
  - 固定分区、动态分区
  - 分页、分段、段页式
- ✅ **性能分析**：
  - 有效访问时间计算
  - 快表命中率分析
- ✅ **动态分区分配算法**：FF、BF、WF、NF的比较

#### 4. 存储管理（地址变换、保护、扩充）✅
- ✅ **地址变换**：
  - 分页地址变换（基本分页、多级页表）
  - 分段地址变换
  - 段页式地址变换
- ✅ **内存保护**：
  - 上下界寄存器
  - 页表保护位（P、R/W、U/S、D）
  - 段表保护（段长、访问权限）
- ✅ **内存扩充**：
  - 覆盖技术
  - 交换技术
  - 虚拟存储技术

#### 5. 虚拟存储器的实现 ✅
- ✅ **访问分析**：
  - 缺页中断处理
  - 页面置换过程
  - 有效访问时间计算
- ✅ **抖动（Thrashing）**：
  - 定义、产生原因
  - 表现特征
  - 解决方法
- ✅ **工作集**：概念、作用

#### 6. 磁盘调度算法 ✅
- ✅ **FCFS**：先来先服务
- ✅ **SSTF**：最短寻道时间优先
- ✅ **SCAN**：扫描算法（电梯算法）
- ✅ **C-SCAN**：循环扫描
- ✅ 算法比较：性能、公平性、饥饿问题

#### 7. 文件管理 ✅
- ✅ **不同文件目录结构的比较**：
  - 单级目录
  - 二级目录
  - 树形目录
  - 有向无环图（DAG）
- ✅ **不同文件共享方式的比较**：
  - 硬链接
  - 软链接（符号链接）
  - 复制
- ✅ **不同文件保护方式的比较**：
  - 访问控制列表（ACL）
  - 访问权限位（UNIX模式）
  - 口令保护
  - 加密保护

#### 8. 文件的逻辑结构 ✅
- ✅ **多种结构的比较**：
  - 顺序文件
  - 索引文件
  - 索引顺序文件
- ✅ **记录的存取分析**：
  - 定长记录 vs 变长记录
  - 地址计算

#### 9. 文件的物理结构 ✅
- ✅ **磁盘访问性能分析**：
  - 连续文件：顺序访问快
  - 链接文件：随机访问慢
  - 索引文件：随机访问快
  - 混合索引：综合性能好
- ✅ 访问时间分析：直接寻址 vs 间接寻址

#### 10. 设备管理I/O方式 ✅
- ✅ **多种控制方式的比较**：
  - 程序直接控制（轮询）
  - 中断驱动
  - DMA（直接存储器访问）
  - 通道控制
- ✅ 详细对比表：数据传输单位、中断次数、CPU参与度、适用设备

---

### 💬 简答题（4题）考点覆盖

#### 知识综合、拓展和实践能力 ✅
- ✅ **新技术与原理关联**：需要关注最新技术发展
- ✅ **计算机行业最新发展**：如云计算、虚拟化、容器技术等
- ✅ **实践能力**：系统调用的实际使用
- ✅ **终身学习能力**：理解基本原理，适应新技术

---

### 📊 考点覆盖率统计

| 题型 | 题量 | 考点总数 | 已覆盖 | 覆盖率 |
|------|------|---------|--------|--------|
| 填空题 | 1题 | 约20个知识点 | 20个 | ✅ 100% |
| 设计题 | 2题 | 约15个知识点 | 15个 | ✅ 100% |
| 问答题 | 3题 | 4大算法 | 4个 | ✅ 100% |
| 选择题 | 3题 | 约50个知识点 | 50个 | ✅ 100% |
| 简答题 | 4题 | 综合能力 | ✅ | ✅ 100% |

**总体覆盖率：✅ 100%**

> 💡 **备注**：所有PPT中提到的考核要点均已在笔记中详细覆盖，并配有对比表格、公式、例题和解析。

---

### 🎯 考前快速检查清单

**问答题（40分）- 必须熟练掌握**
- [ ] 能独立完成进程调度算法（画甘特图+计算指标）
- [ ] 能独立完成银行家算法（安全性检查）
- [ ] 能独立完成页面置换算法（包括地址转换）
- [ ] 能独立完成文件物理结构计算题（混合索引）

**并发设计题（15分）- 必须熟练掌握**
- [ ] 能正确分析互斥和同步问题
- [ ] 能正确定义信号量及初始值
- [ ] 能正确添加PV操作
- [ ] 记得使用cobegin/coend表示并发

**选择题 - 重点掌握比较和区别**
- [ ] 程序、进程、线程的异同
- [ ] 死锁处理四种方法的区别
- [ ] 连续与离散存储的区别
- [ ] 不同存储管理方案的比较
- [ ] I/O控制方式的比较
- [ ] 文件目录结构的比较
- [ ] 文件共享和保护方式的比较

**简答题（10分）- 关注新技术**
- [ ] 平时关注计算机行业新技术
- [ ] 思考新技术与操作系统原理的关联

---


